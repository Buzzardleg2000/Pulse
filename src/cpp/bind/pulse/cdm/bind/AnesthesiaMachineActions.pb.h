// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulse/cdm/bind/AnesthesiaMachineActions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "pulse/cdm/bind/Enums.pb.h"
#include "pulse/cdm/bind/Properties.pb.h"
#include "pulse/cdm/bind/AnesthesiaMachine.pb.h"
#include "pulse/cdm/bind/Actions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
namespace pulse {
namespace cdm {
namespace bind {
class AnesthesiaMachineActionData;
class AnesthesiaMachineActionDataDefaultTypeInternal;
extern AnesthesiaMachineActionDataDefaultTypeInternal _AnesthesiaMachineActionData_default_instance_;
class AnesthesiaMachineConfigurationData;
class AnesthesiaMachineConfigurationDataDefaultTypeInternal;
extern AnesthesiaMachineConfigurationDataDefaultTypeInternal _AnesthesiaMachineConfigurationData_default_instance_;
class AnesthesiaMachineExpiratoryValveLeakData;
class AnesthesiaMachineExpiratoryValveLeakDataDefaultTypeInternal;
extern AnesthesiaMachineExpiratoryValveLeakDataDefaultTypeInternal _AnesthesiaMachineExpiratoryValveLeakData_default_instance_;
class AnesthesiaMachineExpiratoryValveObstructionData;
class AnesthesiaMachineExpiratoryValveObstructionDataDefaultTypeInternal;
extern AnesthesiaMachineExpiratoryValveObstructionDataDefaultTypeInternal _AnesthesiaMachineExpiratoryValveObstructionData_default_instance_;
class AnesthesiaMachineInspiratoryValveLeakData;
class AnesthesiaMachineInspiratoryValveLeakDataDefaultTypeInternal;
extern AnesthesiaMachineInspiratoryValveLeakDataDefaultTypeInternal _AnesthesiaMachineInspiratoryValveLeakData_default_instance_;
class AnesthesiaMachineInspiratoryValveObstructionData;
class AnesthesiaMachineInspiratoryValveObstructionDataDefaultTypeInternal;
extern AnesthesiaMachineInspiratoryValveObstructionDataDefaultTypeInternal _AnesthesiaMachineInspiratoryValveObstructionData_default_instance_;
class AnesthesiaMachineMaskLeakData;
class AnesthesiaMachineMaskLeakDataDefaultTypeInternal;
extern AnesthesiaMachineMaskLeakDataDefaultTypeInternal _AnesthesiaMachineMaskLeakData_default_instance_;
class AnesthesiaMachineOxygenTankPressureLossData;
class AnesthesiaMachineOxygenTankPressureLossDataDefaultTypeInternal;
extern AnesthesiaMachineOxygenTankPressureLossDataDefaultTypeInternal _AnesthesiaMachineOxygenTankPressureLossData_default_instance_;
class AnesthesiaMachineOxygenWallPortPressureLossData;
class AnesthesiaMachineOxygenWallPortPressureLossDataDefaultTypeInternal;
extern AnesthesiaMachineOxygenWallPortPressureLossDataDefaultTypeInternal _AnesthesiaMachineOxygenWallPortPressureLossData_default_instance_;
class AnesthesiaMachineSodaLimeFailureData;
class AnesthesiaMachineSodaLimeFailureDataDefaultTypeInternal;
extern AnesthesiaMachineSodaLimeFailureDataDefaultTypeInternal _AnesthesiaMachineSodaLimeFailureData_default_instance_;
class AnesthesiaMachineTubeCuffLeakData;
class AnesthesiaMachineTubeCuffLeakDataDefaultTypeInternal;
extern AnesthesiaMachineTubeCuffLeakDataDefaultTypeInternal _AnesthesiaMachineTubeCuffLeakData_default_instance_;
class AnesthesiaMachineVaporizerFailureData;
class AnesthesiaMachineVaporizerFailureDataDefaultTypeInternal;
extern AnesthesiaMachineVaporizerFailureDataDefaultTypeInternal _AnesthesiaMachineVaporizerFailureData_default_instance_;
class AnesthesiaMachineVentilatorPressureLossData;
class AnesthesiaMachineVentilatorPressureLossDataDefaultTypeInternal;
extern AnesthesiaMachineVentilatorPressureLossDataDefaultTypeInternal _AnesthesiaMachineVentilatorPressureLossData_default_instance_;
class AnesthesiaMachineYPieceDisconnectData;
class AnesthesiaMachineYPieceDisconnectDataDefaultTypeInternal;
extern AnesthesiaMachineYPieceDisconnectDataDefaultTypeInternal _AnesthesiaMachineYPieceDisconnectData_default_instance_;
class AnyAnesthesiaMachineActionData;
class AnyAnesthesiaMachineActionDataDefaultTypeInternal;
extern AnyAnesthesiaMachineActionDataDefaultTypeInternal _AnyAnesthesiaMachineActionData_default_instance_;
}  // namespace bind
}  // namespace cdm
}  // namespace pulse
PROTOBUF_NAMESPACE_OPEN
template<> ::pulse::cdm::bind::AnesthesiaMachineActionData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineConfigurationData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineMaskLeakData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData>(Arena*);
template<> ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData>(Arena*);
template<> ::pulse::cdm::bind::AnyAnesthesiaMachineActionData* Arena::CreateMaybeMessage<::pulse::cdm::bind::AnyAnesthesiaMachineActionData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pulse {
namespace cdm {
namespace bind {

// ===================================================================

class AnyAnesthesiaMachineActionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnyAnesthesiaMachineActionData) */ {
 public:
  AnyAnesthesiaMachineActionData();
  virtual ~AnyAnesthesiaMachineActionData();

  AnyAnesthesiaMachineActionData(const AnyAnesthesiaMachineActionData& from);
  AnyAnesthesiaMachineActionData(AnyAnesthesiaMachineActionData&& from) noexcept
    : AnyAnesthesiaMachineActionData() {
    *this = ::std::move(from);
  }

  inline AnyAnesthesiaMachineActionData& operator=(const AnyAnesthesiaMachineActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnyAnesthesiaMachineActionData& operator=(AnyAnesthesiaMachineActionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnyAnesthesiaMachineActionData& default_instance();

  enum ActionCase {
    kConfiguration = 1,
    kExpiratoryValveLeak = 2,
    kExpiratoryValveObstruction = 3,
    kInspiratoryValveLeak = 4,
    kInspiratoryValveObstruction = 5,
    kMaskLeak = 6,
    kSodaLimeFailure = 7,
    kTubeCuffLeak = 8,
    kVaporizerFailure = 9,
    kVentilatorPressureLoss = 10,
    kYPieceDisconnect = 11,
    kOxygenWallPortPressureLoss = 12,
    kOxygenTankPressureLoss = 13,
    ACTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnyAnesthesiaMachineActionData* internal_default_instance() {
    return reinterpret_cast<const AnyAnesthesiaMachineActionData*>(
               &_AnyAnesthesiaMachineActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AnyAnesthesiaMachineActionData& a, AnyAnesthesiaMachineActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnyAnesthesiaMachineActionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnyAnesthesiaMachineActionData* New() const final {
    return CreateMaybeMessage<AnyAnesthesiaMachineActionData>(nullptr);
  }

  AnyAnesthesiaMachineActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnyAnesthesiaMachineActionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnyAnesthesiaMachineActionData& from);
  void MergeFrom(const AnyAnesthesiaMachineActionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnyAnesthesiaMachineActionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnyAnesthesiaMachineActionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kExpiratoryValveLeakFieldNumber = 2,
    kExpiratoryValveObstructionFieldNumber = 3,
    kInspiratoryValveLeakFieldNumber = 4,
    kInspiratoryValveObstructionFieldNumber = 5,
    kMaskLeakFieldNumber = 6,
    kSodaLimeFailureFieldNumber = 7,
    kTubeCuffLeakFieldNumber = 8,
    kVaporizerFailureFieldNumber = 9,
    kVentilatorPressureLossFieldNumber = 10,
    kYPieceDisconnectFieldNumber = 11,
    kOxygenWallPortPressureLossFieldNumber = 12,
    kOxygenTankPressureLossFieldNumber = 13,
  };
  // .pulse.cdm.bind.AnesthesiaMachineConfigurationData Configuration = 1;
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::pulse::cdm::bind::AnesthesiaMachineConfigurationData& configuration() const;
  ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* release_configuration();
  ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* mutable_configuration();
  void set_allocated_configuration(::pulse::cdm::bind::AnesthesiaMachineConfigurationData* configuration);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineConfigurationData& _internal_configuration() const;
  ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* _internal_mutable_configuration();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData ExpiratoryValveLeak = 2;
  bool has_expiratoryvalveleak() const;
  private:
  bool _internal_has_expiratoryvalveleak() const;
  public:
  void clear_expiratoryvalveleak();
  const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData& expiratoryvalveleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* release_expiratoryvalveleak();
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* mutable_expiratoryvalveleak();
  void set_allocated_expiratoryvalveleak(::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* expiratoryvalveleak);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData& _internal_expiratoryvalveleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* _internal_mutable_expiratoryvalveleak();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData ExpiratoryValveObstruction = 3;
  bool has_expiratoryvalveobstruction() const;
  private:
  bool _internal_has_expiratoryvalveobstruction() const;
  public:
  void clear_expiratoryvalveobstruction();
  const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData& expiratoryvalveobstruction() const;
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* release_expiratoryvalveobstruction();
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* mutable_expiratoryvalveobstruction();
  void set_allocated_expiratoryvalveobstruction(::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* expiratoryvalveobstruction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData& _internal_expiratoryvalveobstruction() const;
  ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* _internal_mutable_expiratoryvalveobstruction();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData InspiratoryValveLeak = 4;
  bool has_inspiratoryvalveleak() const;
  private:
  bool _internal_has_inspiratoryvalveleak() const;
  public:
  void clear_inspiratoryvalveleak();
  const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData& inspiratoryvalveleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* release_inspiratoryvalveleak();
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* mutable_inspiratoryvalveleak();
  void set_allocated_inspiratoryvalveleak(::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* inspiratoryvalveleak);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData& _internal_inspiratoryvalveleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* _internal_mutable_inspiratoryvalveleak();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData InspiratoryValveObstruction = 5;
  bool has_inspiratoryvalveobstruction() const;
  private:
  bool _internal_has_inspiratoryvalveobstruction() const;
  public:
  void clear_inspiratoryvalveobstruction();
  const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData& inspiratoryvalveobstruction() const;
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* release_inspiratoryvalveobstruction();
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* mutable_inspiratoryvalveobstruction();
  void set_allocated_inspiratoryvalveobstruction(::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* inspiratoryvalveobstruction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData& _internal_inspiratoryvalveobstruction() const;
  ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* _internal_mutable_inspiratoryvalveobstruction();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineMaskLeakData MaskLeak = 6;
  bool has_maskleak() const;
  private:
  bool _internal_has_maskleak() const;
  public:
  void clear_maskleak();
  const ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData& maskleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* release_maskleak();
  ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* mutable_maskleak();
  void set_allocated_maskleak(::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* maskleak);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData& _internal_maskleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* _internal_mutable_maskleak();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData SodaLimeFailure = 7;
  bool has_sodalimefailure() const;
  private:
  bool _internal_has_sodalimefailure() const;
  public:
  void clear_sodalimefailure();
  const ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData& sodalimefailure() const;
  ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* release_sodalimefailure();
  ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* mutable_sodalimefailure();
  void set_allocated_sodalimefailure(::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* sodalimefailure);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData& _internal_sodalimefailure() const;
  ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* _internal_mutable_sodalimefailure();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData TubeCuffLeak = 8;
  bool has_tubecuffleak() const;
  private:
  bool _internal_has_tubecuffleak() const;
  public:
  void clear_tubecuffleak();
  const ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData& tubecuffleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* release_tubecuffleak();
  ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* mutable_tubecuffleak();
  void set_allocated_tubecuffleak(::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* tubecuffleak);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData& _internal_tubecuffleak() const;
  ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* _internal_mutable_tubecuffleak();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData VaporizerFailure = 9;
  bool has_vaporizerfailure() const;
  private:
  bool _internal_has_vaporizerfailure() const;
  public:
  void clear_vaporizerfailure();
  const ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData& vaporizerfailure() const;
  ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* release_vaporizerfailure();
  ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* mutable_vaporizerfailure();
  void set_allocated_vaporizerfailure(::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* vaporizerfailure);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData& _internal_vaporizerfailure() const;
  ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* _internal_mutable_vaporizerfailure();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData VentilatorPressureLoss = 10;
  bool has_ventilatorpressureloss() const;
  private:
  bool _internal_has_ventilatorpressureloss() const;
  public:
  void clear_ventilatorpressureloss();
  const ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData& ventilatorpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* release_ventilatorpressureloss();
  ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* mutable_ventilatorpressureloss();
  void set_allocated_ventilatorpressureloss(::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* ventilatorpressureloss);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData& _internal_ventilatorpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* _internal_mutable_ventilatorpressureloss();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData YPieceDisconnect = 11;
  bool has_ypiecedisconnect() const;
  private:
  bool _internal_has_ypiecedisconnect() const;
  public:
  void clear_ypiecedisconnect();
  const ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData& ypiecedisconnect() const;
  ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* release_ypiecedisconnect();
  ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* mutable_ypiecedisconnect();
  void set_allocated_ypiecedisconnect(::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* ypiecedisconnect);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData& _internal_ypiecedisconnect() const;
  ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* _internal_mutable_ypiecedisconnect();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData OxygenWallPortPressureLoss = 12;
  bool has_oxygenwallportpressureloss() const;
  private:
  bool _internal_has_oxygenwallportpressureloss() const;
  public:
  void clear_oxygenwallportpressureloss();
  const ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData& oxygenwallportpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* release_oxygenwallportpressureloss();
  ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* mutable_oxygenwallportpressureloss();
  void set_allocated_oxygenwallportpressureloss(::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* oxygenwallportpressureloss);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData& _internal_oxygenwallportpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* _internal_mutable_oxygenwallportpressureloss();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData OxygenTankPressureLoss = 13;
  bool has_oxygentankpressureloss() const;
  private:
  bool _internal_has_oxygentankpressureloss() const;
  public:
  void clear_oxygentankpressureloss();
  const ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData& oxygentankpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* release_oxygentankpressureloss();
  ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* mutable_oxygentankpressureloss();
  void set_allocated_oxygentankpressureloss(::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* oxygentankpressureloss);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData& _internal_oxygentankpressureloss() const;
  ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* _internal_mutable_oxygentankpressureloss();
  public:

  void clear_Action();
  ActionCase Action_case() const;
  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnyAnesthesiaMachineActionData)
 private:
  class _Internal;
  void set_has_configuration();
  void set_has_expiratoryvalveleak();
  void set_has_expiratoryvalveobstruction();
  void set_has_inspiratoryvalveleak();
  void set_has_inspiratoryvalveobstruction();
  void set_has_maskleak();
  void set_has_sodalimefailure();
  void set_has_tubecuffleak();
  void set_has_vaporizerfailure();
  void set_has_ventilatorpressureloss();
  void set_has_ypiecedisconnect();
  void set_has_oxygenwallportpressureloss();
  void set_has_oxygentankpressureloss();

  inline bool has_Action() const;
  inline void clear_has_Action();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ActionUnion {
    ActionUnion() {}
    ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* configuration_;
    ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* expiratoryvalveleak_;
    ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* expiratoryvalveobstruction_;
    ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* inspiratoryvalveleak_;
    ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* inspiratoryvalveobstruction_;
    ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* maskleak_;
    ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* sodalimefailure_;
    ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* tubecuffleak_;
    ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* vaporizerfailure_;
    ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* ventilatorpressureloss_;
    ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* ypiecedisconnect_;
    ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* oxygenwallportpressureloss_;
    ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* oxygentankpressureloss_;
  } Action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineActionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineActionData) */ {
 public:
  AnesthesiaMachineActionData();
  virtual ~AnesthesiaMachineActionData();

  AnesthesiaMachineActionData(const AnesthesiaMachineActionData& from);
  AnesthesiaMachineActionData(AnesthesiaMachineActionData&& from) noexcept
    : AnesthesiaMachineActionData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineActionData& operator=(const AnesthesiaMachineActionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineActionData& operator=(AnesthesiaMachineActionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineActionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineActionData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineActionData*>(
               &_AnesthesiaMachineActionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AnesthesiaMachineActionData& a, AnesthesiaMachineActionData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineActionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineActionData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineActionData>(nullptr);
  }

  AnesthesiaMachineActionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineActionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineActionData& from);
  void MergeFrom(const AnesthesiaMachineActionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineActionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineActionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // .pulse.cdm.bind.ActionData Action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::pulse::cdm::bind::ActionData& action() const;
  ::pulse::cdm::bind::ActionData* release_action();
  ::pulse::cdm::bind::ActionData* mutable_action();
  void set_allocated_action(::pulse::cdm::bind::ActionData* action);
  private:
  const ::pulse::cdm::bind::ActionData& _internal_action() const;
  ::pulse::cdm::bind::ActionData* _internal_mutable_action();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineActionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::ActionData* action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineConfigurationData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineConfigurationData) */ {
 public:
  AnesthesiaMachineConfigurationData();
  virtual ~AnesthesiaMachineConfigurationData();

  AnesthesiaMachineConfigurationData(const AnesthesiaMachineConfigurationData& from);
  AnesthesiaMachineConfigurationData(AnesthesiaMachineConfigurationData&& from) noexcept
    : AnesthesiaMachineConfigurationData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineConfigurationData& operator=(const AnesthesiaMachineConfigurationData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineConfigurationData& operator=(AnesthesiaMachineConfigurationData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineConfigurationData& default_instance();

  enum OptionCase {
    kConfiguration = 2,
    kConfigurationFile = 3,
    OPTION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineConfigurationData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineConfigurationData*>(
               &_AnesthesiaMachineConfigurationData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AnesthesiaMachineConfigurationData& a, AnesthesiaMachineConfigurationData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineConfigurationData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineConfigurationData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineConfigurationData>(nullptr);
  }

  AnesthesiaMachineConfigurationData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineConfigurationData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineConfigurationData& from);
  void MergeFrom(const AnesthesiaMachineConfigurationData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineConfigurationData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineConfigurationData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kConfigurationFieldNumber = 2,
    kConfigurationFileFieldNumber = 3,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.AnesthesiaMachineData Configuration = 2;
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::pulse::cdm::bind::AnesthesiaMachineData& configuration() const;
  ::pulse::cdm::bind::AnesthesiaMachineData* release_configuration();
  ::pulse::cdm::bind::AnesthesiaMachineData* mutable_configuration();
  void set_allocated_configuration(::pulse::cdm::bind::AnesthesiaMachineData* configuration);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineData& _internal_configuration() const;
  ::pulse::cdm::bind::AnesthesiaMachineData* _internal_mutable_configuration();
  public:

  // string ConfigurationFile = 3;
  private:
  bool _internal_has_configurationfile() const;
  public:
  void clear_configurationfile();
  const std::string& configurationfile() const;
  void set_configurationfile(const std::string& value);
  void set_configurationfile(std::string&& value);
  void set_configurationfile(const char* value);
  void set_configurationfile(const char* value, size_t size);
  std::string* mutable_configurationfile();
  std::string* release_configurationfile();
  void set_allocated_configurationfile(std::string* configurationfile);
  private:
  const std::string& _internal_configurationfile() const;
  void _internal_set_configurationfile(const std::string& value);
  std::string* _internal_mutable_configurationfile();
  public:

  void clear_Option();
  OptionCase Option_case() const;
  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineConfigurationData)
 private:
  class _Internal;
  void set_has_configuration();
  void set_has_configurationfile();

  inline bool has_Option() const;
  inline void clear_has_Option();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  union OptionUnion {
    OptionUnion() {}
    ::pulse::cdm::bind::AnesthesiaMachineData* configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configurationfile_;
  } Option_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineExpiratoryValveLeakData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData) */ {
 public:
  AnesthesiaMachineExpiratoryValveLeakData();
  virtual ~AnesthesiaMachineExpiratoryValveLeakData();

  AnesthesiaMachineExpiratoryValveLeakData(const AnesthesiaMachineExpiratoryValveLeakData& from);
  AnesthesiaMachineExpiratoryValveLeakData(AnesthesiaMachineExpiratoryValveLeakData&& from) noexcept
    : AnesthesiaMachineExpiratoryValveLeakData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineExpiratoryValveLeakData& operator=(const AnesthesiaMachineExpiratoryValveLeakData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineExpiratoryValveLeakData& operator=(AnesthesiaMachineExpiratoryValveLeakData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineExpiratoryValveLeakData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineExpiratoryValveLeakData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineExpiratoryValveLeakData*>(
               &_AnesthesiaMachineExpiratoryValveLeakData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AnesthesiaMachineExpiratoryValveLeakData& a, AnesthesiaMachineExpiratoryValveLeakData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineExpiratoryValveLeakData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineExpiratoryValveLeakData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineExpiratoryValveLeakData>(nullptr);
  }

  AnesthesiaMachineExpiratoryValveLeakData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineExpiratoryValveLeakData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineExpiratoryValveLeakData& from);
  void MergeFrom(const AnesthesiaMachineExpiratoryValveLeakData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineExpiratoryValveLeakData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineExpiratoryValveObstructionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData) */ {
 public:
  AnesthesiaMachineExpiratoryValveObstructionData();
  virtual ~AnesthesiaMachineExpiratoryValveObstructionData();

  AnesthesiaMachineExpiratoryValveObstructionData(const AnesthesiaMachineExpiratoryValveObstructionData& from);
  AnesthesiaMachineExpiratoryValveObstructionData(AnesthesiaMachineExpiratoryValveObstructionData&& from) noexcept
    : AnesthesiaMachineExpiratoryValveObstructionData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineExpiratoryValveObstructionData& operator=(const AnesthesiaMachineExpiratoryValveObstructionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineExpiratoryValveObstructionData& operator=(AnesthesiaMachineExpiratoryValveObstructionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineExpiratoryValveObstructionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineExpiratoryValveObstructionData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineExpiratoryValveObstructionData*>(
               &_AnesthesiaMachineExpiratoryValveObstructionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AnesthesiaMachineExpiratoryValveObstructionData& a, AnesthesiaMachineExpiratoryValveObstructionData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineExpiratoryValveObstructionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineExpiratoryValveObstructionData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineExpiratoryValveObstructionData>(nullptr);
  }

  AnesthesiaMachineExpiratoryValveObstructionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineExpiratoryValveObstructionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineExpiratoryValveObstructionData& from);
  void MergeFrom(const AnesthesiaMachineExpiratoryValveObstructionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineExpiratoryValveObstructionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineInspiratoryValveLeakData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData) */ {
 public:
  AnesthesiaMachineInspiratoryValveLeakData();
  virtual ~AnesthesiaMachineInspiratoryValveLeakData();

  AnesthesiaMachineInspiratoryValveLeakData(const AnesthesiaMachineInspiratoryValveLeakData& from);
  AnesthesiaMachineInspiratoryValveLeakData(AnesthesiaMachineInspiratoryValveLeakData&& from) noexcept
    : AnesthesiaMachineInspiratoryValveLeakData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineInspiratoryValveLeakData& operator=(const AnesthesiaMachineInspiratoryValveLeakData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineInspiratoryValveLeakData& operator=(AnesthesiaMachineInspiratoryValveLeakData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineInspiratoryValveLeakData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineInspiratoryValveLeakData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineInspiratoryValveLeakData*>(
               &_AnesthesiaMachineInspiratoryValveLeakData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AnesthesiaMachineInspiratoryValveLeakData& a, AnesthesiaMachineInspiratoryValveLeakData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineInspiratoryValveLeakData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineInspiratoryValveLeakData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineInspiratoryValveLeakData>(nullptr);
  }

  AnesthesiaMachineInspiratoryValveLeakData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineInspiratoryValveLeakData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineInspiratoryValveLeakData& from);
  void MergeFrom(const AnesthesiaMachineInspiratoryValveLeakData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineInspiratoryValveLeakData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineInspiratoryValveObstructionData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData) */ {
 public:
  AnesthesiaMachineInspiratoryValveObstructionData();
  virtual ~AnesthesiaMachineInspiratoryValveObstructionData();

  AnesthesiaMachineInspiratoryValveObstructionData(const AnesthesiaMachineInspiratoryValveObstructionData& from);
  AnesthesiaMachineInspiratoryValveObstructionData(AnesthesiaMachineInspiratoryValveObstructionData&& from) noexcept
    : AnesthesiaMachineInspiratoryValveObstructionData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineInspiratoryValveObstructionData& operator=(const AnesthesiaMachineInspiratoryValveObstructionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineInspiratoryValveObstructionData& operator=(AnesthesiaMachineInspiratoryValveObstructionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineInspiratoryValveObstructionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineInspiratoryValveObstructionData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineInspiratoryValveObstructionData*>(
               &_AnesthesiaMachineInspiratoryValveObstructionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AnesthesiaMachineInspiratoryValveObstructionData& a, AnesthesiaMachineInspiratoryValveObstructionData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineInspiratoryValveObstructionData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineInspiratoryValveObstructionData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineInspiratoryValveObstructionData>(nullptr);
  }

  AnesthesiaMachineInspiratoryValveObstructionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineInspiratoryValveObstructionData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineInspiratoryValveObstructionData& from);
  void MergeFrom(const AnesthesiaMachineInspiratoryValveObstructionData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineInspiratoryValveObstructionData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineMaskLeakData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineMaskLeakData) */ {
 public:
  AnesthesiaMachineMaskLeakData();
  virtual ~AnesthesiaMachineMaskLeakData();

  AnesthesiaMachineMaskLeakData(const AnesthesiaMachineMaskLeakData& from);
  AnesthesiaMachineMaskLeakData(AnesthesiaMachineMaskLeakData&& from) noexcept
    : AnesthesiaMachineMaskLeakData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineMaskLeakData& operator=(const AnesthesiaMachineMaskLeakData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineMaskLeakData& operator=(AnesthesiaMachineMaskLeakData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineMaskLeakData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineMaskLeakData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineMaskLeakData*>(
               &_AnesthesiaMachineMaskLeakData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AnesthesiaMachineMaskLeakData& a, AnesthesiaMachineMaskLeakData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineMaskLeakData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineMaskLeakData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineMaskLeakData>(nullptr);
  }

  AnesthesiaMachineMaskLeakData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineMaskLeakData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineMaskLeakData& from);
  void MergeFrom(const AnesthesiaMachineMaskLeakData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineMaskLeakData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineMaskLeakData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineMaskLeakData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineSodaLimeFailureData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData) */ {
 public:
  AnesthesiaMachineSodaLimeFailureData();
  virtual ~AnesthesiaMachineSodaLimeFailureData();

  AnesthesiaMachineSodaLimeFailureData(const AnesthesiaMachineSodaLimeFailureData& from);
  AnesthesiaMachineSodaLimeFailureData(AnesthesiaMachineSodaLimeFailureData&& from) noexcept
    : AnesthesiaMachineSodaLimeFailureData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineSodaLimeFailureData& operator=(const AnesthesiaMachineSodaLimeFailureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineSodaLimeFailureData& operator=(AnesthesiaMachineSodaLimeFailureData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineSodaLimeFailureData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineSodaLimeFailureData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineSodaLimeFailureData*>(
               &_AnesthesiaMachineSodaLimeFailureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AnesthesiaMachineSodaLimeFailureData& a, AnesthesiaMachineSodaLimeFailureData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineSodaLimeFailureData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineSodaLimeFailureData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineSodaLimeFailureData>(nullptr);
  }

  AnesthesiaMachineSodaLimeFailureData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineSodaLimeFailureData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineSodaLimeFailureData& from);
  void MergeFrom(const AnesthesiaMachineSodaLimeFailureData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineSodaLimeFailureData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineTubeCuffLeakData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData) */ {
 public:
  AnesthesiaMachineTubeCuffLeakData();
  virtual ~AnesthesiaMachineTubeCuffLeakData();

  AnesthesiaMachineTubeCuffLeakData(const AnesthesiaMachineTubeCuffLeakData& from);
  AnesthesiaMachineTubeCuffLeakData(AnesthesiaMachineTubeCuffLeakData&& from) noexcept
    : AnesthesiaMachineTubeCuffLeakData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineTubeCuffLeakData& operator=(const AnesthesiaMachineTubeCuffLeakData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineTubeCuffLeakData& operator=(AnesthesiaMachineTubeCuffLeakData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineTubeCuffLeakData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineTubeCuffLeakData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineTubeCuffLeakData*>(
               &_AnesthesiaMachineTubeCuffLeakData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AnesthesiaMachineTubeCuffLeakData& a, AnesthesiaMachineTubeCuffLeakData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineTubeCuffLeakData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineTubeCuffLeakData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineTubeCuffLeakData>(nullptr);
  }

  AnesthesiaMachineTubeCuffLeakData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineTubeCuffLeakData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineTubeCuffLeakData& from);
  void MergeFrom(const AnesthesiaMachineTubeCuffLeakData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineTubeCuffLeakData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineVaporizerFailureData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData) */ {
 public:
  AnesthesiaMachineVaporizerFailureData();
  virtual ~AnesthesiaMachineVaporizerFailureData();

  AnesthesiaMachineVaporizerFailureData(const AnesthesiaMachineVaporizerFailureData& from);
  AnesthesiaMachineVaporizerFailureData(AnesthesiaMachineVaporizerFailureData&& from) noexcept
    : AnesthesiaMachineVaporizerFailureData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineVaporizerFailureData& operator=(const AnesthesiaMachineVaporizerFailureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineVaporizerFailureData& operator=(AnesthesiaMachineVaporizerFailureData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineVaporizerFailureData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineVaporizerFailureData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineVaporizerFailureData*>(
               &_AnesthesiaMachineVaporizerFailureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AnesthesiaMachineVaporizerFailureData& a, AnesthesiaMachineVaporizerFailureData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineVaporizerFailureData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineVaporizerFailureData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineVaporizerFailureData>(nullptr);
  }

  AnesthesiaMachineVaporizerFailureData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineVaporizerFailureData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineVaporizerFailureData& from);
  void MergeFrom(const AnesthesiaMachineVaporizerFailureData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineVaporizerFailureData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineVentilatorPressureLossData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData) */ {
 public:
  AnesthesiaMachineVentilatorPressureLossData();
  virtual ~AnesthesiaMachineVentilatorPressureLossData();

  AnesthesiaMachineVentilatorPressureLossData(const AnesthesiaMachineVentilatorPressureLossData& from);
  AnesthesiaMachineVentilatorPressureLossData(AnesthesiaMachineVentilatorPressureLossData&& from) noexcept
    : AnesthesiaMachineVentilatorPressureLossData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineVentilatorPressureLossData& operator=(const AnesthesiaMachineVentilatorPressureLossData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineVentilatorPressureLossData& operator=(AnesthesiaMachineVentilatorPressureLossData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineVentilatorPressureLossData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineVentilatorPressureLossData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineVentilatorPressureLossData*>(
               &_AnesthesiaMachineVentilatorPressureLossData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AnesthesiaMachineVentilatorPressureLossData& a, AnesthesiaMachineVentilatorPressureLossData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineVentilatorPressureLossData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineVentilatorPressureLossData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineVentilatorPressureLossData>(nullptr);
  }

  AnesthesiaMachineVentilatorPressureLossData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineVentilatorPressureLossData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineVentilatorPressureLossData& from);
  void MergeFrom(const AnesthesiaMachineVentilatorPressureLossData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineVentilatorPressureLossData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineYPieceDisconnectData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData) */ {
 public:
  AnesthesiaMachineYPieceDisconnectData();
  virtual ~AnesthesiaMachineYPieceDisconnectData();

  AnesthesiaMachineYPieceDisconnectData(const AnesthesiaMachineYPieceDisconnectData& from);
  AnesthesiaMachineYPieceDisconnectData(AnesthesiaMachineYPieceDisconnectData&& from) noexcept
    : AnesthesiaMachineYPieceDisconnectData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineYPieceDisconnectData& operator=(const AnesthesiaMachineYPieceDisconnectData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineYPieceDisconnectData& operator=(AnesthesiaMachineYPieceDisconnectData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineYPieceDisconnectData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineYPieceDisconnectData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineYPieceDisconnectData*>(
               &_AnesthesiaMachineYPieceDisconnectData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AnesthesiaMachineYPieceDisconnectData& a, AnesthesiaMachineYPieceDisconnectData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineYPieceDisconnectData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineYPieceDisconnectData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineYPieceDisconnectData>(nullptr);
  }

  AnesthesiaMachineYPieceDisconnectData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineYPieceDisconnectData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineYPieceDisconnectData& from);
  void MergeFrom(const AnesthesiaMachineYPieceDisconnectData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineYPieceDisconnectData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kSeverityFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.Scalar0To1Data Severity = 2;
  bool has_severity() const;
  private:
  bool _internal_has_severity() const;
  public:
  void clear_severity();
  const ::pulse::cdm::bind::Scalar0To1Data& severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* release_severity();
  ::pulse::cdm::bind::Scalar0To1Data* mutable_severity();
  void set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity);
  private:
  const ::pulse::cdm::bind::Scalar0To1Data& _internal_severity() const;
  ::pulse::cdm::bind::Scalar0To1Data* _internal_mutable_severity();
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  ::pulse::cdm::bind::Scalar0To1Data* severity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineOxygenWallPortPressureLossData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData) */ {
 public:
  AnesthesiaMachineOxygenWallPortPressureLossData();
  virtual ~AnesthesiaMachineOxygenWallPortPressureLossData();

  AnesthesiaMachineOxygenWallPortPressureLossData(const AnesthesiaMachineOxygenWallPortPressureLossData& from);
  AnesthesiaMachineOxygenWallPortPressureLossData(AnesthesiaMachineOxygenWallPortPressureLossData&& from) noexcept
    : AnesthesiaMachineOxygenWallPortPressureLossData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineOxygenWallPortPressureLossData& operator=(const AnesthesiaMachineOxygenWallPortPressureLossData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineOxygenWallPortPressureLossData& operator=(AnesthesiaMachineOxygenWallPortPressureLossData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineOxygenWallPortPressureLossData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineOxygenWallPortPressureLossData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineOxygenWallPortPressureLossData*>(
               &_AnesthesiaMachineOxygenWallPortPressureLossData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AnesthesiaMachineOxygenWallPortPressureLossData& a, AnesthesiaMachineOxygenWallPortPressureLossData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineOxygenWallPortPressureLossData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineOxygenWallPortPressureLossData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineOxygenWallPortPressureLossData>(nullptr);
  }

  AnesthesiaMachineOxygenWallPortPressureLossData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineOxygenWallPortPressureLossData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineOxygenWallPortPressureLossData& from);
  void MergeFrom(const AnesthesiaMachineOxygenWallPortPressureLossData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineOxygenWallPortPressureLossData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.eSwitch State = 2;
  void clear_state();
  ::pulse::cdm::bind::eSwitch state() const;
  void set_state(::pulse::cdm::bind::eSwitch value);
  private:
  ::pulse::cdm::bind::eSwitch _internal_state() const;
  void _internal_set_state(::pulse::cdm::bind::eSwitch value);
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// -------------------------------------------------------------------

class AnesthesiaMachineOxygenTankPressureLossData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData) */ {
 public:
  AnesthesiaMachineOxygenTankPressureLossData();
  virtual ~AnesthesiaMachineOxygenTankPressureLossData();

  AnesthesiaMachineOxygenTankPressureLossData(const AnesthesiaMachineOxygenTankPressureLossData& from);
  AnesthesiaMachineOxygenTankPressureLossData(AnesthesiaMachineOxygenTankPressureLossData&& from) noexcept
    : AnesthesiaMachineOxygenTankPressureLossData() {
    *this = ::std::move(from);
  }

  inline AnesthesiaMachineOxygenTankPressureLossData& operator=(const AnesthesiaMachineOxygenTankPressureLossData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnesthesiaMachineOxygenTankPressureLossData& operator=(AnesthesiaMachineOxygenTankPressureLossData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnesthesiaMachineOxygenTankPressureLossData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnesthesiaMachineOxygenTankPressureLossData* internal_default_instance() {
    return reinterpret_cast<const AnesthesiaMachineOxygenTankPressureLossData*>(
               &_AnesthesiaMachineOxygenTankPressureLossData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(AnesthesiaMachineOxygenTankPressureLossData& a, AnesthesiaMachineOxygenTankPressureLossData& b) {
    a.Swap(&b);
  }
  inline void Swap(AnesthesiaMachineOxygenTankPressureLossData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnesthesiaMachineOxygenTankPressureLossData* New() const final {
    return CreateMaybeMessage<AnesthesiaMachineOxygenTankPressureLossData>(nullptr);
  }

  AnesthesiaMachineOxygenTankPressureLossData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnesthesiaMachineOxygenTankPressureLossData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnesthesiaMachineOxygenTankPressureLossData& from);
  void MergeFrom(const AnesthesiaMachineOxygenTankPressureLossData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnesthesiaMachineOxygenTankPressureLossData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto);
    return ::descriptor_table_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnesthesiaMachineActionFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
  bool has_anesthesiamachineaction() const;
  private:
  bool _internal_has_anesthesiamachineaction() const;
  public:
  void clear_anesthesiamachineaction();
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* release_anesthesiamachineaction();
  ::pulse::cdm::bind::AnesthesiaMachineActionData* mutable_anesthesiamachineaction();
  void set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction);
  private:
  const ::pulse::cdm::bind::AnesthesiaMachineActionData& _internal_anesthesiamachineaction() const;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* _internal_mutable_anesthesiamachineaction();
  public:

  // .pulse.cdm.bind.eSwitch State = 2;
  void clear_state();
  ::pulse::cdm::bind::eSwitch state() const;
  void set_state(::pulse::cdm::bind::eSwitch value);
  private:
  ::pulse::cdm::bind::eSwitch _internal_state() const;
  void _internal_set_state(::pulse::cdm::bind::eSwitch value);
  public:

  // @@protoc_insertion_point(class_scope:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AnyAnesthesiaMachineActionData

// .pulse.cdm.bind.AnesthesiaMachineConfigurationData Configuration = 1;
inline bool AnyAnesthesiaMachineActionData::_internal_has_configuration() const {
  return Action_case() == kConfiguration;
}
inline bool AnyAnesthesiaMachineActionData::has_configuration() const {
  return _internal_has_configuration();
}
inline void AnyAnesthesiaMachineActionData::set_has_configuration() {
  _oneof_case_[0] = kConfiguration;
}
inline void AnyAnesthesiaMachineActionData::clear_configuration() {
  if (_internal_has_configuration()) {
    delete Action_.configuration_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* AnyAnesthesiaMachineActionData::release_configuration() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.Configuration)
  if (has_configuration()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* temp = Action_.configuration_;
    Action_.configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineConfigurationData& AnyAnesthesiaMachineActionData::_internal_configuration() const {
  return _internal_has_configuration()
      ? *Action_.configuration_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineConfigurationData*>(&::pulse::cdm::bind::_AnesthesiaMachineConfigurationData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineConfigurationData& AnyAnesthesiaMachineActionData::configuration() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.Configuration)
  return _internal_configuration();
}
inline ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* AnyAnesthesiaMachineActionData::_internal_mutable_configuration() {
  if (!_internal_has_configuration()) {
    clear_Action();
    set_has_configuration();
    Action_.configuration_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineConfigurationData >(
        GetArenaNoVirtual());
  }
  return Action_.configuration_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineConfigurationData* AnyAnesthesiaMachineActionData::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.Configuration)
  return _internal_mutable_configuration();
}

// .pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData ExpiratoryValveLeak = 2;
inline bool AnyAnesthesiaMachineActionData::_internal_has_expiratoryvalveleak() const {
  return Action_case() == kExpiratoryValveLeak;
}
inline bool AnyAnesthesiaMachineActionData::has_expiratoryvalveleak() const {
  return _internal_has_expiratoryvalveleak();
}
inline void AnyAnesthesiaMachineActionData::set_has_expiratoryvalveleak() {
  _oneof_case_[0] = kExpiratoryValveLeak;
}
inline void AnyAnesthesiaMachineActionData::clear_expiratoryvalveleak() {
  if (_internal_has_expiratoryvalveleak()) {
    delete Action_.expiratoryvalveleak_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* AnyAnesthesiaMachineActionData::release_expiratoryvalveleak() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveLeak)
  if (has_expiratoryvalveleak()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* temp = Action_.expiratoryvalveleak_;
    Action_.expiratoryvalveleak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData& AnyAnesthesiaMachineActionData::_internal_expiratoryvalveleak() const {
  return _internal_has_expiratoryvalveleak()
      ? *Action_.expiratoryvalveleak_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData*>(&::pulse::cdm::bind::_AnesthesiaMachineExpiratoryValveLeakData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData& AnyAnesthesiaMachineActionData::expiratoryvalveleak() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveLeak)
  return _internal_expiratoryvalveleak();
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* AnyAnesthesiaMachineActionData::_internal_mutable_expiratoryvalveleak() {
  if (!_internal_has_expiratoryvalveleak()) {
    clear_Action();
    set_has_expiratoryvalveleak();
    Action_.expiratoryvalveleak_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData >(
        GetArenaNoVirtual());
  }
  return Action_.expiratoryvalveleak_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveLeakData* AnyAnesthesiaMachineActionData::mutable_expiratoryvalveleak() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveLeak)
  return _internal_mutable_expiratoryvalveleak();
}

// .pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData ExpiratoryValveObstruction = 3;
inline bool AnyAnesthesiaMachineActionData::_internal_has_expiratoryvalveobstruction() const {
  return Action_case() == kExpiratoryValveObstruction;
}
inline bool AnyAnesthesiaMachineActionData::has_expiratoryvalveobstruction() const {
  return _internal_has_expiratoryvalveobstruction();
}
inline void AnyAnesthesiaMachineActionData::set_has_expiratoryvalveobstruction() {
  _oneof_case_[0] = kExpiratoryValveObstruction;
}
inline void AnyAnesthesiaMachineActionData::clear_expiratoryvalveobstruction() {
  if (_internal_has_expiratoryvalveobstruction()) {
    delete Action_.expiratoryvalveobstruction_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* AnyAnesthesiaMachineActionData::release_expiratoryvalveobstruction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveObstruction)
  if (has_expiratoryvalveobstruction()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* temp = Action_.expiratoryvalveobstruction_;
    Action_.expiratoryvalveobstruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData& AnyAnesthesiaMachineActionData::_internal_expiratoryvalveobstruction() const {
  return _internal_has_expiratoryvalveobstruction()
      ? *Action_.expiratoryvalveobstruction_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData*>(&::pulse::cdm::bind::_AnesthesiaMachineExpiratoryValveObstructionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData& AnyAnesthesiaMachineActionData::expiratoryvalveobstruction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveObstruction)
  return _internal_expiratoryvalveobstruction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* AnyAnesthesiaMachineActionData::_internal_mutable_expiratoryvalveobstruction() {
  if (!_internal_has_expiratoryvalveobstruction()) {
    clear_Action();
    set_has_expiratoryvalveobstruction();
    Action_.expiratoryvalveobstruction_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData >(
        GetArenaNoVirtual());
  }
  return Action_.expiratoryvalveobstruction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineExpiratoryValveObstructionData* AnyAnesthesiaMachineActionData::mutable_expiratoryvalveobstruction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.ExpiratoryValveObstruction)
  return _internal_mutable_expiratoryvalveobstruction();
}

// .pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData InspiratoryValveLeak = 4;
inline bool AnyAnesthesiaMachineActionData::_internal_has_inspiratoryvalveleak() const {
  return Action_case() == kInspiratoryValveLeak;
}
inline bool AnyAnesthesiaMachineActionData::has_inspiratoryvalveleak() const {
  return _internal_has_inspiratoryvalveleak();
}
inline void AnyAnesthesiaMachineActionData::set_has_inspiratoryvalveleak() {
  _oneof_case_[0] = kInspiratoryValveLeak;
}
inline void AnyAnesthesiaMachineActionData::clear_inspiratoryvalveleak() {
  if (_internal_has_inspiratoryvalveleak()) {
    delete Action_.inspiratoryvalveleak_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* AnyAnesthesiaMachineActionData::release_inspiratoryvalveleak() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveLeak)
  if (has_inspiratoryvalveleak()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* temp = Action_.inspiratoryvalveleak_;
    Action_.inspiratoryvalveleak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData& AnyAnesthesiaMachineActionData::_internal_inspiratoryvalveleak() const {
  return _internal_has_inspiratoryvalveleak()
      ? *Action_.inspiratoryvalveleak_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData*>(&::pulse::cdm::bind::_AnesthesiaMachineInspiratoryValveLeakData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData& AnyAnesthesiaMachineActionData::inspiratoryvalveleak() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveLeak)
  return _internal_inspiratoryvalveleak();
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* AnyAnesthesiaMachineActionData::_internal_mutable_inspiratoryvalveleak() {
  if (!_internal_has_inspiratoryvalveleak()) {
    clear_Action();
    set_has_inspiratoryvalveleak();
    Action_.inspiratoryvalveleak_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData >(
        GetArenaNoVirtual());
  }
  return Action_.inspiratoryvalveleak_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveLeakData* AnyAnesthesiaMachineActionData::mutable_inspiratoryvalveleak() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveLeak)
  return _internal_mutable_inspiratoryvalveleak();
}

// .pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData InspiratoryValveObstruction = 5;
inline bool AnyAnesthesiaMachineActionData::_internal_has_inspiratoryvalveobstruction() const {
  return Action_case() == kInspiratoryValveObstruction;
}
inline bool AnyAnesthesiaMachineActionData::has_inspiratoryvalveobstruction() const {
  return _internal_has_inspiratoryvalveobstruction();
}
inline void AnyAnesthesiaMachineActionData::set_has_inspiratoryvalveobstruction() {
  _oneof_case_[0] = kInspiratoryValveObstruction;
}
inline void AnyAnesthesiaMachineActionData::clear_inspiratoryvalveobstruction() {
  if (_internal_has_inspiratoryvalveobstruction()) {
    delete Action_.inspiratoryvalveobstruction_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* AnyAnesthesiaMachineActionData::release_inspiratoryvalveobstruction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveObstruction)
  if (has_inspiratoryvalveobstruction()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* temp = Action_.inspiratoryvalveobstruction_;
    Action_.inspiratoryvalveobstruction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData& AnyAnesthesiaMachineActionData::_internal_inspiratoryvalveobstruction() const {
  return _internal_has_inspiratoryvalveobstruction()
      ? *Action_.inspiratoryvalveobstruction_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData*>(&::pulse::cdm::bind::_AnesthesiaMachineInspiratoryValveObstructionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData& AnyAnesthesiaMachineActionData::inspiratoryvalveobstruction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveObstruction)
  return _internal_inspiratoryvalveobstruction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* AnyAnesthesiaMachineActionData::_internal_mutable_inspiratoryvalveobstruction() {
  if (!_internal_has_inspiratoryvalveobstruction()) {
    clear_Action();
    set_has_inspiratoryvalveobstruction();
    Action_.inspiratoryvalveobstruction_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData >(
        GetArenaNoVirtual());
  }
  return Action_.inspiratoryvalveobstruction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineInspiratoryValveObstructionData* AnyAnesthesiaMachineActionData::mutable_inspiratoryvalveobstruction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.InspiratoryValveObstruction)
  return _internal_mutable_inspiratoryvalveobstruction();
}

// .pulse.cdm.bind.AnesthesiaMachineMaskLeakData MaskLeak = 6;
inline bool AnyAnesthesiaMachineActionData::_internal_has_maskleak() const {
  return Action_case() == kMaskLeak;
}
inline bool AnyAnesthesiaMachineActionData::has_maskleak() const {
  return _internal_has_maskleak();
}
inline void AnyAnesthesiaMachineActionData::set_has_maskleak() {
  _oneof_case_[0] = kMaskLeak;
}
inline void AnyAnesthesiaMachineActionData::clear_maskleak() {
  if (_internal_has_maskleak()) {
    delete Action_.maskleak_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* AnyAnesthesiaMachineActionData::release_maskleak() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.MaskLeak)
  if (has_maskleak()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* temp = Action_.maskleak_;
    Action_.maskleak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData& AnyAnesthesiaMachineActionData::_internal_maskleak() const {
  return _internal_has_maskleak()
      ? *Action_.maskleak_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData*>(&::pulse::cdm::bind::_AnesthesiaMachineMaskLeakData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData& AnyAnesthesiaMachineActionData::maskleak() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.MaskLeak)
  return _internal_maskleak();
}
inline ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* AnyAnesthesiaMachineActionData::_internal_mutable_maskleak() {
  if (!_internal_has_maskleak()) {
    clear_Action();
    set_has_maskleak();
    Action_.maskleak_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData >(
        GetArenaNoVirtual());
  }
  return Action_.maskleak_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineMaskLeakData* AnyAnesthesiaMachineActionData::mutable_maskleak() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.MaskLeak)
  return _internal_mutable_maskleak();
}

// .pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData SodaLimeFailure = 7;
inline bool AnyAnesthesiaMachineActionData::_internal_has_sodalimefailure() const {
  return Action_case() == kSodaLimeFailure;
}
inline bool AnyAnesthesiaMachineActionData::has_sodalimefailure() const {
  return _internal_has_sodalimefailure();
}
inline void AnyAnesthesiaMachineActionData::set_has_sodalimefailure() {
  _oneof_case_[0] = kSodaLimeFailure;
}
inline void AnyAnesthesiaMachineActionData::clear_sodalimefailure() {
  if (_internal_has_sodalimefailure()) {
    delete Action_.sodalimefailure_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* AnyAnesthesiaMachineActionData::release_sodalimefailure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.SodaLimeFailure)
  if (has_sodalimefailure()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* temp = Action_.sodalimefailure_;
    Action_.sodalimefailure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData& AnyAnesthesiaMachineActionData::_internal_sodalimefailure() const {
  return _internal_has_sodalimefailure()
      ? *Action_.sodalimefailure_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData*>(&::pulse::cdm::bind::_AnesthesiaMachineSodaLimeFailureData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData& AnyAnesthesiaMachineActionData::sodalimefailure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.SodaLimeFailure)
  return _internal_sodalimefailure();
}
inline ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* AnyAnesthesiaMachineActionData::_internal_mutable_sodalimefailure() {
  if (!_internal_has_sodalimefailure()) {
    clear_Action();
    set_has_sodalimefailure();
    Action_.sodalimefailure_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData >(
        GetArenaNoVirtual());
  }
  return Action_.sodalimefailure_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineSodaLimeFailureData* AnyAnesthesiaMachineActionData::mutable_sodalimefailure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.SodaLimeFailure)
  return _internal_mutable_sodalimefailure();
}

// .pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData TubeCuffLeak = 8;
inline bool AnyAnesthesiaMachineActionData::_internal_has_tubecuffleak() const {
  return Action_case() == kTubeCuffLeak;
}
inline bool AnyAnesthesiaMachineActionData::has_tubecuffleak() const {
  return _internal_has_tubecuffleak();
}
inline void AnyAnesthesiaMachineActionData::set_has_tubecuffleak() {
  _oneof_case_[0] = kTubeCuffLeak;
}
inline void AnyAnesthesiaMachineActionData::clear_tubecuffleak() {
  if (_internal_has_tubecuffleak()) {
    delete Action_.tubecuffleak_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* AnyAnesthesiaMachineActionData::release_tubecuffleak() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.TubeCuffLeak)
  if (has_tubecuffleak()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* temp = Action_.tubecuffleak_;
    Action_.tubecuffleak_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData& AnyAnesthesiaMachineActionData::_internal_tubecuffleak() const {
  return _internal_has_tubecuffleak()
      ? *Action_.tubecuffleak_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData*>(&::pulse::cdm::bind::_AnesthesiaMachineTubeCuffLeakData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData& AnyAnesthesiaMachineActionData::tubecuffleak() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.TubeCuffLeak)
  return _internal_tubecuffleak();
}
inline ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* AnyAnesthesiaMachineActionData::_internal_mutable_tubecuffleak() {
  if (!_internal_has_tubecuffleak()) {
    clear_Action();
    set_has_tubecuffleak();
    Action_.tubecuffleak_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData >(
        GetArenaNoVirtual());
  }
  return Action_.tubecuffleak_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineTubeCuffLeakData* AnyAnesthesiaMachineActionData::mutable_tubecuffleak() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.TubeCuffLeak)
  return _internal_mutable_tubecuffleak();
}

// .pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData VaporizerFailure = 9;
inline bool AnyAnesthesiaMachineActionData::_internal_has_vaporizerfailure() const {
  return Action_case() == kVaporizerFailure;
}
inline bool AnyAnesthesiaMachineActionData::has_vaporizerfailure() const {
  return _internal_has_vaporizerfailure();
}
inline void AnyAnesthesiaMachineActionData::set_has_vaporizerfailure() {
  _oneof_case_[0] = kVaporizerFailure;
}
inline void AnyAnesthesiaMachineActionData::clear_vaporizerfailure() {
  if (_internal_has_vaporizerfailure()) {
    delete Action_.vaporizerfailure_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* AnyAnesthesiaMachineActionData::release_vaporizerfailure() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VaporizerFailure)
  if (has_vaporizerfailure()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* temp = Action_.vaporizerfailure_;
    Action_.vaporizerfailure_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData& AnyAnesthesiaMachineActionData::_internal_vaporizerfailure() const {
  return _internal_has_vaporizerfailure()
      ? *Action_.vaporizerfailure_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData*>(&::pulse::cdm::bind::_AnesthesiaMachineVaporizerFailureData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData& AnyAnesthesiaMachineActionData::vaporizerfailure() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VaporizerFailure)
  return _internal_vaporizerfailure();
}
inline ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* AnyAnesthesiaMachineActionData::_internal_mutable_vaporizerfailure() {
  if (!_internal_has_vaporizerfailure()) {
    clear_Action();
    set_has_vaporizerfailure();
    Action_.vaporizerfailure_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData >(
        GetArenaNoVirtual());
  }
  return Action_.vaporizerfailure_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineVaporizerFailureData* AnyAnesthesiaMachineActionData::mutable_vaporizerfailure() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VaporizerFailure)
  return _internal_mutable_vaporizerfailure();
}

// .pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData VentilatorPressureLoss = 10;
inline bool AnyAnesthesiaMachineActionData::_internal_has_ventilatorpressureloss() const {
  return Action_case() == kVentilatorPressureLoss;
}
inline bool AnyAnesthesiaMachineActionData::has_ventilatorpressureloss() const {
  return _internal_has_ventilatorpressureloss();
}
inline void AnyAnesthesiaMachineActionData::set_has_ventilatorpressureloss() {
  _oneof_case_[0] = kVentilatorPressureLoss;
}
inline void AnyAnesthesiaMachineActionData::clear_ventilatorpressureloss() {
  if (_internal_has_ventilatorpressureloss()) {
    delete Action_.ventilatorpressureloss_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* AnyAnesthesiaMachineActionData::release_ventilatorpressureloss() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VentilatorPressureLoss)
  if (has_ventilatorpressureloss()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* temp = Action_.ventilatorpressureloss_;
    Action_.ventilatorpressureloss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData& AnyAnesthesiaMachineActionData::_internal_ventilatorpressureloss() const {
  return _internal_has_ventilatorpressureloss()
      ? *Action_.ventilatorpressureloss_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData*>(&::pulse::cdm::bind::_AnesthesiaMachineVentilatorPressureLossData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData& AnyAnesthesiaMachineActionData::ventilatorpressureloss() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VentilatorPressureLoss)
  return _internal_ventilatorpressureloss();
}
inline ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* AnyAnesthesiaMachineActionData::_internal_mutable_ventilatorpressureloss() {
  if (!_internal_has_ventilatorpressureloss()) {
    clear_Action();
    set_has_ventilatorpressureloss();
    Action_.ventilatorpressureloss_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData >(
        GetArenaNoVirtual());
  }
  return Action_.ventilatorpressureloss_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineVentilatorPressureLossData* AnyAnesthesiaMachineActionData::mutable_ventilatorpressureloss() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.VentilatorPressureLoss)
  return _internal_mutable_ventilatorpressureloss();
}

// .pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData YPieceDisconnect = 11;
inline bool AnyAnesthesiaMachineActionData::_internal_has_ypiecedisconnect() const {
  return Action_case() == kYPieceDisconnect;
}
inline bool AnyAnesthesiaMachineActionData::has_ypiecedisconnect() const {
  return _internal_has_ypiecedisconnect();
}
inline void AnyAnesthesiaMachineActionData::set_has_ypiecedisconnect() {
  _oneof_case_[0] = kYPieceDisconnect;
}
inline void AnyAnesthesiaMachineActionData::clear_ypiecedisconnect() {
  if (_internal_has_ypiecedisconnect()) {
    delete Action_.ypiecedisconnect_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* AnyAnesthesiaMachineActionData::release_ypiecedisconnect() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.YPieceDisconnect)
  if (has_ypiecedisconnect()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* temp = Action_.ypiecedisconnect_;
    Action_.ypiecedisconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData& AnyAnesthesiaMachineActionData::_internal_ypiecedisconnect() const {
  return _internal_has_ypiecedisconnect()
      ? *Action_.ypiecedisconnect_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData*>(&::pulse::cdm::bind::_AnesthesiaMachineYPieceDisconnectData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData& AnyAnesthesiaMachineActionData::ypiecedisconnect() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.YPieceDisconnect)
  return _internal_ypiecedisconnect();
}
inline ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* AnyAnesthesiaMachineActionData::_internal_mutable_ypiecedisconnect() {
  if (!_internal_has_ypiecedisconnect()) {
    clear_Action();
    set_has_ypiecedisconnect();
    Action_.ypiecedisconnect_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData >(
        GetArenaNoVirtual());
  }
  return Action_.ypiecedisconnect_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineYPieceDisconnectData* AnyAnesthesiaMachineActionData::mutable_ypiecedisconnect() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.YPieceDisconnect)
  return _internal_mutable_ypiecedisconnect();
}

// .pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData OxygenWallPortPressureLoss = 12;
inline bool AnyAnesthesiaMachineActionData::_internal_has_oxygenwallportpressureloss() const {
  return Action_case() == kOxygenWallPortPressureLoss;
}
inline bool AnyAnesthesiaMachineActionData::has_oxygenwallportpressureloss() const {
  return _internal_has_oxygenwallportpressureloss();
}
inline void AnyAnesthesiaMachineActionData::set_has_oxygenwallportpressureloss() {
  _oneof_case_[0] = kOxygenWallPortPressureLoss;
}
inline void AnyAnesthesiaMachineActionData::clear_oxygenwallportpressureloss() {
  if (_internal_has_oxygenwallportpressureloss()) {
    delete Action_.oxygenwallportpressureloss_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* AnyAnesthesiaMachineActionData::release_oxygenwallportpressureloss() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenWallPortPressureLoss)
  if (has_oxygenwallportpressureloss()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* temp = Action_.oxygenwallportpressureloss_;
    Action_.oxygenwallportpressureloss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData& AnyAnesthesiaMachineActionData::_internal_oxygenwallportpressureloss() const {
  return _internal_has_oxygenwallportpressureloss()
      ? *Action_.oxygenwallportpressureloss_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData*>(&::pulse::cdm::bind::_AnesthesiaMachineOxygenWallPortPressureLossData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData& AnyAnesthesiaMachineActionData::oxygenwallportpressureloss() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenWallPortPressureLoss)
  return _internal_oxygenwallportpressureloss();
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* AnyAnesthesiaMachineActionData::_internal_mutable_oxygenwallportpressureloss() {
  if (!_internal_has_oxygenwallportpressureloss()) {
    clear_Action();
    set_has_oxygenwallportpressureloss();
    Action_.oxygenwallportpressureloss_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData >(
        GetArenaNoVirtual());
  }
  return Action_.oxygenwallportpressureloss_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenWallPortPressureLossData* AnyAnesthesiaMachineActionData::mutable_oxygenwallportpressureloss() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenWallPortPressureLoss)
  return _internal_mutable_oxygenwallportpressureloss();
}

// .pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData OxygenTankPressureLoss = 13;
inline bool AnyAnesthesiaMachineActionData::_internal_has_oxygentankpressureloss() const {
  return Action_case() == kOxygenTankPressureLoss;
}
inline bool AnyAnesthesiaMachineActionData::has_oxygentankpressureloss() const {
  return _internal_has_oxygentankpressureloss();
}
inline void AnyAnesthesiaMachineActionData::set_has_oxygentankpressureloss() {
  _oneof_case_[0] = kOxygenTankPressureLoss;
}
inline void AnyAnesthesiaMachineActionData::clear_oxygentankpressureloss() {
  if (_internal_has_oxygentankpressureloss()) {
    delete Action_.oxygentankpressureloss_;
    clear_has_Action();
  }
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* AnyAnesthesiaMachineActionData::release_oxygentankpressureloss() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenTankPressureLoss)
  if (has_oxygentankpressureloss()) {
    clear_has_Action();
      ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* temp = Action_.oxygentankpressureloss_;
    Action_.oxygentankpressureloss_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData& AnyAnesthesiaMachineActionData::_internal_oxygentankpressureloss() const {
  return _internal_has_oxygentankpressureloss()
      ? *Action_.oxygentankpressureloss_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData*>(&::pulse::cdm::bind::_AnesthesiaMachineOxygenTankPressureLossData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData& AnyAnesthesiaMachineActionData::oxygentankpressureloss() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenTankPressureLoss)
  return _internal_oxygentankpressureloss();
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* AnyAnesthesiaMachineActionData::_internal_mutable_oxygentankpressureloss() {
  if (!_internal_has_oxygentankpressureloss()) {
    clear_Action();
    set_has_oxygentankpressureloss();
    Action_.oxygentankpressureloss_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData >(
        GetArenaNoVirtual());
  }
  return Action_.oxygentankpressureloss_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineOxygenTankPressureLossData* AnyAnesthesiaMachineActionData::mutable_oxygentankpressureloss() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnyAnesthesiaMachineActionData.OxygenTankPressureLoss)
  return _internal_mutable_oxygentankpressureloss();
}

inline bool AnyAnesthesiaMachineActionData::has_Action() const {
  return Action_case() != ACTION_NOT_SET;
}
inline void AnyAnesthesiaMachineActionData::clear_has_Action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline AnyAnesthesiaMachineActionData::ActionCase AnyAnesthesiaMachineActionData::Action_case() const {
  return AnyAnesthesiaMachineActionData::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnesthesiaMachineActionData

// .pulse.cdm.bind.ActionData Action = 1;
inline bool AnesthesiaMachineActionData::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool AnesthesiaMachineActionData::has_action() const {
  return _internal_has_action();
}
inline const ::pulse::cdm::bind::ActionData& AnesthesiaMachineActionData::_internal_action() const {
  const ::pulse::cdm::bind::ActionData* p = action_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::ActionData*>(
      &::pulse::cdm::bind::_ActionData_default_instance_);
}
inline const ::pulse::cdm::bind::ActionData& AnesthesiaMachineActionData::action() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineActionData.Action)
  return _internal_action();
}
inline ::pulse::cdm::bind::ActionData* AnesthesiaMachineActionData::release_action() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineActionData.Action)
  
  ::pulse::cdm::bind::ActionData* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ActionData* AnesthesiaMachineActionData::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ActionData>(GetArenaNoVirtual());
    action_ = p;
  }
  return action_;
}
inline ::pulse::cdm::bind::ActionData* AnesthesiaMachineActionData::mutable_action() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineActionData.Action)
  return _internal_mutable_action();
}
inline void AnesthesiaMachineActionData::set_allocated_action(::pulse::cdm::bind::ActionData* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineActionData.Action)
}

// -------------------------------------------------------------------

// AnesthesiaMachineConfigurationData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineConfigurationData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineConfigurationData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineConfigurationData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineConfigurationData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineConfigurationData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineConfigurationData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineConfigurationData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineConfigurationData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineConfigurationData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineConfigurationData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineConfigurationData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineConfigurationData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineConfigurationData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.AnesthesiaMachineData Configuration = 2;
inline bool AnesthesiaMachineConfigurationData::_internal_has_configuration() const {
  return Option_case() == kConfiguration;
}
inline bool AnesthesiaMachineConfigurationData::has_configuration() const {
  return _internal_has_configuration();
}
inline void AnesthesiaMachineConfigurationData::set_has_configuration() {
  _oneof_case_[0] = kConfiguration;
}
inline ::pulse::cdm::bind::AnesthesiaMachineData* AnesthesiaMachineConfigurationData::release_configuration() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineConfigurationData.Configuration)
  if (has_configuration()) {
    clear_has_Option();
      ::pulse::cdm::bind::AnesthesiaMachineData* temp = Option_.configuration_;
    Option_.configuration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pulse::cdm::bind::AnesthesiaMachineData& AnesthesiaMachineConfigurationData::_internal_configuration() const {
  return _internal_has_configuration()
      ? *Option_.configuration_
      : *reinterpret_cast< ::pulse::cdm::bind::AnesthesiaMachineData*>(&::pulse::cdm::bind::_AnesthesiaMachineData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineData& AnesthesiaMachineConfigurationData::configuration() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineConfigurationData.Configuration)
  return _internal_configuration();
}
inline ::pulse::cdm::bind::AnesthesiaMachineData* AnesthesiaMachineConfigurationData::_internal_mutable_configuration() {
  if (!_internal_has_configuration()) {
    clear_Option();
    set_has_configuration();
    Option_.configuration_ = CreateMaybeMessage< ::pulse::cdm::bind::AnesthesiaMachineData >(
        GetArenaNoVirtual());
  }
  return Option_.configuration_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineData* AnesthesiaMachineConfigurationData::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineConfigurationData.Configuration)
  return _internal_mutable_configuration();
}

// string ConfigurationFile = 3;
inline bool AnesthesiaMachineConfigurationData::_internal_has_configurationfile() const {
  return Option_case() == kConfigurationFile;
}
inline void AnesthesiaMachineConfigurationData::set_has_configurationfile() {
  _oneof_case_[0] = kConfigurationFile;
}
inline void AnesthesiaMachineConfigurationData::clear_configurationfile() {
  if (_internal_has_configurationfile()) {
    Option_.configurationfile_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_Option();
  }
}
inline const std::string& AnesthesiaMachineConfigurationData::configurationfile() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
  return _internal_configurationfile();
}
inline void AnesthesiaMachineConfigurationData::set_configurationfile(const std::string& value) {
  _internal_set_configurationfile(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
}
inline std::string* AnesthesiaMachineConfigurationData::mutable_configurationfile() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
  return _internal_mutable_configurationfile();
}
inline const std::string& AnesthesiaMachineConfigurationData::_internal_configurationfile() const {
  if (_internal_has_configurationfile()) {
    return Option_.configurationfile_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AnesthesiaMachineConfigurationData::_internal_set_configurationfile(const std::string& value) {
  if (!_internal_has_configurationfile()) {
    clear_Option();
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Option_.configurationfile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AnesthesiaMachineConfigurationData::set_configurationfile(std::string&& value) {
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
  if (!_internal_has_configurationfile()) {
    clear_Option();
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Option_.configurationfile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
}
inline void AnesthesiaMachineConfigurationData::set_configurationfile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!_internal_has_configurationfile()) {
    clear_Option();
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Option_.configurationfile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
}
inline void AnesthesiaMachineConfigurationData::set_configurationfile(const char* value, size_t size) {
  if (!_internal_has_configurationfile()) {
    clear_Option();
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  Option_.configurationfile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
}
inline std::string* AnesthesiaMachineConfigurationData::_internal_mutable_configurationfile() {
  if (!_internal_has_configurationfile()) {
    clear_Option();
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return Option_.configurationfile_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AnesthesiaMachineConfigurationData::release_configurationfile() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
  if (_internal_has_configurationfile()) {
    clear_has_Option();
    return Option_.configurationfile_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void AnesthesiaMachineConfigurationData::set_allocated_configurationfile(std::string* configurationfile) {
  if (has_Option()) {
    clear_Option();
  }
  if (configurationfile != nullptr) {
    set_has_configurationfile();
    Option_.configurationfile_.UnsafeSetDefault(configurationfile);
  }
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineConfigurationData.ConfigurationFile)
}

inline bool AnesthesiaMachineConfigurationData::has_Option() const {
  return Option_case() != OPTION_NOT_SET;
}
inline void AnesthesiaMachineConfigurationData::clear_has_Option() {
  _oneof_case_[0] = OPTION_NOT_SET;
}
inline AnesthesiaMachineConfigurationData::OptionCase AnesthesiaMachineConfigurationData::Option_case() const {
  return AnesthesiaMachineConfigurationData::OptionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnesthesiaMachineExpiratoryValveLeakData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineExpiratoryValveLeakData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineExpiratoryValveLeakData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineExpiratoryValveLeakData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineExpiratoryValveLeakData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineExpiratoryValveLeakData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveLeakData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveLeakData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveLeakData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineExpiratoryValveLeakData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineExpiratoryValveLeakData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineExpiratoryValveLeakData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineExpiratoryValveLeakData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineExpiratoryValveLeakData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveLeakData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveLeakData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveLeakData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineExpiratoryValveLeakData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveLeakData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineExpiratoryValveObstructionData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineExpiratoryValveObstructionData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineExpiratoryValveObstructionData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineExpiratoryValveObstructionData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineExpiratoryValveObstructionData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineExpiratoryValveObstructionData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveObstructionData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveObstructionData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineExpiratoryValveObstructionData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineExpiratoryValveObstructionData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineExpiratoryValveObstructionData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineExpiratoryValveObstructionData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineExpiratoryValveObstructionData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineExpiratoryValveObstructionData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveObstructionData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveObstructionData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineExpiratoryValveObstructionData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineExpiratoryValveObstructionData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineExpiratoryValveObstructionData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineInspiratoryValveLeakData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineInspiratoryValveLeakData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineInspiratoryValveLeakData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineInspiratoryValveLeakData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineInspiratoryValveLeakData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineInspiratoryValveLeakData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveLeakData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveLeakData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveLeakData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineInspiratoryValveLeakData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineInspiratoryValveLeakData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineInspiratoryValveLeakData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineInspiratoryValveLeakData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineInspiratoryValveLeakData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveLeakData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveLeakData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveLeakData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineInspiratoryValveLeakData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveLeakData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineInspiratoryValveObstructionData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineInspiratoryValveObstructionData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineInspiratoryValveObstructionData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineInspiratoryValveObstructionData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineInspiratoryValveObstructionData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineInspiratoryValveObstructionData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveObstructionData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveObstructionData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineInspiratoryValveObstructionData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineInspiratoryValveObstructionData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineInspiratoryValveObstructionData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineInspiratoryValveObstructionData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineInspiratoryValveObstructionData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineInspiratoryValveObstructionData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveObstructionData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveObstructionData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineInspiratoryValveObstructionData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineInspiratoryValveObstructionData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineInspiratoryValveObstructionData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineMaskLeakData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineMaskLeakData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineMaskLeakData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineMaskLeakData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineMaskLeakData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineMaskLeakData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineMaskLeakData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineMaskLeakData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineMaskLeakData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineMaskLeakData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineMaskLeakData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineMaskLeakData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineMaskLeakData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineMaskLeakData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineMaskLeakData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineMaskLeakData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineMaskLeakData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineMaskLeakData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineMaskLeakData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineSodaLimeFailureData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineSodaLimeFailureData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineSodaLimeFailureData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineSodaLimeFailureData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineSodaLimeFailureData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineSodaLimeFailureData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineSodaLimeFailureData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineSodaLimeFailureData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineSodaLimeFailureData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineSodaLimeFailureData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineSodaLimeFailureData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineSodaLimeFailureData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineSodaLimeFailureData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineSodaLimeFailureData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineSodaLimeFailureData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineSodaLimeFailureData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineSodaLimeFailureData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineSodaLimeFailureData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineSodaLimeFailureData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineTubeCuffLeakData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineTubeCuffLeakData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineTubeCuffLeakData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineTubeCuffLeakData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineTubeCuffLeakData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineTubeCuffLeakData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineTubeCuffLeakData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineTubeCuffLeakData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineTubeCuffLeakData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineTubeCuffLeakData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineTubeCuffLeakData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineTubeCuffLeakData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineTubeCuffLeakData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineTubeCuffLeakData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineTubeCuffLeakData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineTubeCuffLeakData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineTubeCuffLeakData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineTubeCuffLeakData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineTubeCuffLeakData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineVaporizerFailureData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineVaporizerFailureData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineVaporizerFailureData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineVaporizerFailureData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineVaporizerFailureData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineVaporizerFailureData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVaporizerFailureData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVaporizerFailureData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVaporizerFailureData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineVaporizerFailureData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineVaporizerFailureData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineVaporizerFailureData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineVaporizerFailureData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineVaporizerFailureData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVaporizerFailureData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVaporizerFailureData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVaporizerFailureData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineVaporizerFailureData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineVaporizerFailureData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineVentilatorPressureLossData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineVentilatorPressureLossData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineVentilatorPressureLossData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineVentilatorPressureLossData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineVentilatorPressureLossData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineVentilatorPressureLossData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVentilatorPressureLossData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVentilatorPressureLossData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineVentilatorPressureLossData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineVentilatorPressureLossData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineVentilatorPressureLossData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineVentilatorPressureLossData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineVentilatorPressureLossData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineVentilatorPressureLossData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVentilatorPressureLossData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVentilatorPressureLossData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineVentilatorPressureLossData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineVentilatorPressureLossData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineVentilatorPressureLossData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineYPieceDisconnectData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineYPieceDisconnectData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineYPieceDisconnectData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineYPieceDisconnectData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineYPieceDisconnectData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineYPieceDisconnectData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineYPieceDisconnectData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineYPieceDisconnectData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineYPieceDisconnectData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineYPieceDisconnectData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.Scalar0To1Data Severity = 2;
inline bool AnesthesiaMachineYPieceDisconnectData::_internal_has_severity() const {
  return this != internal_default_instance() && severity_ != nullptr;
}
inline bool AnesthesiaMachineYPieceDisconnectData::has_severity() const {
  return _internal_has_severity();
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineYPieceDisconnectData::_internal_severity() const {
  const ::pulse::cdm::bind::Scalar0To1Data* p = severity_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::Scalar0To1Data*>(
      &::pulse::cdm::bind::_Scalar0To1Data_default_instance_);
}
inline const ::pulse::cdm::bind::Scalar0To1Data& AnesthesiaMachineYPieceDisconnectData::severity() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.Severity)
  return _internal_severity();
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineYPieceDisconnectData::release_severity() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.Severity)
  
  ::pulse::cdm::bind::Scalar0To1Data* temp = severity_;
  severity_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineYPieceDisconnectData::_internal_mutable_severity() {
  
  if (severity_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::Scalar0To1Data>(GetArenaNoVirtual());
    severity_ = p;
  }
  return severity_;
}
inline ::pulse::cdm::bind::Scalar0To1Data* AnesthesiaMachineYPieceDisconnectData::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.Severity)
  return _internal_mutable_severity();
}
inline void AnesthesiaMachineYPieceDisconnectData::set_allocated_severity(::pulse::cdm::bind::Scalar0To1Data* severity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(severity_);
  }
  if (severity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      severity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, severity, submessage_arena);
    }
    
  } else {
    
  }
  severity_ = severity;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineYPieceDisconnectData.Severity)
}

// -------------------------------------------------------------------

// AnesthesiaMachineOxygenWallPortPressureLossData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineOxygenWallPortPressureLossData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineOxygenWallPortPressureLossData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineOxygenWallPortPressureLossData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineOxygenWallPortPressureLossData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineOxygenWallPortPressureLossData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenWallPortPressureLossData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenWallPortPressureLossData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenWallPortPressureLossData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineOxygenWallPortPressureLossData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.eSwitch State = 2;
inline void AnesthesiaMachineOxygenWallPortPressureLossData::clear_state() {
  state_ = 0;
}
inline ::pulse::cdm::bind::eSwitch AnesthesiaMachineOxygenWallPortPressureLossData::_internal_state() const {
  return static_cast< ::pulse::cdm::bind::eSwitch >(state_);
}
inline ::pulse::cdm::bind::eSwitch AnesthesiaMachineOxygenWallPortPressureLossData::state() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.State)
  return _internal_state();
}
inline void AnesthesiaMachineOxygenWallPortPressureLossData::_internal_set_state(::pulse::cdm::bind::eSwitch value) {
  
  state_ = value;
}
inline void AnesthesiaMachineOxygenWallPortPressureLossData::set_state(::pulse::cdm::bind::eSwitch value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.AnesthesiaMachineOxygenWallPortPressureLossData.State)
}

// -------------------------------------------------------------------

// AnesthesiaMachineOxygenTankPressureLossData

// .pulse.cdm.bind.AnesthesiaMachineActionData AnesthesiaMachineAction = 1;
inline bool AnesthesiaMachineOxygenTankPressureLossData::_internal_has_anesthesiamachineaction() const {
  return this != internal_default_instance() && anesthesiamachineaction_ != nullptr;
}
inline bool AnesthesiaMachineOxygenTankPressureLossData::has_anesthesiamachineaction() const {
  return _internal_has_anesthesiamachineaction();
}
inline void AnesthesiaMachineOxygenTankPressureLossData::clear_anesthesiamachineaction() {
  if (GetArenaNoVirtual() == nullptr && anesthesiamachineaction_ != nullptr) {
    delete anesthesiamachineaction_;
  }
  anesthesiamachineaction_ = nullptr;
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineOxygenTankPressureLossData::_internal_anesthesiamachineaction() const {
  const ::pulse::cdm::bind::AnesthesiaMachineActionData* p = anesthesiamachineaction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::AnesthesiaMachineActionData*>(
      &::pulse::cdm::bind::_AnesthesiaMachineActionData_default_instance_);
}
inline const ::pulse::cdm::bind::AnesthesiaMachineActionData& AnesthesiaMachineOxygenTankPressureLossData::anesthesiamachineaction() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.AnesthesiaMachineAction)
  return _internal_anesthesiamachineaction();
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenTankPressureLossData::release_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_release:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.AnesthesiaMachineAction)
  
  ::pulse::cdm::bind::AnesthesiaMachineActionData* temp = anesthesiamachineaction_;
  anesthesiamachineaction_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenTankPressureLossData::_internal_mutable_anesthesiamachineaction() {
  
  if (anesthesiamachineaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::AnesthesiaMachineActionData>(GetArenaNoVirtual());
    anesthesiamachineaction_ = p;
  }
  return anesthesiamachineaction_;
}
inline ::pulse::cdm::bind::AnesthesiaMachineActionData* AnesthesiaMachineOxygenTankPressureLossData::mutable_anesthesiamachineaction() {
  // @@protoc_insertion_point(field_mutable:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.AnesthesiaMachineAction)
  return _internal_mutable_anesthesiamachineaction();
}
inline void AnesthesiaMachineOxygenTankPressureLossData::set_allocated_anesthesiamachineaction(::pulse::cdm::bind::AnesthesiaMachineActionData* anesthesiamachineaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anesthesiamachineaction_;
  }
  if (anesthesiamachineaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachineaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachineaction, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachineaction_ = anesthesiamachineaction;
  // @@protoc_insertion_point(field_set_allocated:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.AnesthesiaMachineAction)
}

// .pulse.cdm.bind.eSwitch State = 2;
inline void AnesthesiaMachineOxygenTankPressureLossData::clear_state() {
  state_ = 0;
}
inline ::pulse::cdm::bind::eSwitch AnesthesiaMachineOxygenTankPressureLossData::_internal_state() const {
  return static_cast< ::pulse::cdm::bind::eSwitch >(state_);
}
inline ::pulse::cdm::bind::eSwitch AnesthesiaMachineOxygenTankPressureLossData::state() const {
  // @@protoc_insertion_point(field_get:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.State)
  return _internal_state();
}
inline void AnesthesiaMachineOxygenTankPressureLossData::_internal_set_state(::pulse::cdm::bind::eSwitch value) {
  
  state_ = value;
}
inline void AnesthesiaMachineOxygenTankPressureLossData::set_state(::pulse::cdm::bind::eSwitch value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:pulse.cdm.bind.AnesthesiaMachineOxygenTankPressureLossData.State)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bind
}  // namespace cdm
}  // namespace pulse

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pulse_2fcdm_2fbind_2fAnesthesiaMachineActions_2eproto
