// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulse/cdm/bind/Circuit.proto

#include "pulse/cdm/bind/Circuit.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricCapacitanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricChargeData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricCurrentData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricInductanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricPotentialData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarElectricResistanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarEnergyData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarHeatCapacitanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarHeatInductanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarHeatResistanceData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarPowerData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarPressureData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarPressureTimePerVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarPressureTimeSquaredPerVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarTemperatureData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarVolumePerPressureData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fProperties_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ScalarVolumePerTimeData_pulse_2fcdm_2fbind_2fProperties_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pulse_2fcdm_2fbind_2fCircuit_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto;
namespace pulse {
namespace cdm {
namespace bind {
class CircuitDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CircuitData> _instance;
} _CircuitData_default_instance_;
class CircuitNodeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CircuitNodeData> _instance;
} _CircuitNodeData_default_instance_;
class CircuitPathDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CircuitPathData> _instance;
} _CircuitPathData_default_instance_;
class ElectricalCircuitDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ElectricalCircuitData> _instance;
} _ElectricalCircuitData_default_instance_;
class ElectricalCircuitNodeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ElectricalCircuitNodeData> _instance;
} _ElectricalCircuitNodeData_default_instance_;
class ElectricalCircuitPathDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ElectricalCircuitPathData> _instance;
} _ElectricalCircuitPathData_default_instance_;
class FluidCircuitDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FluidCircuitData> _instance;
} _FluidCircuitData_default_instance_;
class FluidCircuitNodeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FluidCircuitNodeData> _instance;
} _FluidCircuitNodeData_default_instance_;
class FluidCircuitPathDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FluidCircuitPathData> _instance;
} _FluidCircuitPathData_default_instance_;
class ThermalCircuitDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThermalCircuitData> _instance;
} _ThermalCircuitData_default_instance_;
class ThermalCircuitNodeDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThermalCircuitNodeData> _instance;
} _ThermalCircuitNodeData_default_instance_;
class ThermalCircuitPathDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThermalCircuitPathData> _instance;
} _ThermalCircuitPathData_default_instance_;
class CircuitManagerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CircuitManagerData> _instance;
} _CircuitManagerData_default_instance_;
}  // namespace bind
}  // namespace cdm
}  // namespace pulse
static void InitDefaultsscc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_CircuitData_default_instance_;
    new (ptr) ::pulse::cdm::bind::CircuitData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::CircuitData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {}};

static void InitDefaultsscc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_CircuitManagerData_default_instance_;
    new (ptr) ::pulse::cdm::bind::CircuitManagerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::CircuitManagerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<9> scc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 9, 0, InitDefaultsscc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,}};

static void InitDefaultsscc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_CircuitNodeData_default_instance_;
    new (ptr) ::pulse::cdm::bind::CircuitNodeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::CircuitNodeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {}};

static void InitDefaultsscc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_CircuitPathData_default_instance_;
    new (ptr) ::pulse::cdm::bind::CircuitPathData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::CircuitPathData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {}};

static void InitDefaultsscc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ElectricalCircuitData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ElectricalCircuitData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ElectricalCircuitData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,}};

static void InitDefaultsscc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ElectricalCircuitNodeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ElectricalCircuitNodeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarElectricPotentialData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarElectricChargeData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static void InitDefaultsscc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ElectricalCircuitPathData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ElectricalCircuitPathData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, 0, InitDefaultsscc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarElectricResistanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarElectricCapacitanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarElectricInductanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarElectricCurrentData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarElectricPotentialData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static void InitDefaultsscc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_FluidCircuitData_default_instance_;
    new (ptr) ::pulse::cdm::bind::FluidCircuitData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::FluidCircuitData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,}};

static void InitDefaultsscc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_;
    new (ptr) ::pulse::cdm::bind::FluidCircuitNodeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::FluidCircuitNodeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarPressureData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static void InitDefaultsscc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_FluidCircuitPathData_default_instance_;
    new (ptr) ::pulse::cdm::bind::FluidCircuitPathData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::FluidCircuitPathData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, 0, InitDefaultsscc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarPressureTimePerVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarVolumePerPressureData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarPressureTimeSquaredPerVolumeData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarVolumePerTimeData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarPressureData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static void InitDefaultsscc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ThermalCircuitData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ThermalCircuitData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ThermalCircuitData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,}};

static void InitDefaultsscc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ThermalCircuitNodeData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ThermalCircuitNodeData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarTemperatureData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarEnergyData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static void InitDefaultsscc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_;
    new (ptr) ::pulse::cdm::bind::ThermalCircuitPathData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pulse::cdm::bind::ThermalCircuitPathData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, 0, InitDefaultsscc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto}, {
      &scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
      &scc_info_ScalarHeatResistanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarHeatCapacitanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarHeatInductanceData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarPowerData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,
      &scc_info_ScalarTemperatureData_pulse_2fcdm_2fbind_2fProperties_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_pulse_2fcdm_2fbind_2fCircuit_2eproto[13];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_pulse_2fcdm_2fbind_2fCircuit_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_pulse_2fcdm_2fbind_2fCircuit_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitData, name_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitData, node_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitData, path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitNodeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitNodeData, name_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitNodeData, referencenode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, name_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, sourcenode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, targetnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, switch__),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, nextswitch_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, valve_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, nextvalve_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, polarizedstate_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitPathData, nextpolarizedstate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitData, circuit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, circuitnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, voltage_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, nextvoltage_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, charge_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, nextcharge_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitNodeData, chargebaseline_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, circuitpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, resistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextresistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, resistancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, capacitance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextcapacitance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, capacitancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, inductance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextinductance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, inductancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, current_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextcurrent_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, currentsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextcurrentsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, currentsourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, voltagesource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, nextvoltagesource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, voltagesourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ElectricalCircuitPathData, valvebreakdownvoltage_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitData, circuit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, circuitnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, pressure_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, nextpressure_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, volume_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, nextvolume_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitNodeData, volumebaseline_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, circuitpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, resistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextresistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, resistancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, compliance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextcompliance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, compliancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, inertance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextinertance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, inertancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, flow_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextflow_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, flowsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextflowsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, flowsourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, pressuresource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, nextpressuresource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, pressuresourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::FluidCircuitPathData, valvebreakdownpressure_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitData, circuit_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, circuitnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, temperature_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, nexttemperature_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, heat_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, nextheat_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitNodeData, heatbaseline_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, circuitpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, resistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nextresistance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, resistancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, capacitance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nextcapacitance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, capacitancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, inductance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nextinductance_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, inductancebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, heattransferrate_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nextheattransferrate_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, heatsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nextheatsource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, heatsourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, temperaturesource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, nexttemperaturesource_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, temperaturesourcebaseline_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::ThermalCircuitPathData, valvebreakdowntemperature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, electricalnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, electricalpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, electricalcircuit_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, fluidnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, fluidpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, fluidcircuit_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, thermalnode_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, thermalpath_),
  PROTOBUF_FIELD_OFFSET(::pulse::cdm::bind::CircuitManagerData, thermalcircuit_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::pulse::cdm::bind::CircuitData)},
  { 8, -1, sizeof(::pulse::cdm::bind::CircuitNodeData)},
  { 15, -1, sizeof(::pulse::cdm::bind::CircuitPathData)},
  { 29, -1, sizeof(::pulse::cdm::bind::ElectricalCircuitData)},
  { 35, -1, sizeof(::pulse::cdm::bind::ElectricalCircuitNodeData)},
  { 46, -1, sizeof(::pulse::cdm::bind::ElectricalCircuitPathData)},
  { 70, -1, sizeof(::pulse::cdm::bind::FluidCircuitData)},
  { 76, -1, sizeof(::pulse::cdm::bind::FluidCircuitNodeData)},
  { 87, -1, sizeof(::pulse::cdm::bind::FluidCircuitPathData)},
  { 111, -1, sizeof(::pulse::cdm::bind::ThermalCircuitData)},
  { 117, -1, sizeof(::pulse::cdm::bind::ThermalCircuitNodeData)},
  { 128, -1, sizeof(::pulse::cdm::bind::ThermalCircuitPathData)},
  { 152, -1, sizeof(::pulse::cdm::bind::CircuitManagerData)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_CircuitData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_CircuitNodeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_CircuitPathData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ElectricalCircuitData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_FluidCircuitData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_FluidCircuitPathData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ThermalCircuitData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pulse::cdm::bind::_CircuitManagerData_default_instance_),
};

const char descriptor_table_protodef_pulse_2fcdm_2fbind_2fCircuit_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\034pulse/cdm/bind/Circuit.proto\022\016pulse.cd"
  "m.bind\032\032pulse/cdm/bind/Enums.proto\032\037puls"
  "e/cdm/bind/Properties.proto\"7\n\013CircuitDa"
  "ta\022\014\n\004Name\030\001 \001(\t\022\014\n\004Node\030\002 \003(\t\022\014\n\004Path\030\003"
  " \003(\t\"6\n\017CircuitNodeData\022\014\n\004Name\030\001 \001(\t\022\025\n"
  "\rReferenceNode\030\002 \001(\010\"\313\002\n\017CircuitPathData"
  "\022\014\n\004Name\030\001 \001(\t\022\022\n\nSourceNode\030\002 \001(\t\022\022\n\nTa"
  "rgetNode\030\003 \001(\t\022%\n\006Switch\030\004 \001(\0162\025.pulse.c"
  "dm.bind.eGate\022)\n\nNextSwitch\030\005 \001(\0162\025.puls"
  "e.cdm.bind.eGate\022$\n\005Valve\030\006 \001(\0162\025.pulse."
  "cdm.bind.eGate\022(\n\tNextValve\030\007 \001(\0162\025.puls"
  "e.cdm.bind.eGate\022-\n\016PolarizedState\030\010 \001(\016"
  "2\025.pulse.cdm.bind.eGate\0221\n\022NextPolarized"
  "State\030\t \001(\0162\025.pulse.cdm.bind.eGate\"E\n\025El"
  "ectricalCircuitData\022,\n\007Circuit\030\001 \001(\0132\033.p"
  "ulse.cdm.bind.CircuitData\"\213\003\n\031Electrical"
  "CircuitNodeData\0224\n\013CircuitNode\030\001 \001(\0132\037.p"
  "ulse.cdm.bind.CircuitNodeData\022<\n\007Voltage"
  "\030\002 \001(\0132+.pulse.cdm.bind.ScalarElectricPo"
  "tentialData\022@\n\013NextVoltage\030\003 \001(\0132+.pulse"
  ".cdm.bind.ScalarElectricPotentialData\0228\n"
  "\006Charge\030\004 \001(\0132(.pulse.cdm.bind.ScalarEle"
  "ctricChargeData\022<\n\nNextCharge\030\005 \001(\0132(.pu"
  "lse.cdm.bind.ScalarElectricChargeData\022@\n"
  "\016ChargeBaseline\030\006 \001(\0132(.pulse.cdm.bind.S"
  "calarElectricChargeData\"\277\n\n\031ElectricalCi"
  "rcuitPathData\0224\n\013CircuitPath\030\001 \001(\0132\037.pul"
  "se.cdm.bind.CircuitPathData\022@\n\nResistanc"
  "e\030\002 \001(\0132,.pulse.cdm.bind.ScalarElectricR"
  "esistanceData\022D\n\016NextResistance\030\003 \001(\0132,."
  "pulse.cdm.bind.ScalarElectricResistanceD"
  "ata\022H\n\022ResistanceBaseline\030\004 \001(\0132,.pulse."
  "cdm.bind.ScalarElectricResistanceData\022B\n"
  "\013Capacitance\030\005 \001(\0132-.pulse.cdm.bind.Scal"
  "arElectricCapacitanceData\022F\n\017NextCapacit"
  "ance\030\006 \001(\0132-.pulse.cdm.bind.ScalarElectr"
  "icCapacitanceData\022J\n\023CapacitanceBaseline"
  "\030\007 \001(\0132-.pulse.cdm.bind.ScalarElectricCa"
  "pacitanceData\022@\n\nInductance\030\010 \001(\0132,.puls"
  "e.cdm.bind.ScalarElectricInductanceData\022"
  "D\n\016NextInductance\030\t \001(\0132,.pulse.cdm.bind"
  ".ScalarElectricInductanceData\022H\n\022Inducta"
  "nceBaseline\030\n \001(\0132,.pulse.cdm.bind.Scala"
  "rElectricInductanceData\022:\n\007Current\030\013 \001(\013"
  "2).pulse.cdm.bind.ScalarElectricCurrentD"
  "ata\022>\n\013NextCurrent\030\014 \001(\0132).pulse.cdm.bin"
  "d.ScalarElectricCurrentData\022@\n\rCurrentSo"
  "urce\030\r \001(\0132).pulse.cdm.bind.ScalarElectr"
  "icCurrentData\022D\n\021NextCurrentSource\030\016 \001(\013"
  "2).pulse.cdm.bind.ScalarElectricCurrentD"
  "ata\022H\n\025CurrentSourceBaseline\030\017 \001(\0132).pul"
  "se.cdm.bind.ScalarElectricCurrentData\022B\n"
  "\rVoltageSource\030\020 \001(\0132+.pulse.cdm.bind.Sc"
  "alarElectricPotentialData\022F\n\021NextVoltage"
  "Source\030\021 \001(\0132+.pulse.cdm.bind.ScalarElec"
  "tricPotentialData\022J\n\025VoltageSourceBaseli"
  "ne\030\022 \001(\0132+.pulse.cdm.bind.ScalarElectric"
  "PotentialData\022J\n\025ValveBreakdownVoltage\030\023"
  " \001(\0132+.pulse.cdm.bind.ScalarElectricPote"
  "ntialData\"@\n\020FluidCircuitData\022,\n\007Circuit"
  "\030\001 \001(\0132\033.pulse.cdm.bind.CircuitData\"\336\002\n\024"
  "FluidCircuitNodeData\0224\n\013CircuitNode\030\001 \001("
  "\0132\037.pulse.cdm.bind.CircuitNodeData\0224\n\010Pr"
  "essure\030\002 \001(\0132\".pulse.cdm.bind.ScalarPres"
  "sureData\0228\n\014NextPressure\030\003 \001(\0132\".pulse.c"
  "dm.bind.ScalarPressureData\0220\n\006Volume\030\004 \001"
  "(\0132 .pulse.cdm.bind.ScalarVolumeData\0224\n\n"
  "NextVolume\030\005 \001(\0132 .pulse.cdm.bind.Scalar"
  "VolumeData\0228\n\016VolumeBaseline\030\006 \001(\0132 .pul"
  "se.cdm.bind.ScalarVolumeData\"\234\n\n\024FluidCi"
  "rcuitPathData\0224\n\013CircuitPath\030\001 \001(\0132\037.pul"
  "se.cdm.bind.CircuitPathData\022C\n\nResistanc"
  "e\030\002 \001(\0132/.pulse.cdm.bind.ScalarPressureT"
  "imePerVolumeData\022G\n\016NextResistance\030\003 \001(\013"
  "2/.pulse.cdm.bind.ScalarPressureTimePerV"
  "olumeData\022K\n\022ResistanceBaseline\030\004 \001(\0132/."
  "pulse.cdm.bind.ScalarPressureTimePerVolu"
  "meData\022\?\n\nCompliance\030\005 \001(\0132+.pulse.cdm.b"
  "ind.ScalarVolumePerPressureData\022C\n\016NextC"
  "ompliance\030\006 \001(\0132+.pulse.cdm.bind.ScalarV"
  "olumePerPressureData\022G\n\022ComplianceBaseli"
  "ne\030\007 \001(\0132+.pulse.cdm.bind.ScalarVolumePe"
  "rPressureData\022I\n\tInertance\030\010 \001(\01326.pulse"
  ".cdm.bind.ScalarPressureTimeSquaredPerVo"
  "lumeData\022M\n\rNextInertance\030\t \001(\01326.pulse."
  "cdm.bind.ScalarPressureTimeSquaredPerVol"
  "umeData\022Q\n\021InertanceBaseline\030\n \001(\01326.pul"
  "se.cdm.bind.ScalarPressureTimeSquaredPer"
  "VolumeData\0225\n\004Flow\030\013 \001(\0132\'.pulse.cdm.bin"
  "d.ScalarVolumePerTimeData\0229\n\010NextFlow\030\014 "
  "\001(\0132\'.pulse.cdm.bind.ScalarVolumePerTime"
  "Data\022;\n\nFlowSource\030\r \001(\0132\'.pulse.cdm.bin"
  "d.ScalarVolumePerTimeData\022\?\n\016NextFlowSou"
  "rce\030\016 \001(\0132\'.pulse.cdm.bind.ScalarVolumeP"
  "erTimeData\022C\n\022FlowSourceBaseline\030\017 \001(\0132\'"
  ".pulse.cdm.bind.ScalarVolumePerTimeData\022"
  ":\n\016PressureSource\030\020 \001(\0132\".pulse.cdm.bind"
  ".ScalarPressureData\022>\n\022NextPressureSourc"
  "e\030\021 \001(\0132\".pulse.cdm.bind.ScalarPressureD"
  "ata\022B\n\026PressureSourceBaseline\030\022 \001(\0132\".pu"
  "lse.cdm.bind.ScalarPressureData\022B\n\026Valve"
  "BreakdownPressure\030\023 \001(\0132\".pulse.cdm.bind"
  ".ScalarPressureData\"B\n\022ThermalCircuitDat"
  "a\022,\n\007Circuit\030\001 \001(\0132\033.pulse.cdm.bind.Circ"
  "uitData\"\346\002\n\026ThermalCircuitNodeData\0224\n\013Ci"
  "rcuitNode\030\001 \001(\0132\037.pulse.cdm.bind.Circuit"
  "NodeData\022:\n\013Temperature\030\002 \001(\0132%.pulse.cd"
  "m.bind.ScalarTemperatureData\022>\n\017NextTemp"
  "erature\030\003 \001(\0132%.pulse.cdm.bind.ScalarTem"
  "peratureData\022.\n\004Heat\030\004 \001(\0132 .pulse.cdm.b"
  "ind.ScalarEnergyData\0222\n\010NextHeat\030\005 \001(\0132 "
  ".pulse.cdm.bind.ScalarEnergyData\0226\n\014Heat"
  "Baseline\030\006 \001(\0132 .pulse.cdm.bind.ScalarEn"
  "ergyData\"\347\t\n\026ThermalCircuitPathData\0224\n\013C"
  "ircuitPath\030\001 \001(\0132\037.pulse.cdm.bind.Circui"
  "tPathData\022<\n\nResistance\030\002 \001(\0132(.pulse.cd"
  "m.bind.ScalarHeatResistanceData\022@\n\016NextR"
  "esistance\030\003 \001(\0132(.pulse.cdm.bind.ScalarH"
  "eatResistanceData\022D\n\022ResistanceBaseline\030"
  "\004 \001(\0132(.pulse.cdm.bind.ScalarHeatResista"
  "nceData\022>\n\013Capacitance\030\005 \001(\0132).pulse.cdm"
  ".bind.ScalarHeatCapacitanceData\022B\n\017NextC"
  "apacitance\030\006 \001(\0132).pulse.cdm.bind.Scalar"
  "HeatCapacitanceData\022F\n\023CapacitanceBaseli"
  "ne\030\007 \001(\0132).pulse.cdm.bind.ScalarHeatCapa"
  "citanceData\022<\n\nInductance\030\010 \001(\0132(.pulse."
  "cdm.bind.ScalarHeatInductanceData\022@\n\016Nex"
  "tInductance\030\t \001(\0132(.pulse.cdm.bind.Scala"
  "rHeatInductanceData\022D\n\022InductanceBaselin"
  "e\030\n \001(\0132(.pulse.cdm.bind.ScalarHeatInduc"
  "tanceData\0229\n\020HeatTransferRate\030\013 \001(\0132\037.pu"
  "lse.cdm.bind.ScalarPowerData\022=\n\024NextHeat"
  "TransferRate\030\014 \001(\0132\037.pulse.cdm.bind.Scal"
  "arPowerData\0223\n\nHeatSource\030\r \001(\0132\037.pulse."
  "cdm.bind.ScalarPowerData\0227\n\016NextHeatSour"
  "ce\030\016 \001(\0132\037.pulse.cdm.bind.ScalarPowerDat"
  "a\022;\n\022HeatSourceBaseline\030\017 \001(\0132\037.pulse.cd"
  "m.bind.ScalarPowerData\022@\n\021TemperatureSou"
  "rce\030\020 \001(\0132%.pulse.cdm.bind.ScalarTempera"
  "tureData\022D\n\025NextTemperatureSource\030\021 \001(\0132"
  "%.pulse.cdm.bind.ScalarTemperatureData\022H"
  "\n\031TemperatureSourceBaseline\030\022 \001(\0132%.puls"
  "e.cdm.bind.ScalarTemperatureData\022H\n\031Valv"
  "eBreakdownTemperature\030\023 \001(\0132%.pulse.cdm."
  "bind.ScalarTemperatureData\"\274\004\n\022CircuitMa"
  "nagerData\022A\n\016ElectricalNode\030\001 \003(\0132).puls"
  "e.cdm.bind.ElectricalCircuitNodeData\022A\n\016"
  "ElectricalPath\030\002 \003(\0132).pulse.cdm.bind.El"
  "ectricalCircuitPathData\022@\n\021ElectricalCir"
  "cuit\030\003 \003(\0132%.pulse.cdm.bind.ElectricalCi"
  "rcuitData\0227\n\tFluidNode\030\004 \003(\0132$.pulse.cdm"
  ".bind.FluidCircuitNodeData\0227\n\tFluidPath\030"
  "\005 \003(\0132$.pulse.cdm.bind.FluidCircuitPathD"
  "ata\0226\n\014FluidCircuit\030\006 \003(\0132 .pulse.cdm.bi"
  "nd.FluidCircuitData\022;\n\013ThermalNode\030\007 \003(\013"
  "2&.pulse.cdm.bind.ThermalCircuitNodeData"
  "\022;\n\013ThermalPath\030\010 \003(\0132&.pulse.cdm.bind.T"
  "hermalCircuitPathData\022:\n\016ThermalCircuit\030"
  "\t \003(\0132\".pulse.cdm.bind.ThermalCircuitDat"
  "aB#\n\016pulse.cdm.bindH\001\252\002\016pulse.cdm.bindb\006"
  "proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_deps[2] = {
  &::descriptor_table_pulse_2fcdm_2fbind_2fEnums_2eproto,
  &::descriptor_table_pulse_2fcdm_2fbind_2fProperties_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_sccs[13] = {
  &scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
  &scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_once;
static bool descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto = {
  &descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_initialized, descriptor_table_protodef_pulse_2fcdm_2fbind_2fCircuit_2eproto, "pulse/cdm/bind/Circuit.proto", 6406,
  &descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_once, descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_sccs, descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto_deps, 13, 2,
  schemas, file_default_instances, TableStruct_pulse_2fcdm_2fbind_2fCircuit_2eproto::offsets,
  file_level_metadata_pulse_2fcdm_2fbind_2fCircuit_2eproto, 13, file_level_enum_descriptors_pulse_2fcdm_2fbind_2fCircuit_2eproto, file_level_service_descriptors_pulse_2fcdm_2fbind_2fCircuit_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_pulse_2fcdm_2fbind_2fCircuit_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_pulse_2fcdm_2fbind_2fCircuit_2eproto), true);
namespace pulse {
namespace cdm {
namespace bind {

// ===================================================================

void CircuitData::InitAsDefaultInstance() {
}
class CircuitData::_Internal {
 public:
};

CircuitData::CircuitData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.CircuitData)
}
CircuitData::CircuitData(const CircuitData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      node_(from.node_),
      path_(from.path_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.CircuitData)
}

void CircuitData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

CircuitData::~CircuitData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.CircuitData)
  SharedDtor();
}

void CircuitData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CircuitData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CircuitData& CircuitData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void CircuitData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.CircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  node_.Clear();
  path_.Clear();
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

const char* CircuitData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string Name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_mutable_name(), ptr, ctx, "pulse.cdm.bind.CircuitData.Name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string Node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_add_node(), ptr, ctx, "pulse.cdm.bind.CircuitData.Node");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated string Path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_add_path(), ptr, ctx, "pulse.cdm.bind.CircuitData.Path");
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CircuitData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.CircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string Name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitData.Name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated string Node = 2;
  for (int i = 0, n = this->_internal_node_size(); i < n; i++) {
    const auto& s = this->_internal_node(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitData.Node");
    target = stream->WriteString(2, s, target);
  }

  // repeated string Path = 3;
  for (int i = 0, n = this->_internal_path_size(); i < n; i++) {
    const auto& s = this->_internal_path(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitData.Path");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.CircuitData)
  return target;
}

size_t CircuitData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.CircuitData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string Node = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(node_.size());
  for (int i = 0, n = node_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      node_.Get(i));
  }

  // repeated string Path = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(path_.size());
  for (int i = 0, n = path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      path_.Get(i));
  }

  // string Name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CircuitData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.CircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  const CircuitData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CircuitData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.CircuitData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.CircuitData)
    MergeFrom(*source);
  }
}

void CircuitData::MergeFrom(const CircuitData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.CircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  node_.MergeFrom(from.node_);
  path_.MergeFrom(from.path_);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void CircuitData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.CircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CircuitData::CopyFrom(const CircuitData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.CircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircuitData::IsInitialized() const {
  return true;
}

void CircuitData::InternalSwap(CircuitData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  node_.InternalSwap(&other->node_);
  path_.InternalSwap(&other->path_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata CircuitData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CircuitNodeData::InitAsDefaultInstance() {
}
class CircuitNodeData::_Internal {
 public:
};

CircuitNodeData::CircuitNodeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.CircuitNodeData)
}
CircuitNodeData::CircuitNodeData(const CircuitNodeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  referencenode_ = from.referencenode_;
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.CircuitNodeData)
}

void CircuitNodeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  referencenode_ = false;
}

CircuitNodeData::~CircuitNodeData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.CircuitNodeData)
  SharedDtor();
}

void CircuitNodeData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CircuitNodeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CircuitNodeData& CircuitNodeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void CircuitNodeData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.CircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  referencenode_ = false;
  _internal_metadata_.Clear();
}

const char* CircuitNodeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string Name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_mutable_name(), ptr, ctx, "pulse.cdm.bind.CircuitNodeData.Name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool ReferenceNode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          referencenode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CircuitNodeData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.CircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string Name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitNodeData.Name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // bool ReferenceNode = 2;
  if (this->referencenode() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_referencenode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.CircuitNodeData)
  return target;
}

size_t CircuitNodeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.CircuitNodeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bool ReferenceNode = 2;
  if (this->referencenode() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CircuitNodeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.CircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  const CircuitNodeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CircuitNodeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.CircuitNodeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.CircuitNodeData)
    MergeFrom(*source);
  }
}

void CircuitNodeData::MergeFrom(const CircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.CircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.referencenode() != 0) {
    _internal_set_referencenode(from._internal_referencenode());
  }
}

void CircuitNodeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.CircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CircuitNodeData::CopyFrom(const CircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.CircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircuitNodeData::IsInitialized() const {
  return true;
}

void CircuitNodeData::InternalSwap(CircuitNodeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(referencenode_, other->referencenode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CircuitNodeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CircuitPathData::InitAsDefaultInstance() {
}
class CircuitPathData::_Internal {
 public:
};

CircuitPathData::CircuitPathData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.CircuitPathData)
}
CircuitPathData::CircuitPathData(const CircuitPathData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_name().empty()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  sourcenode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_sourcenode().empty()) {
    sourcenode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sourcenode_);
  }
  targetnode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_targetnode().empty()) {
    targetnode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.targetnode_);
  }
  ::memcpy(&switch__, &from.switch__,
    static_cast<size_t>(reinterpret_cast<char*>(&nextpolarizedstate_) -
    reinterpret_cast<char*>(&switch__)) + sizeof(nextpolarizedstate_));
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.CircuitPathData)
}

void CircuitPathData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sourcenode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  targetnode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&switch__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nextpolarizedstate_) -
      reinterpret_cast<char*>(&switch__)) + sizeof(nextpolarizedstate_));
}

CircuitPathData::~CircuitPathData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.CircuitPathData)
  SharedDtor();
}

void CircuitPathData::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sourcenode_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  targetnode_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CircuitPathData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CircuitPathData& CircuitPathData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void CircuitPathData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.CircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  sourcenode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  targetnode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&switch__, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nextpolarizedstate_) -
      reinterpret_cast<char*>(&switch__)) + sizeof(nextpolarizedstate_));
  _internal_metadata_.Clear();
}

const char* CircuitPathData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // string Name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_mutable_name(), ptr, ctx, "pulse.cdm.bind.CircuitPathData.Name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string SourceNode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_mutable_sourcenode(), ptr, ctx, "pulse.cdm.bind.CircuitPathData.SourceNode");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string TargetNode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8(_internal_mutable_targetnode(), ptr, ctx, "pulse.cdm.bind.CircuitPathData.TargetNode");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate Switch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_switch_(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate NextSwitch = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_nextswitch(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate Valve = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_valve(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate NextValve = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_nextvalve(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate PolarizedState = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_polarizedstate(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.eGate NextPolarizedState = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          _internal_set_nextpolarizedstate(static_cast<::pulse::cdm::bind::eGate>(val));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CircuitPathData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.CircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string Name = 1;
  if (this->name().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitPathData.Name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string SourceNode = 2;
  if (this->sourcenode().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sourcenode().data(), static_cast<int>(this->_internal_sourcenode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitPathData.SourceNode");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_sourcenode(), target);
  }

  // string TargetNode = 3;
  if (this->targetnode().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_targetnode().data(), static_cast<int>(this->_internal_targetnode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pulse.cdm.bind.CircuitPathData.TargetNode");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_targetnode(), target);
  }

  // .pulse.cdm.bind.eGate Switch = 4;
  if (this->switch_() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_switch_(), target);
  }

  // .pulse.cdm.bind.eGate NextSwitch = 5;
  if (this->nextswitch() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_nextswitch(), target);
  }

  // .pulse.cdm.bind.eGate Valve = 6;
  if (this->valve() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_valve(), target);
  }

  // .pulse.cdm.bind.eGate NextValve = 7;
  if (this->nextvalve() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_nextvalve(), target);
  }

  // .pulse.cdm.bind.eGate PolarizedState = 8;
  if (this->polarizedstate() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_polarizedstate(), target);
  }

  // .pulse.cdm.bind.eGate NextPolarizedState = 9;
  if (this->nextpolarizedstate() != 0) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_nextpolarizedstate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.CircuitPathData)
  return target;
}

size_t CircuitPathData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.CircuitPathData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string Name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string SourceNode = 2;
  if (this->sourcenode().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sourcenode());
  }

  // string TargetNode = 3;
  if (this->targetnode().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_targetnode());
  }

  // .pulse.cdm.bind.eGate Switch = 4;
  if (this->switch_() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_switch_());
  }

  // .pulse.cdm.bind.eGate NextSwitch = 5;
  if (this->nextswitch() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_nextswitch());
  }

  // .pulse.cdm.bind.eGate Valve = 6;
  if (this->valve() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_valve());
  }

  // .pulse.cdm.bind.eGate NextValve = 7;
  if (this->nextvalve() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_nextvalve());
  }

  // .pulse.cdm.bind.eGate PolarizedState = 8;
  if (this->polarizedstate() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_polarizedstate());
  }

  // .pulse.cdm.bind.eGate NextPolarizedState = 9;
  if (this->nextpolarizedstate() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_nextpolarizedstate());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CircuitPathData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.CircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  const CircuitPathData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CircuitPathData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.CircuitPathData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.CircuitPathData)
    MergeFrom(*source);
  }
}

void CircuitPathData::MergeFrom(const CircuitPathData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.CircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.sourcenode().size() > 0) {

    sourcenode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.sourcenode_);
  }
  if (from.targetnode().size() > 0) {

    targetnode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.targetnode_);
  }
  if (from.switch_() != 0) {
    _internal_set_switch_(from._internal_switch_());
  }
  if (from.nextswitch() != 0) {
    _internal_set_nextswitch(from._internal_nextswitch());
  }
  if (from.valve() != 0) {
    _internal_set_valve(from._internal_valve());
  }
  if (from.nextvalve() != 0) {
    _internal_set_nextvalve(from._internal_nextvalve());
  }
  if (from.polarizedstate() != 0) {
    _internal_set_polarizedstate(from._internal_polarizedstate());
  }
  if (from.nextpolarizedstate() != 0) {
    _internal_set_nextpolarizedstate(from._internal_nextpolarizedstate());
  }
}

void CircuitPathData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.CircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CircuitPathData::CopyFrom(const CircuitPathData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.CircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircuitPathData::IsInitialized() const {
  return true;
}

void CircuitPathData::InternalSwap(CircuitPathData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  sourcenode_.Swap(&other->sourcenode_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  targetnode_.Swap(&other->targetnode_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(switch__, other->switch__);
  swap(nextswitch_, other->nextswitch_);
  swap(valve_, other->valve_);
  swap(nextvalve_, other->nextvalve_);
  swap(polarizedstate_, other->polarizedstate_);
  swap(nextpolarizedstate_, other->nextpolarizedstate_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CircuitPathData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ElectricalCircuitData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ElectricalCircuitData_default_instance_._instance.get_mutable()->circuit_ = const_cast< ::pulse::cdm::bind::CircuitData*>(
      ::pulse::cdm::bind::CircuitData::internal_default_instance());
}
class ElectricalCircuitData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitData& circuit(const ElectricalCircuitData* msg);
};

const ::pulse::cdm::bind::CircuitData&
ElectricalCircuitData::_Internal::circuit(const ElectricalCircuitData* msg) {
  return *msg->circuit_;
}
ElectricalCircuitData::ElectricalCircuitData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ElectricalCircuitData)
}
ElectricalCircuitData::ElectricalCircuitData(const ElectricalCircuitData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuit()) {
    circuit_ = new ::pulse::cdm::bind::CircuitData(*from.circuit_);
  } else {
    circuit_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ElectricalCircuitData)
}

void ElectricalCircuitData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  circuit_ = nullptr;
}

ElectricalCircuitData::~ElectricalCircuitData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ElectricalCircuitData)
  SharedDtor();
}

void ElectricalCircuitData::SharedDtor() {
  if (this != internal_default_instance()) delete circuit_;
}

void ElectricalCircuitData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ElectricalCircuitData& ElectricalCircuitData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ElectricalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ElectricalCircuitData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ElectricalCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ElectricalCircuitData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitData Circuit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ElectricalCircuitData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ElectricalCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ElectricalCircuitData)
  return target;
}

size_t ElectricalCircuitData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ElectricalCircuitData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuit_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElectricalCircuitData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ElectricalCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  const ElectricalCircuitData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ElectricalCircuitData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ElectricalCircuitData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ElectricalCircuitData)
    MergeFrom(*source);
  }
}

void ElectricalCircuitData::MergeFrom(const ElectricalCircuitData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ElectricalCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuit()) {
    _internal_mutable_circuit()->::pulse::cdm::bind::CircuitData::MergeFrom(from._internal_circuit());
  }
}

void ElectricalCircuitData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ElectricalCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ElectricalCircuitData::CopyFrom(const ElectricalCircuitData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ElectricalCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElectricalCircuitData::IsInitialized() const {
  return true;
}

void ElectricalCircuitData::InternalSwap(ElectricalCircuitData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuit_, other->circuit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ElectricalCircuitData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ElectricalCircuitNodeData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->circuitnode_ = const_cast< ::pulse::cdm::bind::CircuitNodeData*>(
      ::pulse::cdm::bind::CircuitNodeData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->voltage_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->nextvoltage_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->charge_ = const_cast< ::pulse::cdm::bind::ScalarElectricChargeData*>(
      ::pulse::cdm::bind::ScalarElectricChargeData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->nextcharge_ = const_cast< ::pulse::cdm::bind::ScalarElectricChargeData*>(
      ::pulse::cdm::bind::ScalarElectricChargeData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitNodeData_default_instance_._instance.get_mutable()->chargebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricChargeData*>(
      ::pulse::cdm::bind::ScalarElectricChargeData::internal_default_instance());
}
class ElectricalCircuitNodeData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitNodeData& circuitnode(const ElectricalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& voltage(const ElectricalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& nextvoltage(const ElectricalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarElectricChargeData& charge(const ElectricalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarElectricChargeData& nextcharge(const ElectricalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarElectricChargeData& chargebaseline(const ElectricalCircuitNodeData* msg);
};

const ::pulse::cdm::bind::CircuitNodeData&
ElectricalCircuitNodeData::_Internal::circuitnode(const ElectricalCircuitNodeData* msg) {
  return *msg->circuitnode_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitNodeData::_Internal::voltage(const ElectricalCircuitNodeData* msg) {
  return *msg->voltage_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitNodeData::_Internal::nextvoltage(const ElectricalCircuitNodeData* msg) {
  return *msg->nextvoltage_;
}
const ::pulse::cdm::bind::ScalarElectricChargeData&
ElectricalCircuitNodeData::_Internal::charge(const ElectricalCircuitNodeData* msg) {
  return *msg->charge_;
}
const ::pulse::cdm::bind::ScalarElectricChargeData&
ElectricalCircuitNodeData::_Internal::nextcharge(const ElectricalCircuitNodeData* msg) {
  return *msg->nextcharge_;
}
const ::pulse::cdm::bind::ScalarElectricChargeData&
ElectricalCircuitNodeData::_Internal::chargebaseline(const ElectricalCircuitNodeData* msg) {
  return *msg->chargebaseline_;
}
void ElectricalCircuitNodeData::clear_voltage() {
  if (GetArenaNoVirtual() == nullptr && voltage_ != nullptr) {
    delete voltage_;
  }
  voltage_ = nullptr;
}
void ElectricalCircuitNodeData::clear_nextvoltage() {
  if (GetArenaNoVirtual() == nullptr && nextvoltage_ != nullptr) {
    delete nextvoltage_;
  }
  nextvoltage_ = nullptr;
}
void ElectricalCircuitNodeData::clear_charge() {
  if (GetArenaNoVirtual() == nullptr && charge_ != nullptr) {
    delete charge_;
  }
  charge_ = nullptr;
}
void ElectricalCircuitNodeData::clear_nextcharge() {
  if (GetArenaNoVirtual() == nullptr && nextcharge_ != nullptr) {
    delete nextcharge_;
  }
  nextcharge_ = nullptr;
}
void ElectricalCircuitNodeData::clear_chargebaseline() {
  if (GetArenaNoVirtual() == nullptr && chargebaseline_ != nullptr) {
    delete chargebaseline_;
  }
  chargebaseline_ = nullptr;
}
ElectricalCircuitNodeData::ElectricalCircuitNodeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ElectricalCircuitNodeData)
}
ElectricalCircuitNodeData::ElectricalCircuitNodeData(const ElectricalCircuitNodeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitnode()) {
    circuitnode_ = new ::pulse::cdm::bind::CircuitNodeData(*from.circuitnode_);
  } else {
    circuitnode_ = nullptr;
  }
  if (from._internal_has_voltage()) {
    voltage_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.voltage_);
  } else {
    voltage_ = nullptr;
  }
  if (from._internal_has_nextvoltage()) {
    nextvoltage_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.nextvoltage_);
  } else {
    nextvoltage_ = nullptr;
  }
  if (from._internal_has_charge()) {
    charge_ = new ::pulse::cdm::bind::ScalarElectricChargeData(*from.charge_);
  } else {
    charge_ = nullptr;
  }
  if (from._internal_has_nextcharge()) {
    nextcharge_ = new ::pulse::cdm::bind::ScalarElectricChargeData(*from.nextcharge_);
  } else {
    nextcharge_ = nullptr;
  }
  if (from._internal_has_chargebaseline()) {
    chargebaseline_ = new ::pulse::cdm::bind::ScalarElectricChargeData(*from.chargebaseline_);
  } else {
    chargebaseline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ElectricalCircuitNodeData)
}

void ElectricalCircuitNodeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitnode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chargebaseline_) -
      reinterpret_cast<char*>(&circuitnode_)) + sizeof(chargebaseline_));
}

ElectricalCircuitNodeData::~ElectricalCircuitNodeData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ElectricalCircuitNodeData)
  SharedDtor();
}

void ElectricalCircuitNodeData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitnode_;
  if (this != internal_default_instance()) delete voltage_;
  if (this != internal_default_instance()) delete nextvoltage_;
  if (this != internal_default_instance()) delete charge_;
  if (this != internal_default_instance()) delete nextcharge_;
  if (this != internal_default_instance()) delete chargebaseline_;
}

void ElectricalCircuitNodeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ElectricalCircuitNodeData& ElectricalCircuitNodeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ElectricalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ElectricalCircuitNodeData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && voltage_ != nullptr) {
    delete voltage_;
  }
  voltage_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextvoltage_ != nullptr) {
    delete nextvoltage_;
  }
  nextvoltage_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && charge_ != nullptr) {
    delete charge_;
  }
  charge_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcharge_ != nullptr) {
    delete nextcharge_;
  }
  nextcharge_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && chargebaseline_ != nullptr) {
    delete chargebaseline_;
  }
  chargebaseline_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ElectricalCircuitNodeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitnode(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData Voltage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_voltage(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltage = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextvoltage(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricChargeData Charge = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_charge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricChargeData NextCharge = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcharge(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricChargeData ChargeBaseline = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_chargebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ElectricalCircuitNodeData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitnode(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData Voltage = 2;
  if (this->has_voltage()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::voltage(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltage = 3;
  if (this->has_nextvoltage()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nextvoltage(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData Charge = 4;
  if (this->has_charge()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::charge(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData NextCharge = 5;
  if (this->has_nextcharge()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::nextcharge(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData ChargeBaseline = 6;
  if (this->has_chargebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::chargebaseline(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ElectricalCircuitNodeData)
  return target;
}

size_t ElectricalCircuitNodeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitnode_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData Voltage = 2;
  if (this->has_voltage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *voltage_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltage = 3;
  if (this->has_nextvoltage()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextvoltage_);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData Charge = 4;
  if (this->has_charge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *charge_);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData NextCharge = 5;
  if (this->has_nextcharge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcharge_);
  }

  // .pulse.cdm.bind.ScalarElectricChargeData ChargeBaseline = 6;
  if (this->has_chargebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *chargebaseline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElectricalCircuitNodeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  const ElectricalCircuitNodeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ElectricalCircuitNodeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ElectricalCircuitNodeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ElectricalCircuitNodeData)
    MergeFrom(*source);
  }
}

void ElectricalCircuitNodeData::MergeFrom(const ElectricalCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitnode()) {
    _internal_mutable_circuitnode()->::pulse::cdm::bind::CircuitNodeData::MergeFrom(from._internal_circuitnode());
  }
  if (from.has_voltage()) {
    _internal_mutable_voltage()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_voltage());
  }
  if (from.has_nextvoltage()) {
    _internal_mutable_nextvoltage()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_nextvoltage());
  }
  if (from.has_charge()) {
    _internal_mutable_charge()->::pulse::cdm::bind::ScalarElectricChargeData::MergeFrom(from._internal_charge());
  }
  if (from.has_nextcharge()) {
    _internal_mutable_nextcharge()->::pulse::cdm::bind::ScalarElectricChargeData::MergeFrom(from._internal_nextcharge());
  }
  if (from.has_chargebaseline()) {
    _internal_mutable_chargebaseline()->::pulse::cdm::bind::ScalarElectricChargeData::MergeFrom(from._internal_chargebaseline());
  }
}

void ElectricalCircuitNodeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ElectricalCircuitNodeData::CopyFrom(const ElectricalCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ElectricalCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElectricalCircuitNodeData::IsInitialized() const {
  return true;
}

void ElectricalCircuitNodeData::InternalSwap(ElectricalCircuitNodeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitnode_, other->circuitnode_);
  swap(voltage_, other->voltage_);
  swap(nextvoltage_, other->nextvoltage_);
  swap(charge_, other->charge_);
  swap(nextcharge_, other->nextcharge_);
  swap(chargebaseline_, other->chargebaseline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ElectricalCircuitNodeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ElectricalCircuitPathData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->circuitpath_ = const_cast< ::pulse::cdm::bind::CircuitPathData*>(
      ::pulse::cdm::bind::CircuitPathData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->resistance_ = const_cast< ::pulse::cdm::bind::ScalarElectricResistanceData*>(
      ::pulse::cdm::bind::ScalarElectricResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextresistance_ = const_cast< ::pulse::cdm::bind::ScalarElectricResistanceData*>(
      ::pulse::cdm::bind::ScalarElectricResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->resistancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricResistanceData*>(
      ::pulse::cdm::bind::ScalarElectricResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->capacitance_ = const_cast< ::pulse::cdm::bind::ScalarElectricCapacitanceData*>(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextcapacitance_ = const_cast< ::pulse::cdm::bind::ScalarElectricCapacitanceData*>(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->capacitancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricCapacitanceData*>(
      ::pulse::cdm::bind::ScalarElectricCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->inductance_ = const_cast< ::pulse::cdm::bind::ScalarElectricInductanceData*>(
      ::pulse::cdm::bind::ScalarElectricInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextinductance_ = const_cast< ::pulse::cdm::bind::ScalarElectricInductanceData*>(
      ::pulse::cdm::bind::ScalarElectricInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->inductancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricInductanceData*>(
      ::pulse::cdm::bind::ScalarElectricInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->current_ = const_cast< ::pulse::cdm::bind::ScalarElectricCurrentData*>(
      ::pulse::cdm::bind::ScalarElectricCurrentData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextcurrent_ = const_cast< ::pulse::cdm::bind::ScalarElectricCurrentData*>(
      ::pulse::cdm::bind::ScalarElectricCurrentData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->currentsource_ = const_cast< ::pulse::cdm::bind::ScalarElectricCurrentData*>(
      ::pulse::cdm::bind::ScalarElectricCurrentData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextcurrentsource_ = const_cast< ::pulse::cdm::bind::ScalarElectricCurrentData*>(
      ::pulse::cdm::bind::ScalarElectricCurrentData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->currentsourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricCurrentData*>(
      ::pulse::cdm::bind::ScalarElectricCurrentData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->voltagesource_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->nextvoltagesource_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->voltagesourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
  ::pulse::cdm::bind::_ElectricalCircuitPathData_default_instance_._instance.get_mutable()->valvebreakdownvoltage_ = const_cast< ::pulse::cdm::bind::ScalarElectricPotentialData*>(
      ::pulse::cdm::bind::ScalarElectricPotentialData::internal_default_instance());
}
class ElectricalCircuitPathData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitPathData& circuitpath(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricResistanceData& resistance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricResistanceData& nextresistance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricResistanceData& resistancebaseline(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCapacitanceData& capacitance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCapacitanceData& nextcapacitance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCapacitanceData& capacitancebaseline(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricInductanceData& inductance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricInductanceData& nextinductance(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricInductanceData& inductancebaseline(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCurrentData& current(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCurrentData& nextcurrent(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCurrentData& currentsource(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCurrentData& nextcurrentsource(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricCurrentData& currentsourcebaseline(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& voltagesource(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& nextvoltagesource(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& voltagesourcebaseline(const ElectricalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarElectricPotentialData& valvebreakdownvoltage(const ElectricalCircuitPathData* msg);
};

const ::pulse::cdm::bind::CircuitPathData&
ElectricalCircuitPathData::_Internal::circuitpath(const ElectricalCircuitPathData* msg) {
  return *msg->circuitpath_;
}
const ::pulse::cdm::bind::ScalarElectricResistanceData&
ElectricalCircuitPathData::_Internal::resistance(const ElectricalCircuitPathData* msg) {
  return *msg->resistance_;
}
const ::pulse::cdm::bind::ScalarElectricResistanceData&
ElectricalCircuitPathData::_Internal::nextresistance(const ElectricalCircuitPathData* msg) {
  return *msg->nextresistance_;
}
const ::pulse::cdm::bind::ScalarElectricResistanceData&
ElectricalCircuitPathData::_Internal::resistancebaseline(const ElectricalCircuitPathData* msg) {
  return *msg->resistancebaseline_;
}
const ::pulse::cdm::bind::ScalarElectricCapacitanceData&
ElectricalCircuitPathData::_Internal::capacitance(const ElectricalCircuitPathData* msg) {
  return *msg->capacitance_;
}
const ::pulse::cdm::bind::ScalarElectricCapacitanceData&
ElectricalCircuitPathData::_Internal::nextcapacitance(const ElectricalCircuitPathData* msg) {
  return *msg->nextcapacitance_;
}
const ::pulse::cdm::bind::ScalarElectricCapacitanceData&
ElectricalCircuitPathData::_Internal::capacitancebaseline(const ElectricalCircuitPathData* msg) {
  return *msg->capacitancebaseline_;
}
const ::pulse::cdm::bind::ScalarElectricInductanceData&
ElectricalCircuitPathData::_Internal::inductance(const ElectricalCircuitPathData* msg) {
  return *msg->inductance_;
}
const ::pulse::cdm::bind::ScalarElectricInductanceData&
ElectricalCircuitPathData::_Internal::nextinductance(const ElectricalCircuitPathData* msg) {
  return *msg->nextinductance_;
}
const ::pulse::cdm::bind::ScalarElectricInductanceData&
ElectricalCircuitPathData::_Internal::inductancebaseline(const ElectricalCircuitPathData* msg) {
  return *msg->inductancebaseline_;
}
const ::pulse::cdm::bind::ScalarElectricCurrentData&
ElectricalCircuitPathData::_Internal::current(const ElectricalCircuitPathData* msg) {
  return *msg->current_;
}
const ::pulse::cdm::bind::ScalarElectricCurrentData&
ElectricalCircuitPathData::_Internal::nextcurrent(const ElectricalCircuitPathData* msg) {
  return *msg->nextcurrent_;
}
const ::pulse::cdm::bind::ScalarElectricCurrentData&
ElectricalCircuitPathData::_Internal::currentsource(const ElectricalCircuitPathData* msg) {
  return *msg->currentsource_;
}
const ::pulse::cdm::bind::ScalarElectricCurrentData&
ElectricalCircuitPathData::_Internal::nextcurrentsource(const ElectricalCircuitPathData* msg) {
  return *msg->nextcurrentsource_;
}
const ::pulse::cdm::bind::ScalarElectricCurrentData&
ElectricalCircuitPathData::_Internal::currentsourcebaseline(const ElectricalCircuitPathData* msg) {
  return *msg->currentsourcebaseline_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitPathData::_Internal::voltagesource(const ElectricalCircuitPathData* msg) {
  return *msg->voltagesource_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitPathData::_Internal::nextvoltagesource(const ElectricalCircuitPathData* msg) {
  return *msg->nextvoltagesource_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitPathData::_Internal::voltagesourcebaseline(const ElectricalCircuitPathData* msg) {
  return *msg->voltagesourcebaseline_;
}
const ::pulse::cdm::bind::ScalarElectricPotentialData&
ElectricalCircuitPathData::_Internal::valvebreakdownvoltage(const ElectricalCircuitPathData* msg) {
  return *msg->valvebreakdownvoltage_;
}
void ElectricalCircuitPathData::clear_resistance() {
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextresistance() {
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
}
void ElectricalCircuitPathData::clear_resistancebaseline() {
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
}
void ElectricalCircuitPathData::clear_capacitance() {
  if (GetArenaNoVirtual() == nullptr && capacitance_ != nullptr) {
    delete capacitance_;
  }
  capacitance_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextcapacitance() {
  if (GetArenaNoVirtual() == nullptr && nextcapacitance_ != nullptr) {
    delete nextcapacitance_;
  }
  nextcapacitance_ = nullptr;
}
void ElectricalCircuitPathData::clear_capacitancebaseline() {
  if (GetArenaNoVirtual() == nullptr && capacitancebaseline_ != nullptr) {
    delete capacitancebaseline_;
  }
  capacitancebaseline_ = nullptr;
}
void ElectricalCircuitPathData::clear_inductance() {
  if (GetArenaNoVirtual() == nullptr && inductance_ != nullptr) {
    delete inductance_;
  }
  inductance_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextinductance() {
  if (GetArenaNoVirtual() == nullptr && nextinductance_ != nullptr) {
    delete nextinductance_;
  }
  nextinductance_ = nullptr;
}
void ElectricalCircuitPathData::clear_inductancebaseline() {
  if (GetArenaNoVirtual() == nullptr && inductancebaseline_ != nullptr) {
    delete inductancebaseline_;
  }
  inductancebaseline_ = nullptr;
}
void ElectricalCircuitPathData::clear_current() {
  if (GetArenaNoVirtual() == nullptr && current_ != nullptr) {
    delete current_;
  }
  current_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextcurrent() {
  if (GetArenaNoVirtual() == nullptr && nextcurrent_ != nullptr) {
    delete nextcurrent_;
  }
  nextcurrent_ = nullptr;
}
void ElectricalCircuitPathData::clear_currentsource() {
  if (GetArenaNoVirtual() == nullptr && currentsource_ != nullptr) {
    delete currentsource_;
  }
  currentsource_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextcurrentsource() {
  if (GetArenaNoVirtual() == nullptr && nextcurrentsource_ != nullptr) {
    delete nextcurrentsource_;
  }
  nextcurrentsource_ = nullptr;
}
void ElectricalCircuitPathData::clear_currentsourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && currentsourcebaseline_ != nullptr) {
    delete currentsourcebaseline_;
  }
  currentsourcebaseline_ = nullptr;
}
void ElectricalCircuitPathData::clear_voltagesource() {
  if (GetArenaNoVirtual() == nullptr && voltagesource_ != nullptr) {
    delete voltagesource_;
  }
  voltagesource_ = nullptr;
}
void ElectricalCircuitPathData::clear_nextvoltagesource() {
  if (GetArenaNoVirtual() == nullptr && nextvoltagesource_ != nullptr) {
    delete nextvoltagesource_;
  }
  nextvoltagesource_ = nullptr;
}
void ElectricalCircuitPathData::clear_voltagesourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && voltagesourcebaseline_ != nullptr) {
    delete voltagesourcebaseline_;
  }
  voltagesourcebaseline_ = nullptr;
}
void ElectricalCircuitPathData::clear_valvebreakdownvoltage() {
  if (GetArenaNoVirtual() == nullptr && valvebreakdownvoltage_ != nullptr) {
    delete valvebreakdownvoltage_;
  }
  valvebreakdownvoltage_ = nullptr;
}
ElectricalCircuitPathData::ElectricalCircuitPathData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ElectricalCircuitPathData)
}
ElectricalCircuitPathData::ElectricalCircuitPathData(const ElectricalCircuitPathData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitpath()) {
    circuitpath_ = new ::pulse::cdm::bind::CircuitPathData(*from.circuitpath_);
  } else {
    circuitpath_ = nullptr;
  }
  if (from._internal_has_resistance()) {
    resistance_ = new ::pulse::cdm::bind::ScalarElectricResistanceData(*from.resistance_);
  } else {
    resistance_ = nullptr;
  }
  if (from._internal_has_nextresistance()) {
    nextresistance_ = new ::pulse::cdm::bind::ScalarElectricResistanceData(*from.nextresistance_);
  } else {
    nextresistance_ = nullptr;
  }
  if (from._internal_has_resistancebaseline()) {
    resistancebaseline_ = new ::pulse::cdm::bind::ScalarElectricResistanceData(*from.resistancebaseline_);
  } else {
    resistancebaseline_ = nullptr;
  }
  if (from._internal_has_capacitance()) {
    capacitance_ = new ::pulse::cdm::bind::ScalarElectricCapacitanceData(*from.capacitance_);
  } else {
    capacitance_ = nullptr;
  }
  if (from._internal_has_nextcapacitance()) {
    nextcapacitance_ = new ::pulse::cdm::bind::ScalarElectricCapacitanceData(*from.nextcapacitance_);
  } else {
    nextcapacitance_ = nullptr;
  }
  if (from._internal_has_capacitancebaseline()) {
    capacitancebaseline_ = new ::pulse::cdm::bind::ScalarElectricCapacitanceData(*from.capacitancebaseline_);
  } else {
    capacitancebaseline_ = nullptr;
  }
  if (from._internal_has_inductance()) {
    inductance_ = new ::pulse::cdm::bind::ScalarElectricInductanceData(*from.inductance_);
  } else {
    inductance_ = nullptr;
  }
  if (from._internal_has_nextinductance()) {
    nextinductance_ = new ::pulse::cdm::bind::ScalarElectricInductanceData(*from.nextinductance_);
  } else {
    nextinductance_ = nullptr;
  }
  if (from._internal_has_inductancebaseline()) {
    inductancebaseline_ = new ::pulse::cdm::bind::ScalarElectricInductanceData(*from.inductancebaseline_);
  } else {
    inductancebaseline_ = nullptr;
  }
  if (from._internal_has_current()) {
    current_ = new ::pulse::cdm::bind::ScalarElectricCurrentData(*from.current_);
  } else {
    current_ = nullptr;
  }
  if (from._internal_has_nextcurrent()) {
    nextcurrent_ = new ::pulse::cdm::bind::ScalarElectricCurrentData(*from.nextcurrent_);
  } else {
    nextcurrent_ = nullptr;
  }
  if (from._internal_has_currentsource()) {
    currentsource_ = new ::pulse::cdm::bind::ScalarElectricCurrentData(*from.currentsource_);
  } else {
    currentsource_ = nullptr;
  }
  if (from._internal_has_nextcurrentsource()) {
    nextcurrentsource_ = new ::pulse::cdm::bind::ScalarElectricCurrentData(*from.nextcurrentsource_);
  } else {
    nextcurrentsource_ = nullptr;
  }
  if (from._internal_has_currentsourcebaseline()) {
    currentsourcebaseline_ = new ::pulse::cdm::bind::ScalarElectricCurrentData(*from.currentsourcebaseline_);
  } else {
    currentsourcebaseline_ = nullptr;
  }
  if (from._internal_has_voltagesource()) {
    voltagesource_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.voltagesource_);
  } else {
    voltagesource_ = nullptr;
  }
  if (from._internal_has_nextvoltagesource()) {
    nextvoltagesource_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.nextvoltagesource_);
  } else {
    nextvoltagesource_ = nullptr;
  }
  if (from._internal_has_voltagesourcebaseline()) {
    voltagesourcebaseline_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.voltagesourcebaseline_);
  } else {
    voltagesourcebaseline_ = nullptr;
  }
  if (from._internal_has_valvebreakdownvoltage()) {
    valvebreakdownvoltage_ = new ::pulse::cdm::bind::ScalarElectricPotentialData(*from.valvebreakdownvoltage_);
  } else {
    valvebreakdownvoltage_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ElectricalCircuitPathData)
}

void ElectricalCircuitPathData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitpath_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valvebreakdownvoltage_) -
      reinterpret_cast<char*>(&circuitpath_)) + sizeof(valvebreakdownvoltage_));
}

ElectricalCircuitPathData::~ElectricalCircuitPathData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ElectricalCircuitPathData)
  SharedDtor();
}

void ElectricalCircuitPathData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitpath_;
  if (this != internal_default_instance()) delete resistance_;
  if (this != internal_default_instance()) delete nextresistance_;
  if (this != internal_default_instance()) delete resistancebaseline_;
  if (this != internal_default_instance()) delete capacitance_;
  if (this != internal_default_instance()) delete nextcapacitance_;
  if (this != internal_default_instance()) delete capacitancebaseline_;
  if (this != internal_default_instance()) delete inductance_;
  if (this != internal_default_instance()) delete nextinductance_;
  if (this != internal_default_instance()) delete inductancebaseline_;
  if (this != internal_default_instance()) delete current_;
  if (this != internal_default_instance()) delete nextcurrent_;
  if (this != internal_default_instance()) delete currentsource_;
  if (this != internal_default_instance()) delete nextcurrentsource_;
  if (this != internal_default_instance()) delete currentsourcebaseline_;
  if (this != internal_default_instance()) delete voltagesource_;
  if (this != internal_default_instance()) delete nextvoltagesource_;
  if (this != internal_default_instance()) delete voltagesourcebaseline_;
  if (this != internal_default_instance()) delete valvebreakdownvoltage_;
}

void ElectricalCircuitPathData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ElectricalCircuitPathData& ElectricalCircuitPathData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ElectricalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ElectricalCircuitPathData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ElectricalCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && capacitance_ != nullptr) {
    delete capacitance_;
  }
  capacitance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcapacitance_ != nullptr) {
    delete nextcapacitance_;
  }
  nextcapacitance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && capacitancebaseline_ != nullptr) {
    delete capacitancebaseline_;
  }
  capacitancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inductance_ != nullptr) {
    delete inductance_;
  }
  inductance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextinductance_ != nullptr) {
    delete nextinductance_;
  }
  nextinductance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inductancebaseline_ != nullptr) {
    delete inductancebaseline_;
  }
  inductancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && current_ != nullptr) {
    delete current_;
  }
  current_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcurrent_ != nullptr) {
    delete nextcurrent_;
  }
  nextcurrent_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && currentsource_ != nullptr) {
    delete currentsource_;
  }
  currentsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcurrentsource_ != nullptr) {
    delete nextcurrentsource_;
  }
  nextcurrentsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && currentsourcebaseline_ != nullptr) {
    delete currentsourcebaseline_;
  }
  currentsourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && voltagesource_ != nullptr) {
    delete voltagesource_;
  }
  voltagesource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextvoltagesource_ != nullptr) {
    delete nextvoltagesource_;
  }
  nextvoltagesource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && voltagesourcebaseline_ != nullptr) {
    delete voltagesourcebaseline_;
  }
  voltagesourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && valvebreakdownvoltage_ != nullptr) {
    delete valvebreakdownvoltage_;
  }
  valvebreakdownvoltage_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ElectricalCircuitPathData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitpath(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricResistanceData Resistance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricResistanceData NextResistance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextresistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricResistanceData ResistanceBaseline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCapacitanceData Capacitance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_capacitance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCapacitanceData NextCapacitance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcapacitance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCapacitanceData CapacitanceBaseline = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_capacitancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricInductanceData Inductance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_inductance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricInductanceData NextInductance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextinductance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricInductanceData InductanceBaseline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_inductancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCurrentData Current = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_current(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrent = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcurrent(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSource = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_currentsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrentSource = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcurrentsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSourceBaseline = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_currentsourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSource = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_voltagesource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltageSource = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextvoltagesource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSourceBaseline = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_voltagesourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarElectricPotentialData ValveBreakdownVoltage = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_valvebreakdownvoltage(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ElectricalCircuitPathData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ElectricalCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitpath(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData Resistance = 2;
  if (this->has_resistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::resistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData NextResistance = 3;
  if (this->has_nextresistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nextresistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::resistancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData Capacitance = 5;
  if (this->has_capacitance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::capacitance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData NextCapacitance = 6;
  if (this->has_nextcapacitance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::nextcapacitance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData CapacitanceBaseline = 7;
  if (this->has_capacitancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::capacitancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData Inductance = 8;
  if (this->has_inductance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::inductance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData NextInductance = 9;
  if (this->has_nextinductance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::nextinductance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData InductanceBaseline = 10;
  if (this->has_inductancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, _Internal::inductancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData Current = 11;
  if (this->has_current()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, _Internal::current(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrent = 12;
  if (this->has_nextcurrent()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, _Internal::nextcurrent(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSource = 13;
  if (this->has_currentsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, _Internal::currentsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrentSource = 14;
  if (this->has_nextcurrentsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, _Internal::nextcurrentsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSourceBaseline = 15;
  if (this->has_currentsourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        15, _Internal::currentsourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSource = 16;
  if (this->has_voltagesource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, _Internal::voltagesource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltageSource = 17;
  if (this->has_nextvoltagesource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        17, _Internal::nextvoltagesource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSourceBaseline = 18;
  if (this->has_voltagesourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, _Internal::voltagesourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData ValveBreakdownVoltage = 19;
  if (this->has_valvebreakdownvoltage()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        19, _Internal::valvebreakdownvoltage(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ElectricalCircuitPathData)
  return target;
}

size_t ElectricalCircuitPathData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ElectricalCircuitPathData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitpath_);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData Resistance = 2;
  if (this->has_resistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistance_);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData NextResistance = 3;
  if (this->has_nextresistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextresistance_);
  }

  // .pulse.cdm.bind.ScalarElectricResistanceData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistancebaseline_);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData Capacitance = 5;
  if (this->has_capacitance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *capacitance_);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData NextCapacitance = 6;
  if (this->has_nextcapacitance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcapacitance_);
  }

  // .pulse.cdm.bind.ScalarElectricCapacitanceData CapacitanceBaseline = 7;
  if (this->has_capacitancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *capacitancebaseline_);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData Inductance = 8;
  if (this->has_inductance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inductance_);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData NextInductance = 9;
  if (this->has_nextinductance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextinductance_);
  }

  // .pulse.cdm.bind.ScalarElectricInductanceData InductanceBaseline = 10;
  if (this->has_inductancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inductancebaseline_);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData Current = 11;
  if (this->has_current()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *current_);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrent = 12;
  if (this->has_nextcurrent()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcurrent_);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSource = 13;
  if (this->has_currentsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *currentsource_);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData NextCurrentSource = 14;
  if (this->has_nextcurrentsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcurrentsource_);
  }

  // .pulse.cdm.bind.ScalarElectricCurrentData CurrentSourceBaseline = 15;
  if (this->has_currentsourcebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *currentsourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSource = 16;
  if (this->has_voltagesource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *voltagesource_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData NextVoltageSource = 17;
  if (this->has_nextvoltagesource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextvoltagesource_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData VoltageSourceBaseline = 18;
  if (this->has_voltagesourcebaseline()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *voltagesourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarElectricPotentialData ValveBreakdownVoltage = 19;
  if (this->has_valvebreakdownvoltage()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *valvebreakdownvoltage_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ElectricalCircuitPathData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ElectricalCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  const ElectricalCircuitPathData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ElectricalCircuitPathData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ElectricalCircuitPathData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ElectricalCircuitPathData)
    MergeFrom(*source);
  }
}

void ElectricalCircuitPathData::MergeFrom(const ElectricalCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ElectricalCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitpath()) {
    _internal_mutable_circuitpath()->::pulse::cdm::bind::CircuitPathData::MergeFrom(from._internal_circuitpath());
  }
  if (from.has_resistance()) {
    _internal_mutable_resistance()->::pulse::cdm::bind::ScalarElectricResistanceData::MergeFrom(from._internal_resistance());
  }
  if (from.has_nextresistance()) {
    _internal_mutable_nextresistance()->::pulse::cdm::bind::ScalarElectricResistanceData::MergeFrom(from._internal_nextresistance());
  }
  if (from.has_resistancebaseline()) {
    _internal_mutable_resistancebaseline()->::pulse::cdm::bind::ScalarElectricResistanceData::MergeFrom(from._internal_resistancebaseline());
  }
  if (from.has_capacitance()) {
    _internal_mutable_capacitance()->::pulse::cdm::bind::ScalarElectricCapacitanceData::MergeFrom(from._internal_capacitance());
  }
  if (from.has_nextcapacitance()) {
    _internal_mutable_nextcapacitance()->::pulse::cdm::bind::ScalarElectricCapacitanceData::MergeFrom(from._internal_nextcapacitance());
  }
  if (from.has_capacitancebaseline()) {
    _internal_mutable_capacitancebaseline()->::pulse::cdm::bind::ScalarElectricCapacitanceData::MergeFrom(from._internal_capacitancebaseline());
  }
  if (from.has_inductance()) {
    _internal_mutable_inductance()->::pulse::cdm::bind::ScalarElectricInductanceData::MergeFrom(from._internal_inductance());
  }
  if (from.has_nextinductance()) {
    _internal_mutable_nextinductance()->::pulse::cdm::bind::ScalarElectricInductanceData::MergeFrom(from._internal_nextinductance());
  }
  if (from.has_inductancebaseline()) {
    _internal_mutable_inductancebaseline()->::pulse::cdm::bind::ScalarElectricInductanceData::MergeFrom(from._internal_inductancebaseline());
  }
  if (from.has_current()) {
    _internal_mutable_current()->::pulse::cdm::bind::ScalarElectricCurrentData::MergeFrom(from._internal_current());
  }
  if (from.has_nextcurrent()) {
    _internal_mutable_nextcurrent()->::pulse::cdm::bind::ScalarElectricCurrentData::MergeFrom(from._internal_nextcurrent());
  }
  if (from.has_currentsource()) {
    _internal_mutable_currentsource()->::pulse::cdm::bind::ScalarElectricCurrentData::MergeFrom(from._internal_currentsource());
  }
  if (from.has_nextcurrentsource()) {
    _internal_mutable_nextcurrentsource()->::pulse::cdm::bind::ScalarElectricCurrentData::MergeFrom(from._internal_nextcurrentsource());
  }
  if (from.has_currentsourcebaseline()) {
    _internal_mutable_currentsourcebaseline()->::pulse::cdm::bind::ScalarElectricCurrentData::MergeFrom(from._internal_currentsourcebaseline());
  }
  if (from.has_voltagesource()) {
    _internal_mutable_voltagesource()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_voltagesource());
  }
  if (from.has_nextvoltagesource()) {
    _internal_mutable_nextvoltagesource()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_nextvoltagesource());
  }
  if (from.has_voltagesourcebaseline()) {
    _internal_mutable_voltagesourcebaseline()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_voltagesourcebaseline());
  }
  if (from.has_valvebreakdownvoltage()) {
    _internal_mutable_valvebreakdownvoltage()->::pulse::cdm::bind::ScalarElectricPotentialData::MergeFrom(from._internal_valvebreakdownvoltage());
  }
}

void ElectricalCircuitPathData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ElectricalCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ElectricalCircuitPathData::CopyFrom(const ElectricalCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ElectricalCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ElectricalCircuitPathData::IsInitialized() const {
  return true;
}

void ElectricalCircuitPathData::InternalSwap(ElectricalCircuitPathData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitpath_, other->circuitpath_);
  swap(resistance_, other->resistance_);
  swap(nextresistance_, other->nextresistance_);
  swap(resistancebaseline_, other->resistancebaseline_);
  swap(capacitance_, other->capacitance_);
  swap(nextcapacitance_, other->nextcapacitance_);
  swap(capacitancebaseline_, other->capacitancebaseline_);
  swap(inductance_, other->inductance_);
  swap(nextinductance_, other->nextinductance_);
  swap(inductancebaseline_, other->inductancebaseline_);
  swap(current_, other->current_);
  swap(nextcurrent_, other->nextcurrent_);
  swap(currentsource_, other->currentsource_);
  swap(nextcurrentsource_, other->nextcurrentsource_);
  swap(currentsourcebaseline_, other->currentsourcebaseline_);
  swap(voltagesource_, other->voltagesource_);
  swap(nextvoltagesource_, other->nextvoltagesource_);
  swap(voltagesourcebaseline_, other->voltagesourcebaseline_);
  swap(valvebreakdownvoltage_, other->valvebreakdownvoltage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ElectricalCircuitPathData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FluidCircuitData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_FluidCircuitData_default_instance_._instance.get_mutable()->circuit_ = const_cast< ::pulse::cdm::bind::CircuitData*>(
      ::pulse::cdm::bind::CircuitData::internal_default_instance());
}
class FluidCircuitData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitData& circuit(const FluidCircuitData* msg);
};

const ::pulse::cdm::bind::CircuitData&
FluidCircuitData::_Internal::circuit(const FluidCircuitData* msg) {
  return *msg->circuit_;
}
FluidCircuitData::FluidCircuitData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.FluidCircuitData)
}
FluidCircuitData::FluidCircuitData(const FluidCircuitData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuit()) {
    circuit_ = new ::pulse::cdm::bind::CircuitData(*from.circuit_);
  } else {
    circuit_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.FluidCircuitData)
}

void FluidCircuitData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  circuit_ = nullptr;
}

FluidCircuitData::~FluidCircuitData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.FluidCircuitData)
  SharedDtor();
}

void FluidCircuitData::SharedDtor() {
  if (this != internal_default_instance()) delete circuit_;
}

void FluidCircuitData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FluidCircuitData& FluidCircuitData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FluidCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void FluidCircuitData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.FluidCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
  _internal_metadata_.Clear();
}

const char* FluidCircuitData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitData Circuit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FluidCircuitData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.FluidCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.FluidCircuitData)
  return target;
}

size_t FluidCircuitData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.FluidCircuitData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuit_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FluidCircuitData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.FluidCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  const FluidCircuitData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FluidCircuitData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.FluidCircuitData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.FluidCircuitData)
    MergeFrom(*source);
  }
}

void FluidCircuitData::MergeFrom(const FluidCircuitData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.FluidCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuit()) {
    _internal_mutable_circuit()->::pulse::cdm::bind::CircuitData::MergeFrom(from._internal_circuit());
  }
}

void FluidCircuitData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.FluidCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FluidCircuitData::CopyFrom(const FluidCircuitData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.FluidCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FluidCircuitData::IsInitialized() const {
  return true;
}

void FluidCircuitData::InternalSwap(FluidCircuitData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuit_, other->circuit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FluidCircuitData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FluidCircuitNodeData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->circuitnode_ = const_cast< ::pulse::cdm::bind::CircuitNodeData*>(
      ::pulse::cdm::bind::CircuitNodeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->pressure_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->nextpressure_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->volume_ = const_cast< ::pulse::cdm::bind::ScalarVolumeData*>(
      ::pulse::cdm::bind::ScalarVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->nextvolume_ = const_cast< ::pulse::cdm::bind::ScalarVolumeData*>(
      ::pulse::cdm::bind::ScalarVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitNodeData_default_instance_._instance.get_mutable()->volumebaseline_ = const_cast< ::pulse::cdm::bind::ScalarVolumeData*>(
      ::pulse::cdm::bind::ScalarVolumeData::internal_default_instance());
}
class FluidCircuitNodeData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitNodeData& circuitnode(const FluidCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& pressure(const FluidCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& nextpressure(const FluidCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarVolumeData& volume(const FluidCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarVolumeData& nextvolume(const FluidCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarVolumeData& volumebaseline(const FluidCircuitNodeData* msg);
};

const ::pulse::cdm::bind::CircuitNodeData&
FluidCircuitNodeData::_Internal::circuitnode(const FluidCircuitNodeData* msg) {
  return *msg->circuitnode_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitNodeData::_Internal::pressure(const FluidCircuitNodeData* msg) {
  return *msg->pressure_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitNodeData::_Internal::nextpressure(const FluidCircuitNodeData* msg) {
  return *msg->nextpressure_;
}
const ::pulse::cdm::bind::ScalarVolumeData&
FluidCircuitNodeData::_Internal::volume(const FluidCircuitNodeData* msg) {
  return *msg->volume_;
}
const ::pulse::cdm::bind::ScalarVolumeData&
FluidCircuitNodeData::_Internal::nextvolume(const FluidCircuitNodeData* msg) {
  return *msg->nextvolume_;
}
const ::pulse::cdm::bind::ScalarVolumeData&
FluidCircuitNodeData::_Internal::volumebaseline(const FluidCircuitNodeData* msg) {
  return *msg->volumebaseline_;
}
void FluidCircuitNodeData::clear_pressure() {
  if (GetArenaNoVirtual() == nullptr && pressure_ != nullptr) {
    delete pressure_;
  }
  pressure_ = nullptr;
}
void FluidCircuitNodeData::clear_nextpressure() {
  if (GetArenaNoVirtual() == nullptr && nextpressure_ != nullptr) {
    delete nextpressure_;
  }
  nextpressure_ = nullptr;
}
void FluidCircuitNodeData::clear_volume() {
  if (GetArenaNoVirtual() == nullptr && volume_ != nullptr) {
    delete volume_;
  }
  volume_ = nullptr;
}
void FluidCircuitNodeData::clear_nextvolume() {
  if (GetArenaNoVirtual() == nullptr && nextvolume_ != nullptr) {
    delete nextvolume_;
  }
  nextvolume_ = nullptr;
}
void FluidCircuitNodeData::clear_volumebaseline() {
  if (GetArenaNoVirtual() == nullptr && volumebaseline_ != nullptr) {
    delete volumebaseline_;
  }
  volumebaseline_ = nullptr;
}
FluidCircuitNodeData::FluidCircuitNodeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.FluidCircuitNodeData)
}
FluidCircuitNodeData::FluidCircuitNodeData(const FluidCircuitNodeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitnode()) {
    circuitnode_ = new ::pulse::cdm::bind::CircuitNodeData(*from.circuitnode_);
  } else {
    circuitnode_ = nullptr;
  }
  if (from._internal_has_pressure()) {
    pressure_ = new ::pulse::cdm::bind::ScalarPressureData(*from.pressure_);
  } else {
    pressure_ = nullptr;
  }
  if (from._internal_has_nextpressure()) {
    nextpressure_ = new ::pulse::cdm::bind::ScalarPressureData(*from.nextpressure_);
  } else {
    nextpressure_ = nullptr;
  }
  if (from._internal_has_volume()) {
    volume_ = new ::pulse::cdm::bind::ScalarVolumeData(*from.volume_);
  } else {
    volume_ = nullptr;
  }
  if (from._internal_has_nextvolume()) {
    nextvolume_ = new ::pulse::cdm::bind::ScalarVolumeData(*from.nextvolume_);
  } else {
    nextvolume_ = nullptr;
  }
  if (from._internal_has_volumebaseline()) {
    volumebaseline_ = new ::pulse::cdm::bind::ScalarVolumeData(*from.volumebaseline_);
  } else {
    volumebaseline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.FluidCircuitNodeData)
}

void FluidCircuitNodeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitnode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&volumebaseline_) -
      reinterpret_cast<char*>(&circuitnode_)) + sizeof(volumebaseline_));
}

FluidCircuitNodeData::~FluidCircuitNodeData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.FluidCircuitNodeData)
  SharedDtor();
}

void FluidCircuitNodeData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitnode_;
  if (this != internal_default_instance()) delete pressure_;
  if (this != internal_default_instance()) delete nextpressure_;
  if (this != internal_default_instance()) delete volume_;
  if (this != internal_default_instance()) delete nextvolume_;
  if (this != internal_default_instance()) delete volumebaseline_;
}

void FluidCircuitNodeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FluidCircuitNodeData& FluidCircuitNodeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FluidCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void FluidCircuitNodeData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.FluidCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && pressure_ != nullptr) {
    delete pressure_;
  }
  pressure_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextpressure_ != nullptr) {
    delete nextpressure_;
  }
  nextpressure_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && volume_ != nullptr) {
    delete volume_;
  }
  volume_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextvolume_ != nullptr) {
    delete nextvolume_;
  }
  nextvolume_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && volumebaseline_ != nullptr) {
    delete volumebaseline_;
  }
  volumebaseline_ = nullptr;
  _internal_metadata_.Clear();
}

const char* FluidCircuitNodeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitnode(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData Pressure = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pressure(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData NextPressure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextpressure(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumeData Volume = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumeData NextVolume = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextvolume(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumeData VolumeBaseline = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_volumebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FluidCircuitNodeData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.FluidCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitnode(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData Pressure = 2;
  if (this->has_pressure()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::pressure(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData NextPressure = 3;
  if (this->has_nextpressure()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nextpressure(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumeData Volume = 4;
  if (this->has_volume()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::volume(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumeData NextVolume = 5;
  if (this->has_nextvolume()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::nextvolume(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumeData VolumeBaseline = 6;
  if (this->has_volumebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::volumebaseline(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.FluidCircuitNodeData)
  return target;
}

size_t FluidCircuitNodeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.FluidCircuitNodeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitnode_);
  }

  // .pulse.cdm.bind.ScalarPressureData Pressure = 2;
  if (this->has_pressure()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pressure_);
  }

  // .pulse.cdm.bind.ScalarPressureData NextPressure = 3;
  if (this->has_nextpressure()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextpressure_);
  }

  // .pulse.cdm.bind.ScalarVolumeData Volume = 4;
  if (this->has_volume()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *volume_);
  }

  // .pulse.cdm.bind.ScalarVolumeData NextVolume = 5;
  if (this->has_nextvolume()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextvolume_);
  }

  // .pulse.cdm.bind.ScalarVolumeData VolumeBaseline = 6;
  if (this->has_volumebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *volumebaseline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FluidCircuitNodeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.FluidCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  const FluidCircuitNodeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FluidCircuitNodeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.FluidCircuitNodeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.FluidCircuitNodeData)
    MergeFrom(*source);
  }
}

void FluidCircuitNodeData::MergeFrom(const FluidCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.FluidCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitnode()) {
    _internal_mutable_circuitnode()->::pulse::cdm::bind::CircuitNodeData::MergeFrom(from._internal_circuitnode());
  }
  if (from.has_pressure()) {
    _internal_mutable_pressure()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_pressure());
  }
  if (from.has_nextpressure()) {
    _internal_mutable_nextpressure()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_nextpressure());
  }
  if (from.has_volume()) {
    _internal_mutable_volume()->::pulse::cdm::bind::ScalarVolumeData::MergeFrom(from._internal_volume());
  }
  if (from.has_nextvolume()) {
    _internal_mutable_nextvolume()->::pulse::cdm::bind::ScalarVolumeData::MergeFrom(from._internal_nextvolume());
  }
  if (from.has_volumebaseline()) {
    _internal_mutable_volumebaseline()->::pulse::cdm::bind::ScalarVolumeData::MergeFrom(from._internal_volumebaseline());
  }
}

void FluidCircuitNodeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.FluidCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FluidCircuitNodeData::CopyFrom(const FluidCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.FluidCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FluidCircuitNodeData::IsInitialized() const {
  return true;
}

void FluidCircuitNodeData::InternalSwap(FluidCircuitNodeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitnode_, other->circuitnode_);
  swap(pressure_, other->pressure_);
  swap(nextpressure_, other->nextpressure_);
  swap(volume_, other->volume_);
  swap(nextvolume_, other->nextvolume_);
  swap(volumebaseline_, other->volumebaseline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FluidCircuitNodeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FluidCircuitPathData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->circuitpath_ = const_cast< ::pulse::cdm::bind::CircuitPathData*>(
      ::pulse::cdm::bind::CircuitPathData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->resistance_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimePerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextresistance_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimePerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->resistancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimePerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimePerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->compliance_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerPressureData*>(
      ::pulse::cdm::bind::ScalarVolumePerPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextcompliance_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerPressureData*>(
      ::pulse::cdm::bind::ScalarVolumePerPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->compliancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerPressureData*>(
      ::pulse::cdm::bind::ScalarVolumePerPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->inertance_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextinertance_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->inertancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData*>(
      ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->flow_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData*>(
      ::pulse::cdm::bind::ScalarVolumePerTimeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextflow_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData*>(
      ::pulse::cdm::bind::ScalarVolumePerTimeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->flowsource_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData*>(
      ::pulse::cdm::bind::ScalarVolumePerTimeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextflowsource_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData*>(
      ::pulse::cdm::bind::ScalarVolumePerTimeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->flowsourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarVolumePerTimeData*>(
      ::pulse::cdm::bind::ScalarVolumePerTimeData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->pressuresource_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->nextpressuresource_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->pressuresourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
  ::pulse::cdm::bind::_FluidCircuitPathData_default_instance_._instance.get_mutable()->valvebreakdownpressure_ = const_cast< ::pulse::cdm::bind::ScalarPressureData*>(
      ::pulse::cdm::bind::ScalarPressureData::internal_default_instance());
}
class FluidCircuitPathData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitPathData& circuitpath(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& resistance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& nextresistance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData& resistancebaseline(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerPressureData& compliance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerPressureData& nextcompliance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerPressureData& compliancebaseline(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& inertance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& nextinertance(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData& inertancebaseline(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerTimeData& flow(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerTimeData& nextflow(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerTimeData& flowsource(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerTimeData& nextflowsource(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarVolumePerTimeData& flowsourcebaseline(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& pressuresource(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& nextpressuresource(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& pressuresourcebaseline(const FluidCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPressureData& valvebreakdownpressure(const FluidCircuitPathData* msg);
};

const ::pulse::cdm::bind::CircuitPathData&
FluidCircuitPathData::_Internal::circuitpath(const FluidCircuitPathData* msg) {
  return *msg->circuitpath_;
}
const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&
FluidCircuitPathData::_Internal::resistance(const FluidCircuitPathData* msg) {
  return *msg->resistance_;
}
const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&
FluidCircuitPathData::_Internal::nextresistance(const FluidCircuitPathData* msg) {
  return *msg->nextresistance_;
}
const ::pulse::cdm::bind::ScalarPressureTimePerVolumeData&
FluidCircuitPathData::_Internal::resistancebaseline(const FluidCircuitPathData* msg) {
  return *msg->resistancebaseline_;
}
const ::pulse::cdm::bind::ScalarVolumePerPressureData&
FluidCircuitPathData::_Internal::compliance(const FluidCircuitPathData* msg) {
  return *msg->compliance_;
}
const ::pulse::cdm::bind::ScalarVolumePerPressureData&
FluidCircuitPathData::_Internal::nextcompliance(const FluidCircuitPathData* msg) {
  return *msg->nextcompliance_;
}
const ::pulse::cdm::bind::ScalarVolumePerPressureData&
FluidCircuitPathData::_Internal::compliancebaseline(const FluidCircuitPathData* msg) {
  return *msg->compliancebaseline_;
}
const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&
FluidCircuitPathData::_Internal::inertance(const FluidCircuitPathData* msg) {
  return *msg->inertance_;
}
const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&
FluidCircuitPathData::_Internal::nextinertance(const FluidCircuitPathData* msg) {
  return *msg->nextinertance_;
}
const ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData&
FluidCircuitPathData::_Internal::inertancebaseline(const FluidCircuitPathData* msg) {
  return *msg->inertancebaseline_;
}
const ::pulse::cdm::bind::ScalarVolumePerTimeData&
FluidCircuitPathData::_Internal::flow(const FluidCircuitPathData* msg) {
  return *msg->flow_;
}
const ::pulse::cdm::bind::ScalarVolumePerTimeData&
FluidCircuitPathData::_Internal::nextflow(const FluidCircuitPathData* msg) {
  return *msg->nextflow_;
}
const ::pulse::cdm::bind::ScalarVolumePerTimeData&
FluidCircuitPathData::_Internal::flowsource(const FluidCircuitPathData* msg) {
  return *msg->flowsource_;
}
const ::pulse::cdm::bind::ScalarVolumePerTimeData&
FluidCircuitPathData::_Internal::nextflowsource(const FluidCircuitPathData* msg) {
  return *msg->nextflowsource_;
}
const ::pulse::cdm::bind::ScalarVolumePerTimeData&
FluidCircuitPathData::_Internal::flowsourcebaseline(const FluidCircuitPathData* msg) {
  return *msg->flowsourcebaseline_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitPathData::_Internal::pressuresource(const FluidCircuitPathData* msg) {
  return *msg->pressuresource_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitPathData::_Internal::nextpressuresource(const FluidCircuitPathData* msg) {
  return *msg->nextpressuresource_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitPathData::_Internal::pressuresourcebaseline(const FluidCircuitPathData* msg) {
  return *msg->pressuresourcebaseline_;
}
const ::pulse::cdm::bind::ScalarPressureData&
FluidCircuitPathData::_Internal::valvebreakdownpressure(const FluidCircuitPathData* msg) {
  return *msg->valvebreakdownpressure_;
}
void FluidCircuitPathData::clear_resistance() {
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
}
void FluidCircuitPathData::clear_nextresistance() {
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
}
void FluidCircuitPathData::clear_resistancebaseline() {
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
}
void FluidCircuitPathData::clear_compliance() {
  if (GetArenaNoVirtual() == nullptr && compliance_ != nullptr) {
    delete compliance_;
  }
  compliance_ = nullptr;
}
void FluidCircuitPathData::clear_nextcompliance() {
  if (GetArenaNoVirtual() == nullptr && nextcompliance_ != nullptr) {
    delete nextcompliance_;
  }
  nextcompliance_ = nullptr;
}
void FluidCircuitPathData::clear_compliancebaseline() {
  if (GetArenaNoVirtual() == nullptr && compliancebaseline_ != nullptr) {
    delete compliancebaseline_;
  }
  compliancebaseline_ = nullptr;
}
void FluidCircuitPathData::clear_inertance() {
  if (GetArenaNoVirtual() == nullptr && inertance_ != nullptr) {
    delete inertance_;
  }
  inertance_ = nullptr;
}
void FluidCircuitPathData::clear_nextinertance() {
  if (GetArenaNoVirtual() == nullptr && nextinertance_ != nullptr) {
    delete nextinertance_;
  }
  nextinertance_ = nullptr;
}
void FluidCircuitPathData::clear_inertancebaseline() {
  if (GetArenaNoVirtual() == nullptr && inertancebaseline_ != nullptr) {
    delete inertancebaseline_;
  }
  inertancebaseline_ = nullptr;
}
void FluidCircuitPathData::clear_flow() {
  if (GetArenaNoVirtual() == nullptr && flow_ != nullptr) {
    delete flow_;
  }
  flow_ = nullptr;
}
void FluidCircuitPathData::clear_nextflow() {
  if (GetArenaNoVirtual() == nullptr && nextflow_ != nullptr) {
    delete nextflow_;
  }
  nextflow_ = nullptr;
}
void FluidCircuitPathData::clear_flowsource() {
  if (GetArenaNoVirtual() == nullptr && flowsource_ != nullptr) {
    delete flowsource_;
  }
  flowsource_ = nullptr;
}
void FluidCircuitPathData::clear_nextflowsource() {
  if (GetArenaNoVirtual() == nullptr && nextflowsource_ != nullptr) {
    delete nextflowsource_;
  }
  nextflowsource_ = nullptr;
}
void FluidCircuitPathData::clear_flowsourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && flowsourcebaseline_ != nullptr) {
    delete flowsourcebaseline_;
  }
  flowsourcebaseline_ = nullptr;
}
void FluidCircuitPathData::clear_pressuresource() {
  if (GetArenaNoVirtual() == nullptr && pressuresource_ != nullptr) {
    delete pressuresource_;
  }
  pressuresource_ = nullptr;
}
void FluidCircuitPathData::clear_nextpressuresource() {
  if (GetArenaNoVirtual() == nullptr && nextpressuresource_ != nullptr) {
    delete nextpressuresource_;
  }
  nextpressuresource_ = nullptr;
}
void FluidCircuitPathData::clear_pressuresourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && pressuresourcebaseline_ != nullptr) {
    delete pressuresourcebaseline_;
  }
  pressuresourcebaseline_ = nullptr;
}
void FluidCircuitPathData::clear_valvebreakdownpressure() {
  if (GetArenaNoVirtual() == nullptr && valvebreakdownpressure_ != nullptr) {
    delete valvebreakdownpressure_;
  }
  valvebreakdownpressure_ = nullptr;
}
FluidCircuitPathData::FluidCircuitPathData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.FluidCircuitPathData)
}
FluidCircuitPathData::FluidCircuitPathData(const FluidCircuitPathData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitpath()) {
    circuitpath_ = new ::pulse::cdm::bind::CircuitPathData(*from.circuitpath_);
  } else {
    circuitpath_ = nullptr;
  }
  if (from._internal_has_resistance()) {
    resistance_ = new ::pulse::cdm::bind::ScalarPressureTimePerVolumeData(*from.resistance_);
  } else {
    resistance_ = nullptr;
  }
  if (from._internal_has_nextresistance()) {
    nextresistance_ = new ::pulse::cdm::bind::ScalarPressureTimePerVolumeData(*from.nextresistance_);
  } else {
    nextresistance_ = nullptr;
  }
  if (from._internal_has_resistancebaseline()) {
    resistancebaseline_ = new ::pulse::cdm::bind::ScalarPressureTimePerVolumeData(*from.resistancebaseline_);
  } else {
    resistancebaseline_ = nullptr;
  }
  if (from._internal_has_compliance()) {
    compliance_ = new ::pulse::cdm::bind::ScalarVolumePerPressureData(*from.compliance_);
  } else {
    compliance_ = nullptr;
  }
  if (from._internal_has_nextcompliance()) {
    nextcompliance_ = new ::pulse::cdm::bind::ScalarVolumePerPressureData(*from.nextcompliance_);
  } else {
    nextcompliance_ = nullptr;
  }
  if (from._internal_has_compliancebaseline()) {
    compliancebaseline_ = new ::pulse::cdm::bind::ScalarVolumePerPressureData(*from.compliancebaseline_);
  } else {
    compliancebaseline_ = nullptr;
  }
  if (from._internal_has_inertance()) {
    inertance_ = new ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData(*from.inertance_);
  } else {
    inertance_ = nullptr;
  }
  if (from._internal_has_nextinertance()) {
    nextinertance_ = new ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData(*from.nextinertance_);
  } else {
    nextinertance_ = nullptr;
  }
  if (from._internal_has_inertancebaseline()) {
    inertancebaseline_ = new ::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData(*from.inertancebaseline_);
  } else {
    inertancebaseline_ = nullptr;
  }
  if (from._internal_has_flow()) {
    flow_ = new ::pulse::cdm::bind::ScalarVolumePerTimeData(*from.flow_);
  } else {
    flow_ = nullptr;
  }
  if (from._internal_has_nextflow()) {
    nextflow_ = new ::pulse::cdm::bind::ScalarVolumePerTimeData(*from.nextflow_);
  } else {
    nextflow_ = nullptr;
  }
  if (from._internal_has_flowsource()) {
    flowsource_ = new ::pulse::cdm::bind::ScalarVolumePerTimeData(*from.flowsource_);
  } else {
    flowsource_ = nullptr;
  }
  if (from._internal_has_nextflowsource()) {
    nextflowsource_ = new ::pulse::cdm::bind::ScalarVolumePerTimeData(*from.nextflowsource_);
  } else {
    nextflowsource_ = nullptr;
  }
  if (from._internal_has_flowsourcebaseline()) {
    flowsourcebaseline_ = new ::pulse::cdm::bind::ScalarVolumePerTimeData(*from.flowsourcebaseline_);
  } else {
    flowsourcebaseline_ = nullptr;
  }
  if (from._internal_has_pressuresource()) {
    pressuresource_ = new ::pulse::cdm::bind::ScalarPressureData(*from.pressuresource_);
  } else {
    pressuresource_ = nullptr;
  }
  if (from._internal_has_nextpressuresource()) {
    nextpressuresource_ = new ::pulse::cdm::bind::ScalarPressureData(*from.nextpressuresource_);
  } else {
    nextpressuresource_ = nullptr;
  }
  if (from._internal_has_pressuresourcebaseline()) {
    pressuresourcebaseline_ = new ::pulse::cdm::bind::ScalarPressureData(*from.pressuresourcebaseline_);
  } else {
    pressuresourcebaseline_ = nullptr;
  }
  if (from._internal_has_valvebreakdownpressure()) {
    valvebreakdownpressure_ = new ::pulse::cdm::bind::ScalarPressureData(*from.valvebreakdownpressure_);
  } else {
    valvebreakdownpressure_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.FluidCircuitPathData)
}

void FluidCircuitPathData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitpath_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valvebreakdownpressure_) -
      reinterpret_cast<char*>(&circuitpath_)) + sizeof(valvebreakdownpressure_));
}

FluidCircuitPathData::~FluidCircuitPathData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.FluidCircuitPathData)
  SharedDtor();
}

void FluidCircuitPathData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitpath_;
  if (this != internal_default_instance()) delete resistance_;
  if (this != internal_default_instance()) delete nextresistance_;
  if (this != internal_default_instance()) delete resistancebaseline_;
  if (this != internal_default_instance()) delete compliance_;
  if (this != internal_default_instance()) delete nextcompliance_;
  if (this != internal_default_instance()) delete compliancebaseline_;
  if (this != internal_default_instance()) delete inertance_;
  if (this != internal_default_instance()) delete nextinertance_;
  if (this != internal_default_instance()) delete inertancebaseline_;
  if (this != internal_default_instance()) delete flow_;
  if (this != internal_default_instance()) delete nextflow_;
  if (this != internal_default_instance()) delete flowsource_;
  if (this != internal_default_instance()) delete nextflowsource_;
  if (this != internal_default_instance()) delete flowsourcebaseline_;
  if (this != internal_default_instance()) delete pressuresource_;
  if (this != internal_default_instance()) delete nextpressuresource_;
  if (this != internal_default_instance()) delete pressuresourcebaseline_;
  if (this != internal_default_instance()) delete valvebreakdownpressure_;
}

void FluidCircuitPathData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FluidCircuitPathData& FluidCircuitPathData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FluidCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void FluidCircuitPathData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.FluidCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && compliance_ != nullptr) {
    delete compliance_;
  }
  compliance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcompliance_ != nullptr) {
    delete nextcompliance_;
  }
  nextcompliance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && compliancebaseline_ != nullptr) {
    delete compliancebaseline_;
  }
  compliancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inertance_ != nullptr) {
    delete inertance_;
  }
  inertance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextinertance_ != nullptr) {
    delete nextinertance_;
  }
  nextinertance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inertancebaseline_ != nullptr) {
    delete inertancebaseline_;
  }
  inertancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && flow_ != nullptr) {
    delete flow_;
  }
  flow_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextflow_ != nullptr) {
    delete nextflow_;
  }
  nextflow_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && flowsource_ != nullptr) {
    delete flowsource_;
  }
  flowsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextflowsource_ != nullptr) {
    delete nextflowsource_;
  }
  nextflowsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && flowsourcebaseline_ != nullptr) {
    delete flowsourcebaseline_;
  }
  flowsourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && pressuresource_ != nullptr) {
    delete pressuresource_;
  }
  pressuresource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextpressuresource_ != nullptr) {
    delete nextpressuresource_;
  }
  nextpressuresource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && pressuresourcebaseline_ != nullptr) {
    delete pressuresourcebaseline_;
  }
  pressuresourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && valvebreakdownpressure_ != nullptr) {
    delete valvebreakdownpressure_;
  }
  valvebreakdownpressure_ = nullptr;
  _internal_metadata_.Clear();
}

const char* FluidCircuitPathData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitpath(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimePerVolumeData Resistance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimePerVolumeData NextResistance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextresistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ResistanceBaseline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerPressureData Compliance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_compliance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerPressureData NextCompliance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcompliance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerPressureData ComplianceBaseline = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_compliancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData Inertance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_inertance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData NextInertance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextinertance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData InertanceBaseline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_inertancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerTimeData Flow = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_flow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlow = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextflow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSource = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_flowsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlowSource = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextflowsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSourceBaseline = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_flowsourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData PressureSource = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_pressuresource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData NextPressureSource = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextpressuresource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData PressureSourceBaseline = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_pressuresourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPressureData ValveBreakdownPressure = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_valvebreakdownpressure(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FluidCircuitPathData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.FluidCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitpath(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData Resistance = 2;
  if (this->has_resistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::resistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData NextResistance = 3;
  if (this->has_nextresistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nextresistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::resistancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData Compliance = 5;
  if (this->has_compliance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::compliance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData NextCompliance = 6;
  if (this->has_nextcompliance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::nextcompliance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData ComplianceBaseline = 7;
  if (this->has_compliancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::compliancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData Inertance = 8;
  if (this->has_inertance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::inertance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData NextInertance = 9;
  if (this->has_nextinertance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::nextinertance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData InertanceBaseline = 10;
  if (this->has_inertancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, _Internal::inertancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData Flow = 11;
  if (this->has_flow()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, _Internal::flow(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlow = 12;
  if (this->has_nextflow()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, _Internal::nextflow(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSource = 13;
  if (this->has_flowsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, _Internal::flowsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlowSource = 14;
  if (this->has_nextflowsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, _Internal::nextflowsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSourceBaseline = 15;
  if (this->has_flowsourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        15, _Internal::flowsourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData PressureSource = 16;
  if (this->has_pressuresource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, _Internal::pressuresource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData NextPressureSource = 17;
  if (this->has_nextpressuresource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        17, _Internal::nextpressuresource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData PressureSourceBaseline = 18;
  if (this->has_pressuresourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, _Internal::pressuresourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPressureData ValveBreakdownPressure = 19;
  if (this->has_valvebreakdownpressure()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        19, _Internal::valvebreakdownpressure(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.FluidCircuitPathData)
  return target;
}

size_t FluidCircuitPathData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.FluidCircuitPathData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitpath_);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData Resistance = 2;
  if (this->has_resistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistance_);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData NextResistance = 3;
  if (this->has_nextresistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextresistance_);
  }

  // .pulse.cdm.bind.ScalarPressureTimePerVolumeData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistancebaseline_);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData Compliance = 5;
  if (this->has_compliance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *compliance_);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData NextCompliance = 6;
  if (this->has_nextcompliance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcompliance_);
  }

  // .pulse.cdm.bind.ScalarVolumePerPressureData ComplianceBaseline = 7;
  if (this->has_compliancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *compliancebaseline_);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData Inertance = 8;
  if (this->has_inertance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inertance_);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData NextInertance = 9;
  if (this->has_nextinertance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextinertance_);
  }

  // .pulse.cdm.bind.ScalarPressureTimeSquaredPerVolumeData InertanceBaseline = 10;
  if (this->has_inertancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inertancebaseline_);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData Flow = 11;
  if (this->has_flow()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *flow_);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlow = 12;
  if (this->has_nextflow()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextflow_);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSource = 13;
  if (this->has_flowsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *flowsource_);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData NextFlowSource = 14;
  if (this->has_nextflowsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextflowsource_);
  }

  // .pulse.cdm.bind.ScalarVolumePerTimeData FlowSourceBaseline = 15;
  if (this->has_flowsourcebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *flowsourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarPressureData PressureSource = 16;
  if (this->has_pressuresource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pressuresource_);
  }

  // .pulse.cdm.bind.ScalarPressureData NextPressureSource = 17;
  if (this->has_nextpressuresource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextpressuresource_);
  }

  // .pulse.cdm.bind.ScalarPressureData PressureSourceBaseline = 18;
  if (this->has_pressuresourcebaseline()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *pressuresourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarPressureData ValveBreakdownPressure = 19;
  if (this->has_valvebreakdownpressure()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *valvebreakdownpressure_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FluidCircuitPathData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.FluidCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  const FluidCircuitPathData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FluidCircuitPathData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.FluidCircuitPathData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.FluidCircuitPathData)
    MergeFrom(*source);
  }
}

void FluidCircuitPathData::MergeFrom(const FluidCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.FluidCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitpath()) {
    _internal_mutable_circuitpath()->::pulse::cdm::bind::CircuitPathData::MergeFrom(from._internal_circuitpath());
  }
  if (from.has_resistance()) {
    _internal_mutable_resistance()->::pulse::cdm::bind::ScalarPressureTimePerVolumeData::MergeFrom(from._internal_resistance());
  }
  if (from.has_nextresistance()) {
    _internal_mutable_nextresistance()->::pulse::cdm::bind::ScalarPressureTimePerVolumeData::MergeFrom(from._internal_nextresistance());
  }
  if (from.has_resistancebaseline()) {
    _internal_mutable_resistancebaseline()->::pulse::cdm::bind::ScalarPressureTimePerVolumeData::MergeFrom(from._internal_resistancebaseline());
  }
  if (from.has_compliance()) {
    _internal_mutable_compliance()->::pulse::cdm::bind::ScalarVolumePerPressureData::MergeFrom(from._internal_compliance());
  }
  if (from.has_nextcompliance()) {
    _internal_mutable_nextcompliance()->::pulse::cdm::bind::ScalarVolumePerPressureData::MergeFrom(from._internal_nextcompliance());
  }
  if (from.has_compliancebaseline()) {
    _internal_mutable_compliancebaseline()->::pulse::cdm::bind::ScalarVolumePerPressureData::MergeFrom(from._internal_compliancebaseline());
  }
  if (from.has_inertance()) {
    _internal_mutable_inertance()->::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::MergeFrom(from._internal_inertance());
  }
  if (from.has_nextinertance()) {
    _internal_mutable_nextinertance()->::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::MergeFrom(from._internal_nextinertance());
  }
  if (from.has_inertancebaseline()) {
    _internal_mutable_inertancebaseline()->::pulse::cdm::bind::ScalarPressureTimeSquaredPerVolumeData::MergeFrom(from._internal_inertancebaseline());
  }
  if (from.has_flow()) {
    _internal_mutable_flow()->::pulse::cdm::bind::ScalarVolumePerTimeData::MergeFrom(from._internal_flow());
  }
  if (from.has_nextflow()) {
    _internal_mutable_nextflow()->::pulse::cdm::bind::ScalarVolumePerTimeData::MergeFrom(from._internal_nextflow());
  }
  if (from.has_flowsource()) {
    _internal_mutable_flowsource()->::pulse::cdm::bind::ScalarVolumePerTimeData::MergeFrom(from._internal_flowsource());
  }
  if (from.has_nextflowsource()) {
    _internal_mutable_nextflowsource()->::pulse::cdm::bind::ScalarVolumePerTimeData::MergeFrom(from._internal_nextflowsource());
  }
  if (from.has_flowsourcebaseline()) {
    _internal_mutable_flowsourcebaseline()->::pulse::cdm::bind::ScalarVolumePerTimeData::MergeFrom(from._internal_flowsourcebaseline());
  }
  if (from.has_pressuresource()) {
    _internal_mutable_pressuresource()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_pressuresource());
  }
  if (from.has_nextpressuresource()) {
    _internal_mutable_nextpressuresource()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_nextpressuresource());
  }
  if (from.has_pressuresourcebaseline()) {
    _internal_mutable_pressuresourcebaseline()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_pressuresourcebaseline());
  }
  if (from.has_valvebreakdownpressure()) {
    _internal_mutable_valvebreakdownpressure()->::pulse::cdm::bind::ScalarPressureData::MergeFrom(from._internal_valvebreakdownpressure());
  }
}

void FluidCircuitPathData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.FluidCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FluidCircuitPathData::CopyFrom(const FluidCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.FluidCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FluidCircuitPathData::IsInitialized() const {
  return true;
}

void FluidCircuitPathData::InternalSwap(FluidCircuitPathData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitpath_, other->circuitpath_);
  swap(resistance_, other->resistance_);
  swap(nextresistance_, other->nextresistance_);
  swap(resistancebaseline_, other->resistancebaseline_);
  swap(compliance_, other->compliance_);
  swap(nextcompliance_, other->nextcompliance_);
  swap(compliancebaseline_, other->compliancebaseline_);
  swap(inertance_, other->inertance_);
  swap(nextinertance_, other->nextinertance_);
  swap(inertancebaseline_, other->inertancebaseline_);
  swap(flow_, other->flow_);
  swap(nextflow_, other->nextflow_);
  swap(flowsource_, other->flowsource_);
  swap(nextflowsource_, other->nextflowsource_);
  swap(flowsourcebaseline_, other->flowsourcebaseline_);
  swap(pressuresource_, other->pressuresource_);
  swap(nextpressuresource_, other->nextpressuresource_);
  swap(pressuresourcebaseline_, other->pressuresourcebaseline_);
  swap(valvebreakdownpressure_, other->valvebreakdownpressure_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FluidCircuitPathData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ThermalCircuitData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ThermalCircuitData_default_instance_._instance.get_mutable()->circuit_ = const_cast< ::pulse::cdm::bind::CircuitData*>(
      ::pulse::cdm::bind::CircuitData::internal_default_instance());
}
class ThermalCircuitData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitData& circuit(const ThermalCircuitData* msg);
};

const ::pulse::cdm::bind::CircuitData&
ThermalCircuitData::_Internal::circuit(const ThermalCircuitData* msg) {
  return *msg->circuit_;
}
ThermalCircuitData::ThermalCircuitData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ThermalCircuitData)
}
ThermalCircuitData::ThermalCircuitData(const ThermalCircuitData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuit()) {
    circuit_ = new ::pulse::cdm::bind::CircuitData(*from.circuit_);
  } else {
    circuit_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ThermalCircuitData)
}

void ThermalCircuitData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  circuit_ = nullptr;
}

ThermalCircuitData::~ThermalCircuitData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ThermalCircuitData)
  SharedDtor();
}

void ThermalCircuitData::SharedDtor() {
  if (this != internal_default_instance()) delete circuit_;
}

void ThermalCircuitData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThermalCircuitData& ThermalCircuitData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThermalCircuitData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ThermalCircuitData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ThermalCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuit_ != nullptr) {
    delete circuit_;
  }
  circuit_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ThermalCircuitData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitData Circuit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuit(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThermalCircuitData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ThermalCircuitData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuit(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ThermalCircuitData)
  return target;
}

size_t ThermalCircuitData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ThermalCircuitData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitData Circuit = 1;
  if (this->has_circuit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuit_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThermalCircuitData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ThermalCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  const ThermalCircuitData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ThermalCircuitData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ThermalCircuitData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ThermalCircuitData)
    MergeFrom(*source);
  }
}

void ThermalCircuitData::MergeFrom(const ThermalCircuitData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ThermalCircuitData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuit()) {
    _internal_mutable_circuit()->::pulse::cdm::bind::CircuitData::MergeFrom(from._internal_circuit());
  }
}

void ThermalCircuitData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ThermalCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThermalCircuitData::CopyFrom(const ThermalCircuitData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ThermalCircuitData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalCircuitData::IsInitialized() const {
  return true;
}

void ThermalCircuitData::InternalSwap(ThermalCircuitData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuit_, other->circuit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThermalCircuitData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ThermalCircuitNodeData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->circuitnode_ = const_cast< ::pulse::cdm::bind::CircuitNodeData*>(
      ::pulse::cdm::bind::CircuitNodeData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->temperature_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->nexttemperature_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->heat_ = const_cast< ::pulse::cdm::bind::ScalarEnergyData*>(
      ::pulse::cdm::bind::ScalarEnergyData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->nextheat_ = const_cast< ::pulse::cdm::bind::ScalarEnergyData*>(
      ::pulse::cdm::bind::ScalarEnergyData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitNodeData_default_instance_._instance.get_mutable()->heatbaseline_ = const_cast< ::pulse::cdm::bind::ScalarEnergyData*>(
      ::pulse::cdm::bind::ScalarEnergyData::internal_default_instance());
}
class ThermalCircuitNodeData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitNodeData& circuitnode(const ThermalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& temperature(const ThermalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& nexttemperature(const ThermalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarEnergyData& heat(const ThermalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarEnergyData& nextheat(const ThermalCircuitNodeData* msg);
  static const ::pulse::cdm::bind::ScalarEnergyData& heatbaseline(const ThermalCircuitNodeData* msg);
};

const ::pulse::cdm::bind::CircuitNodeData&
ThermalCircuitNodeData::_Internal::circuitnode(const ThermalCircuitNodeData* msg) {
  return *msg->circuitnode_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitNodeData::_Internal::temperature(const ThermalCircuitNodeData* msg) {
  return *msg->temperature_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitNodeData::_Internal::nexttemperature(const ThermalCircuitNodeData* msg) {
  return *msg->nexttemperature_;
}
const ::pulse::cdm::bind::ScalarEnergyData&
ThermalCircuitNodeData::_Internal::heat(const ThermalCircuitNodeData* msg) {
  return *msg->heat_;
}
const ::pulse::cdm::bind::ScalarEnergyData&
ThermalCircuitNodeData::_Internal::nextheat(const ThermalCircuitNodeData* msg) {
  return *msg->nextheat_;
}
const ::pulse::cdm::bind::ScalarEnergyData&
ThermalCircuitNodeData::_Internal::heatbaseline(const ThermalCircuitNodeData* msg) {
  return *msg->heatbaseline_;
}
void ThermalCircuitNodeData::clear_temperature() {
  if (GetArenaNoVirtual() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
}
void ThermalCircuitNodeData::clear_nexttemperature() {
  if (GetArenaNoVirtual() == nullptr && nexttemperature_ != nullptr) {
    delete nexttemperature_;
  }
  nexttemperature_ = nullptr;
}
void ThermalCircuitNodeData::clear_heat() {
  if (GetArenaNoVirtual() == nullptr && heat_ != nullptr) {
    delete heat_;
  }
  heat_ = nullptr;
}
void ThermalCircuitNodeData::clear_nextheat() {
  if (GetArenaNoVirtual() == nullptr && nextheat_ != nullptr) {
    delete nextheat_;
  }
  nextheat_ = nullptr;
}
void ThermalCircuitNodeData::clear_heatbaseline() {
  if (GetArenaNoVirtual() == nullptr && heatbaseline_ != nullptr) {
    delete heatbaseline_;
  }
  heatbaseline_ = nullptr;
}
ThermalCircuitNodeData::ThermalCircuitNodeData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ThermalCircuitNodeData)
}
ThermalCircuitNodeData::ThermalCircuitNodeData(const ThermalCircuitNodeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitnode()) {
    circuitnode_ = new ::pulse::cdm::bind::CircuitNodeData(*from.circuitnode_);
  } else {
    circuitnode_ = nullptr;
  }
  if (from._internal_has_temperature()) {
    temperature_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.temperature_);
  } else {
    temperature_ = nullptr;
  }
  if (from._internal_has_nexttemperature()) {
    nexttemperature_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.nexttemperature_);
  } else {
    nexttemperature_ = nullptr;
  }
  if (from._internal_has_heat()) {
    heat_ = new ::pulse::cdm::bind::ScalarEnergyData(*from.heat_);
  } else {
    heat_ = nullptr;
  }
  if (from._internal_has_nextheat()) {
    nextheat_ = new ::pulse::cdm::bind::ScalarEnergyData(*from.nextheat_);
  } else {
    nextheat_ = nullptr;
  }
  if (from._internal_has_heatbaseline()) {
    heatbaseline_ = new ::pulse::cdm::bind::ScalarEnergyData(*from.heatbaseline_);
  } else {
    heatbaseline_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ThermalCircuitNodeData)
}

void ThermalCircuitNodeData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitnode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&heatbaseline_) -
      reinterpret_cast<char*>(&circuitnode_)) + sizeof(heatbaseline_));
}

ThermalCircuitNodeData::~ThermalCircuitNodeData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ThermalCircuitNodeData)
  SharedDtor();
}

void ThermalCircuitNodeData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitnode_;
  if (this != internal_default_instance()) delete temperature_;
  if (this != internal_default_instance()) delete nexttemperature_;
  if (this != internal_default_instance()) delete heat_;
  if (this != internal_default_instance()) delete nextheat_;
  if (this != internal_default_instance()) delete heatbaseline_;
}

void ThermalCircuitNodeData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThermalCircuitNodeData& ThermalCircuitNodeData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThermalCircuitNodeData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ThermalCircuitNodeData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ThermalCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitnode_ != nullptr) {
    delete circuitnode_;
  }
  circuitnode_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nexttemperature_ != nullptr) {
    delete nexttemperature_;
  }
  nexttemperature_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && heat_ != nullptr) {
    delete heat_;
  }
  heat_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextheat_ != nullptr) {
    delete nextheat_;
  }
  nextheat_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && heatbaseline_ != nullptr) {
    delete heatbaseline_;
  }
  heatbaseline_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ThermalCircuitNodeData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitnode(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData Temperature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_temperature(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData NextTemperature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nexttemperature(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarEnergyData Heat = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_heat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarEnergyData NextHeat = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextheat(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarEnergyData HeatBaseline = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_heatbaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThermalCircuitNodeData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ThermalCircuitNodeData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitnode(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData Temperature = 2;
  if (this->has_temperature()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::temperature(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperature = 3;
  if (this->has_nexttemperature()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nexttemperature(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarEnergyData Heat = 4;
  if (this->has_heat()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::heat(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarEnergyData NextHeat = 5;
  if (this->has_nextheat()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::nextheat(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarEnergyData HeatBaseline = 6;
  if (this->has_heatbaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::heatbaseline(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ThermalCircuitNodeData)
  return target;
}

size_t ThermalCircuitNodeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ThermalCircuitNodeData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitNodeData CircuitNode = 1;
  if (this->has_circuitnode()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitnode_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData Temperature = 2;
  if (this->has_temperature()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *temperature_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperature = 3;
  if (this->has_nexttemperature()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nexttemperature_);
  }

  // .pulse.cdm.bind.ScalarEnergyData Heat = 4;
  if (this->has_heat()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heat_);
  }

  // .pulse.cdm.bind.ScalarEnergyData NextHeat = 5;
  if (this->has_nextheat()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextheat_);
  }

  // .pulse.cdm.bind.ScalarEnergyData HeatBaseline = 6;
  if (this->has_heatbaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heatbaseline_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThermalCircuitNodeData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ThermalCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  const ThermalCircuitNodeData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ThermalCircuitNodeData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ThermalCircuitNodeData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ThermalCircuitNodeData)
    MergeFrom(*source);
  }
}

void ThermalCircuitNodeData::MergeFrom(const ThermalCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ThermalCircuitNodeData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitnode()) {
    _internal_mutable_circuitnode()->::pulse::cdm::bind::CircuitNodeData::MergeFrom(from._internal_circuitnode());
  }
  if (from.has_temperature()) {
    _internal_mutable_temperature()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_temperature());
  }
  if (from.has_nexttemperature()) {
    _internal_mutable_nexttemperature()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_nexttemperature());
  }
  if (from.has_heat()) {
    _internal_mutable_heat()->::pulse::cdm::bind::ScalarEnergyData::MergeFrom(from._internal_heat());
  }
  if (from.has_nextheat()) {
    _internal_mutable_nextheat()->::pulse::cdm::bind::ScalarEnergyData::MergeFrom(from._internal_nextheat());
  }
  if (from.has_heatbaseline()) {
    _internal_mutable_heatbaseline()->::pulse::cdm::bind::ScalarEnergyData::MergeFrom(from._internal_heatbaseline());
  }
}

void ThermalCircuitNodeData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ThermalCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThermalCircuitNodeData::CopyFrom(const ThermalCircuitNodeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ThermalCircuitNodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalCircuitNodeData::IsInitialized() const {
  return true;
}

void ThermalCircuitNodeData::InternalSwap(ThermalCircuitNodeData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitnode_, other->circuitnode_);
  swap(temperature_, other->temperature_);
  swap(nexttemperature_, other->nexttemperature_);
  swap(heat_, other->heat_);
  swap(nextheat_, other->nextheat_);
  swap(heatbaseline_, other->heatbaseline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThermalCircuitNodeData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ThermalCircuitPathData::InitAsDefaultInstance() {
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->circuitpath_ = const_cast< ::pulse::cdm::bind::CircuitPathData*>(
      ::pulse::cdm::bind::CircuitPathData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->resistance_ = const_cast< ::pulse::cdm::bind::ScalarHeatResistanceData*>(
      ::pulse::cdm::bind::ScalarHeatResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nextresistance_ = const_cast< ::pulse::cdm::bind::ScalarHeatResistanceData*>(
      ::pulse::cdm::bind::ScalarHeatResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->resistancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarHeatResistanceData*>(
      ::pulse::cdm::bind::ScalarHeatResistanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->capacitance_ = const_cast< ::pulse::cdm::bind::ScalarHeatCapacitanceData*>(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nextcapacitance_ = const_cast< ::pulse::cdm::bind::ScalarHeatCapacitanceData*>(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->capacitancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarHeatCapacitanceData*>(
      ::pulse::cdm::bind::ScalarHeatCapacitanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->inductance_ = const_cast< ::pulse::cdm::bind::ScalarHeatInductanceData*>(
      ::pulse::cdm::bind::ScalarHeatInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nextinductance_ = const_cast< ::pulse::cdm::bind::ScalarHeatInductanceData*>(
      ::pulse::cdm::bind::ScalarHeatInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->inductancebaseline_ = const_cast< ::pulse::cdm::bind::ScalarHeatInductanceData*>(
      ::pulse::cdm::bind::ScalarHeatInductanceData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->heattransferrate_ = const_cast< ::pulse::cdm::bind::ScalarPowerData*>(
      ::pulse::cdm::bind::ScalarPowerData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nextheattransferrate_ = const_cast< ::pulse::cdm::bind::ScalarPowerData*>(
      ::pulse::cdm::bind::ScalarPowerData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->heatsource_ = const_cast< ::pulse::cdm::bind::ScalarPowerData*>(
      ::pulse::cdm::bind::ScalarPowerData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nextheatsource_ = const_cast< ::pulse::cdm::bind::ScalarPowerData*>(
      ::pulse::cdm::bind::ScalarPowerData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->heatsourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarPowerData*>(
      ::pulse::cdm::bind::ScalarPowerData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->temperaturesource_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->nexttemperaturesource_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->temperaturesourcebaseline_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
  ::pulse::cdm::bind::_ThermalCircuitPathData_default_instance_._instance.get_mutable()->valvebreakdowntemperature_ = const_cast< ::pulse::cdm::bind::ScalarTemperatureData*>(
      ::pulse::cdm::bind::ScalarTemperatureData::internal_default_instance());
}
class ThermalCircuitPathData::_Internal {
 public:
  static const ::pulse::cdm::bind::CircuitPathData& circuitpath(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatResistanceData& resistance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatResistanceData& nextresistance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatResistanceData& resistancebaseline(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatCapacitanceData& capacitance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatCapacitanceData& nextcapacitance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatCapacitanceData& capacitancebaseline(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatInductanceData& inductance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatInductanceData& nextinductance(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarHeatInductanceData& inductancebaseline(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPowerData& heattransferrate(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPowerData& nextheattransferrate(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPowerData& heatsource(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPowerData& nextheatsource(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarPowerData& heatsourcebaseline(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& temperaturesource(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& nexttemperaturesource(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& temperaturesourcebaseline(const ThermalCircuitPathData* msg);
  static const ::pulse::cdm::bind::ScalarTemperatureData& valvebreakdowntemperature(const ThermalCircuitPathData* msg);
};

const ::pulse::cdm::bind::CircuitPathData&
ThermalCircuitPathData::_Internal::circuitpath(const ThermalCircuitPathData* msg) {
  return *msg->circuitpath_;
}
const ::pulse::cdm::bind::ScalarHeatResistanceData&
ThermalCircuitPathData::_Internal::resistance(const ThermalCircuitPathData* msg) {
  return *msg->resistance_;
}
const ::pulse::cdm::bind::ScalarHeatResistanceData&
ThermalCircuitPathData::_Internal::nextresistance(const ThermalCircuitPathData* msg) {
  return *msg->nextresistance_;
}
const ::pulse::cdm::bind::ScalarHeatResistanceData&
ThermalCircuitPathData::_Internal::resistancebaseline(const ThermalCircuitPathData* msg) {
  return *msg->resistancebaseline_;
}
const ::pulse::cdm::bind::ScalarHeatCapacitanceData&
ThermalCircuitPathData::_Internal::capacitance(const ThermalCircuitPathData* msg) {
  return *msg->capacitance_;
}
const ::pulse::cdm::bind::ScalarHeatCapacitanceData&
ThermalCircuitPathData::_Internal::nextcapacitance(const ThermalCircuitPathData* msg) {
  return *msg->nextcapacitance_;
}
const ::pulse::cdm::bind::ScalarHeatCapacitanceData&
ThermalCircuitPathData::_Internal::capacitancebaseline(const ThermalCircuitPathData* msg) {
  return *msg->capacitancebaseline_;
}
const ::pulse::cdm::bind::ScalarHeatInductanceData&
ThermalCircuitPathData::_Internal::inductance(const ThermalCircuitPathData* msg) {
  return *msg->inductance_;
}
const ::pulse::cdm::bind::ScalarHeatInductanceData&
ThermalCircuitPathData::_Internal::nextinductance(const ThermalCircuitPathData* msg) {
  return *msg->nextinductance_;
}
const ::pulse::cdm::bind::ScalarHeatInductanceData&
ThermalCircuitPathData::_Internal::inductancebaseline(const ThermalCircuitPathData* msg) {
  return *msg->inductancebaseline_;
}
const ::pulse::cdm::bind::ScalarPowerData&
ThermalCircuitPathData::_Internal::heattransferrate(const ThermalCircuitPathData* msg) {
  return *msg->heattransferrate_;
}
const ::pulse::cdm::bind::ScalarPowerData&
ThermalCircuitPathData::_Internal::nextheattransferrate(const ThermalCircuitPathData* msg) {
  return *msg->nextheattransferrate_;
}
const ::pulse::cdm::bind::ScalarPowerData&
ThermalCircuitPathData::_Internal::heatsource(const ThermalCircuitPathData* msg) {
  return *msg->heatsource_;
}
const ::pulse::cdm::bind::ScalarPowerData&
ThermalCircuitPathData::_Internal::nextheatsource(const ThermalCircuitPathData* msg) {
  return *msg->nextheatsource_;
}
const ::pulse::cdm::bind::ScalarPowerData&
ThermalCircuitPathData::_Internal::heatsourcebaseline(const ThermalCircuitPathData* msg) {
  return *msg->heatsourcebaseline_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitPathData::_Internal::temperaturesource(const ThermalCircuitPathData* msg) {
  return *msg->temperaturesource_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitPathData::_Internal::nexttemperaturesource(const ThermalCircuitPathData* msg) {
  return *msg->nexttemperaturesource_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitPathData::_Internal::temperaturesourcebaseline(const ThermalCircuitPathData* msg) {
  return *msg->temperaturesourcebaseline_;
}
const ::pulse::cdm::bind::ScalarTemperatureData&
ThermalCircuitPathData::_Internal::valvebreakdowntemperature(const ThermalCircuitPathData* msg) {
  return *msg->valvebreakdowntemperature_;
}
void ThermalCircuitPathData::clear_resistance() {
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
}
void ThermalCircuitPathData::clear_nextresistance() {
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
}
void ThermalCircuitPathData::clear_resistancebaseline() {
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
}
void ThermalCircuitPathData::clear_capacitance() {
  if (GetArenaNoVirtual() == nullptr && capacitance_ != nullptr) {
    delete capacitance_;
  }
  capacitance_ = nullptr;
}
void ThermalCircuitPathData::clear_nextcapacitance() {
  if (GetArenaNoVirtual() == nullptr && nextcapacitance_ != nullptr) {
    delete nextcapacitance_;
  }
  nextcapacitance_ = nullptr;
}
void ThermalCircuitPathData::clear_capacitancebaseline() {
  if (GetArenaNoVirtual() == nullptr && capacitancebaseline_ != nullptr) {
    delete capacitancebaseline_;
  }
  capacitancebaseline_ = nullptr;
}
void ThermalCircuitPathData::clear_inductance() {
  if (GetArenaNoVirtual() == nullptr && inductance_ != nullptr) {
    delete inductance_;
  }
  inductance_ = nullptr;
}
void ThermalCircuitPathData::clear_nextinductance() {
  if (GetArenaNoVirtual() == nullptr && nextinductance_ != nullptr) {
    delete nextinductance_;
  }
  nextinductance_ = nullptr;
}
void ThermalCircuitPathData::clear_inductancebaseline() {
  if (GetArenaNoVirtual() == nullptr && inductancebaseline_ != nullptr) {
    delete inductancebaseline_;
  }
  inductancebaseline_ = nullptr;
}
void ThermalCircuitPathData::clear_heattransferrate() {
  if (GetArenaNoVirtual() == nullptr && heattransferrate_ != nullptr) {
    delete heattransferrate_;
  }
  heattransferrate_ = nullptr;
}
void ThermalCircuitPathData::clear_nextheattransferrate() {
  if (GetArenaNoVirtual() == nullptr && nextheattransferrate_ != nullptr) {
    delete nextheattransferrate_;
  }
  nextheattransferrate_ = nullptr;
}
void ThermalCircuitPathData::clear_heatsource() {
  if (GetArenaNoVirtual() == nullptr && heatsource_ != nullptr) {
    delete heatsource_;
  }
  heatsource_ = nullptr;
}
void ThermalCircuitPathData::clear_nextheatsource() {
  if (GetArenaNoVirtual() == nullptr && nextheatsource_ != nullptr) {
    delete nextheatsource_;
  }
  nextheatsource_ = nullptr;
}
void ThermalCircuitPathData::clear_heatsourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && heatsourcebaseline_ != nullptr) {
    delete heatsourcebaseline_;
  }
  heatsourcebaseline_ = nullptr;
}
void ThermalCircuitPathData::clear_temperaturesource() {
  if (GetArenaNoVirtual() == nullptr && temperaturesource_ != nullptr) {
    delete temperaturesource_;
  }
  temperaturesource_ = nullptr;
}
void ThermalCircuitPathData::clear_nexttemperaturesource() {
  if (GetArenaNoVirtual() == nullptr && nexttemperaturesource_ != nullptr) {
    delete nexttemperaturesource_;
  }
  nexttemperaturesource_ = nullptr;
}
void ThermalCircuitPathData::clear_temperaturesourcebaseline() {
  if (GetArenaNoVirtual() == nullptr && temperaturesourcebaseline_ != nullptr) {
    delete temperaturesourcebaseline_;
  }
  temperaturesourcebaseline_ = nullptr;
}
void ThermalCircuitPathData::clear_valvebreakdowntemperature() {
  if (GetArenaNoVirtual() == nullptr && valvebreakdowntemperature_ != nullptr) {
    delete valvebreakdowntemperature_;
  }
  valvebreakdowntemperature_ = nullptr;
}
ThermalCircuitPathData::ThermalCircuitPathData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.ThermalCircuitPathData)
}
ThermalCircuitPathData::ThermalCircuitPathData(const ThermalCircuitPathData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_circuitpath()) {
    circuitpath_ = new ::pulse::cdm::bind::CircuitPathData(*from.circuitpath_);
  } else {
    circuitpath_ = nullptr;
  }
  if (from._internal_has_resistance()) {
    resistance_ = new ::pulse::cdm::bind::ScalarHeatResistanceData(*from.resistance_);
  } else {
    resistance_ = nullptr;
  }
  if (from._internal_has_nextresistance()) {
    nextresistance_ = new ::pulse::cdm::bind::ScalarHeatResistanceData(*from.nextresistance_);
  } else {
    nextresistance_ = nullptr;
  }
  if (from._internal_has_resistancebaseline()) {
    resistancebaseline_ = new ::pulse::cdm::bind::ScalarHeatResistanceData(*from.resistancebaseline_);
  } else {
    resistancebaseline_ = nullptr;
  }
  if (from._internal_has_capacitance()) {
    capacitance_ = new ::pulse::cdm::bind::ScalarHeatCapacitanceData(*from.capacitance_);
  } else {
    capacitance_ = nullptr;
  }
  if (from._internal_has_nextcapacitance()) {
    nextcapacitance_ = new ::pulse::cdm::bind::ScalarHeatCapacitanceData(*from.nextcapacitance_);
  } else {
    nextcapacitance_ = nullptr;
  }
  if (from._internal_has_capacitancebaseline()) {
    capacitancebaseline_ = new ::pulse::cdm::bind::ScalarHeatCapacitanceData(*from.capacitancebaseline_);
  } else {
    capacitancebaseline_ = nullptr;
  }
  if (from._internal_has_inductance()) {
    inductance_ = new ::pulse::cdm::bind::ScalarHeatInductanceData(*from.inductance_);
  } else {
    inductance_ = nullptr;
  }
  if (from._internal_has_nextinductance()) {
    nextinductance_ = new ::pulse::cdm::bind::ScalarHeatInductanceData(*from.nextinductance_);
  } else {
    nextinductance_ = nullptr;
  }
  if (from._internal_has_inductancebaseline()) {
    inductancebaseline_ = new ::pulse::cdm::bind::ScalarHeatInductanceData(*from.inductancebaseline_);
  } else {
    inductancebaseline_ = nullptr;
  }
  if (from._internal_has_heattransferrate()) {
    heattransferrate_ = new ::pulse::cdm::bind::ScalarPowerData(*from.heattransferrate_);
  } else {
    heattransferrate_ = nullptr;
  }
  if (from._internal_has_nextheattransferrate()) {
    nextheattransferrate_ = new ::pulse::cdm::bind::ScalarPowerData(*from.nextheattransferrate_);
  } else {
    nextheattransferrate_ = nullptr;
  }
  if (from._internal_has_heatsource()) {
    heatsource_ = new ::pulse::cdm::bind::ScalarPowerData(*from.heatsource_);
  } else {
    heatsource_ = nullptr;
  }
  if (from._internal_has_nextheatsource()) {
    nextheatsource_ = new ::pulse::cdm::bind::ScalarPowerData(*from.nextheatsource_);
  } else {
    nextheatsource_ = nullptr;
  }
  if (from._internal_has_heatsourcebaseline()) {
    heatsourcebaseline_ = new ::pulse::cdm::bind::ScalarPowerData(*from.heatsourcebaseline_);
  } else {
    heatsourcebaseline_ = nullptr;
  }
  if (from._internal_has_temperaturesource()) {
    temperaturesource_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.temperaturesource_);
  } else {
    temperaturesource_ = nullptr;
  }
  if (from._internal_has_nexttemperaturesource()) {
    nexttemperaturesource_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.nexttemperaturesource_);
  } else {
    nexttemperaturesource_ = nullptr;
  }
  if (from._internal_has_temperaturesourcebaseline()) {
    temperaturesourcebaseline_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.temperaturesourcebaseline_);
  } else {
    temperaturesourcebaseline_ = nullptr;
  }
  if (from._internal_has_valvebreakdowntemperature()) {
    valvebreakdowntemperature_ = new ::pulse::cdm::bind::ScalarTemperatureData(*from.valvebreakdowntemperature_);
  } else {
    valvebreakdowntemperature_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.ThermalCircuitPathData)
}

void ThermalCircuitPathData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  ::memset(&circuitpath_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&valvebreakdowntemperature_) -
      reinterpret_cast<char*>(&circuitpath_)) + sizeof(valvebreakdowntemperature_));
}

ThermalCircuitPathData::~ThermalCircuitPathData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.ThermalCircuitPathData)
  SharedDtor();
}

void ThermalCircuitPathData::SharedDtor() {
  if (this != internal_default_instance()) delete circuitpath_;
  if (this != internal_default_instance()) delete resistance_;
  if (this != internal_default_instance()) delete nextresistance_;
  if (this != internal_default_instance()) delete resistancebaseline_;
  if (this != internal_default_instance()) delete capacitance_;
  if (this != internal_default_instance()) delete nextcapacitance_;
  if (this != internal_default_instance()) delete capacitancebaseline_;
  if (this != internal_default_instance()) delete inductance_;
  if (this != internal_default_instance()) delete nextinductance_;
  if (this != internal_default_instance()) delete inductancebaseline_;
  if (this != internal_default_instance()) delete heattransferrate_;
  if (this != internal_default_instance()) delete nextheattransferrate_;
  if (this != internal_default_instance()) delete heatsource_;
  if (this != internal_default_instance()) delete nextheatsource_;
  if (this != internal_default_instance()) delete heatsourcebaseline_;
  if (this != internal_default_instance()) delete temperaturesource_;
  if (this != internal_default_instance()) delete nexttemperaturesource_;
  if (this != internal_default_instance()) delete temperaturesourcebaseline_;
  if (this != internal_default_instance()) delete valvebreakdowntemperature_;
}

void ThermalCircuitPathData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThermalCircuitPathData& ThermalCircuitPathData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThermalCircuitPathData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void ThermalCircuitPathData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.ThermalCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && circuitpath_ != nullptr) {
    delete circuitpath_;
  }
  circuitpath_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistance_ != nullptr) {
    delete resistance_;
  }
  resistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextresistance_ != nullptr) {
    delete nextresistance_;
  }
  nextresistance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && resistancebaseline_ != nullptr) {
    delete resistancebaseline_;
  }
  resistancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && capacitance_ != nullptr) {
    delete capacitance_;
  }
  capacitance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextcapacitance_ != nullptr) {
    delete nextcapacitance_;
  }
  nextcapacitance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && capacitancebaseline_ != nullptr) {
    delete capacitancebaseline_;
  }
  capacitancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inductance_ != nullptr) {
    delete inductance_;
  }
  inductance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextinductance_ != nullptr) {
    delete nextinductance_;
  }
  nextinductance_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && inductancebaseline_ != nullptr) {
    delete inductancebaseline_;
  }
  inductancebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && heattransferrate_ != nullptr) {
    delete heattransferrate_;
  }
  heattransferrate_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextheattransferrate_ != nullptr) {
    delete nextheattransferrate_;
  }
  nextheattransferrate_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && heatsource_ != nullptr) {
    delete heatsource_;
  }
  heatsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nextheatsource_ != nullptr) {
    delete nextheatsource_;
  }
  nextheatsource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && heatsourcebaseline_ != nullptr) {
    delete heatsourcebaseline_;
  }
  heatsourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && temperaturesource_ != nullptr) {
    delete temperaturesource_;
  }
  temperaturesource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && nexttemperaturesource_ != nullptr) {
    delete nexttemperaturesource_;
  }
  nexttemperaturesource_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && temperaturesourcebaseline_ != nullptr) {
    delete temperaturesourcebaseline_;
  }
  temperaturesourcebaseline_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && valvebreakdowntemperature_ != nullptr) {
    delete valvebreakdowntemperature_;
  }
  valvebreakdowntemperature_ = nullptr;
  _internal_metadata_.Clear();
}

const char* ThermalCircuitPathData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_circuitpath(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatResistanceData Resistance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatResistanceData NextResistance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextresistance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatResistanceData ResistanceBaseline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_resistancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatCapacitanceData Capacitance = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_capacitance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatCapacitanceData NextCapacitance = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextcapacitance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatCapacitanceData CapacitanceBaseline = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_capacitancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatInductanceData Inductance = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_inductance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatInductanceData NextInductance = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextinductance(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarHeatInductanceData InductanceBaseline = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_inductancebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPowerData HeatTransferRate = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_heattransferrate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPowerData NextHeatTransferRate = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextheattransferrate(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPowerData HeatSource = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_heatsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPowerData NextHeatSource = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_nextheatsource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarPowerData HeatSourceBaseline = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_heatsourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData TemperatureSource = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_temperaturesource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData NextTemperatureSource = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_nexttemperaturesource(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData TemperatureSourceBaseline = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_temperaturesourcebaseline(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pulse.cdm.bind.ScalarTemperatureData ValveBreakdownTemperature = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_valvebreakdowntemperature(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ThermalCircuitPathData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.ThermalCircuitPathData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::circuitpath(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData Resistance = 2;
  if (this->has_resistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::resistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData NextResistance = 3;
  if (this->has_nextresistance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::nextresistance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::resistancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData Capacitance = 5;
  if (this->has_capacitance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::capacitance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData NextCapacitance = 6;
  if (this->has_nextcapacitance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::nextcapacitance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData CapacitanceBaseline = 7;
  if (this->has_capacitancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::capacitancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData Inductance = 8;
  if (this->has_inductance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::inductance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData NextInductance = 9;
  if (this->has_nextinductance()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::nextinductance(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData InductanceBaseline = 10;
  if (this->has_inductancebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, _Internal::inductancebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatTransferRate = 11;
  if (this->has_heattransferrate()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, _Internal::heattransferrate(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPowerData NextHeatTransferRate = 12;
  if (this->has_nextheattransferrate()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, _Internal::nextheattransferrate(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatSource = 13;
  if (this->has_heatsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, _Internal::heatsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPowerData NextHeatSource = 14;
  if (this->has_nextheatsource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, _Internal::nextheatsource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatSourceBaseline = 15;
  if (this->has_heatsourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        15, _Internal::heatsourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSource = 16;
  if (this->has_temperaturesource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, _Internal::temperaturesource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperatureSource = 17;
  if (this->has_nexttemperaturesource()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        17, _Internal::nexttemperaturesource(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSourceBaseline = 18;
  if (this->has_temperaturesourcebaseline()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, _Internal::temperaturesourcebaseline(this), target, stream);
  }

  // .pulse.cdm.bind.ScalarTemperatureData ValveBreakdownTemperature = 19;
  if (this->has_valvebreakdowntemperature()) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        19, _Internal::valvebreakdowntemperature(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.ThermalCircuitPathData)
  return target;
}

size_t ThermalCircuitPathData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.ThermalCircuitPathData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .pulse.cdm.bind.CircuitPathData CircuitPath = 1;
  if (this->has_circuitpath()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *circuitpath_);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData Resistance = 2;
  if (this->has_resistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistance_);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData NextResistance = 3;
  if (this->has_nextresistance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextresistance_);
  }

  // .pulse.cdm.bind.ScalarHeatResistanceData ResistanceBaseline = 4;
  if (this->has_resistancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *resistancebaseline_);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData Capacitance = 5;
  if (this->has_capacitance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *capacitance_);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData NextCapacitance = 6;
  if (this->has_nextcapacitance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextcapacitance_);
  }

  // .pulse.cdm.bind.ScalarHeatCapacitanceData CapacitanceBaseline = 7;
  if (this->has_capacitancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *capacitancebaseline_);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData Inductance = 8;
  if (this->has_inductance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inductance_);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData NextInductance = 9;
  if (this->has_nextinductance()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextinductance_);
  }

  // .pulse.cdm.bind.ScalarHeatInductanceData InductanceBaseline = 10;
  if (this->has_inductancebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *inductancebaseline_);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatTransferRate = 11;
  if (this->has_heattransferrate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heattransferrate_);
  }

  // .pulse.cdm.bind.ScalarPowerData NextHeatTransferRate = 12;
  if (this->has_nextheattransferrate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextheattransferrate_);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatSource = 13;
  if (this->has_heatsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heatsource_);
  }

  // .pulse.cdm.bind.ScalarPowerData NextHeatSource = 14;
  if (this->has_nextheatsource()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nextheatsource_);
  }

  // .pulse.cdm.bind.ScalarPowerData HeatSourceBaseline = 15;
  if (this->has_heatsourcebaseline()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *heatsourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSource = 16;
  if (this->has_temperaturesource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *temperaturesource_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData NextTemperatureSource = 17;
  if (this->has_nexttemperaturesource()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *nexttemperaturesource_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData TemperatureSourceBaseline = 18;
  if (this->has_temperaturesourcebaseline()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *temperaturesourcebaseline_);
  }

  // .pulse.cdm.bind.ScalarTemperatureData ValveBreakdownTemperature = 19;
  if (this->has_valvebreakdowntemperature()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *valvebreakdowntemperature_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThermalCircuitPathData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.ThermalCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  const ThermalCircuitPathData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ThermalCircuitPathData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.ThermalCircuitPathData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.ThermalCircuitPathData)
    MergeFrom(*source);
  }
}

void ThermalCircuitPathData::MergeFrom(const ThermalCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.ThermalCircuitPathData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_circuitpath()) {
    _internal_mutable_circuitpath()->::pulse::cdm::bind::CircuitPathData::MergeFrom(from._internal_circuitpath());
  }
  if (from.has_resistance()) {
    _internal_mutable_resistance()->::pulse::cdm::bind::ScalarHeatResistanceData::MergeFrom(from._internal_resistance());
  }
  if (from.has_nextresistance()) {
    _internal_mutable_nextresistance()->::pulse::cdm::bind::ScalarHeatResistanceData::MergeFrom(from._internal_nextresistance());
  }
  if (from.has_resistancebaseline()) {
    _internal_mutable_resistancebaseline()->::pulse::cdm::bind::ScalarHeatResistanceData::MergeFrom(from._internal_resistancebaseline());
  }
  if (from.has_capacitance()) {
    _internal_mutable_capacitance()->::pulse::cdm::bind::ScalarHeatCapacitanceData::MergeFrom(from._internal_capacitance());
  }
  if (from.has_nextcapacitance()) {
    _internal_mutable_nextcapacitance()->::pulse::cdm::bind::ScalarHeatCapacitanceData::MergeFrom(from._internal_nextcapacitance());
  }
  if (from.has_capacitancebaseline()) {
    _internal_mutable_capacitancebaseline()->::pulse::cdm::bind::ScalarHeatCapacitanceData::MergeFrom(from._internal_capacitancebaseline());
  }
  if (from.has_inductance()) {
    _internal_mutable_inductance()->::pulse::cdm::bind::ScalarHeatInductanceData::MergeFrom(from._internal_inductance());
  }
  if (from.has_nextinductance()) {
    _internal_mutable_nextinductance()->::pulse::cdm::bind::ScalarHeatInductanceData::MergeFrom(from._internal_nextinductance());
  }
  if (from.has_inductancebaseline()) {
    _internal_mutable_inductancebaseline()->::pulse::cdm::bind::ScalarHeatInductanceData::MergeFrom(from._internal_inductancebaseline());
  }
  if (from.has_heattransferrate()) {
    _internal_mutable_heattransferrate()->::pulse::cdm::bind::ScalarPowerData::MergeFrom(from._internal_heattransferrate());
  }
  if (from.has_nextheattransferrate()) {
    _internal_mutable_nextheattransferrate()->::pulse::cdm::bind::ScalarPowerData::MergeFrom(from._internal_nextheattransferrate());
  }
  if (from.has_heatsource()) {
    _internal_mutable_heatsource()->::pulse::cdm::bind::ScalarPowerData::MergeFrom(from._internal_heatsource());
  }
  if (from.has_nextheatsource()) {
    _internal_mutable_nextheatsource()->::pulse::cdm::bind::ScalarPowerData::MergeFrom(from._internal_nextheatsource());
  }
  if (from.has_heatsourcebaseline()) {
    _internal_mutable_heatsourcebaseline()->::pulse::cdm::bind::ScalarPowerData::MergeFrom(from._internal_heatsourcebaseline());
  }
  if (from.has_temperaturesource()) {
    _internal_mutable_temperaturesource()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_temperaturesource());
  }
  if (from.has_nexttemperaturesource()) {
    _internal_mutable_nexttemperaturesource()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_nexttemperaturesource());
  }
  if (from.has_temperaturesourcebaseline()) {
    _internal_mutable_temperaturesourcebaseline()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_temperaturesourcebaseline());
  }
  if (from.has_valvebreakdowntemperature()) {
    _internal_mutable_valvebreakdowntemperature()->::pulse::cdm::bind::ScalarTemperatureData::MergeFrom(from._internal_valvebreakdowntemperature());
  }
}

void ThermalCircuitPathData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.ThermalCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThermalCircuitPathData::CopyFrom(const ThermalCircuitPathData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.ThermalCircuitPathData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThermalCircuitPathData::IsInitialized() const {
  return true;
}

void ThermalCircuitPathData::InternalSwap(ThermalCircuitPathData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(circuitpath_, other->circuitpath_);
  swap(resistance_, other->resistance_);
  swap(nextresistance_, other->nextresistance_);
  swap(resistancebaseline_, other->resistancebaseline_);
  swap(capacitance_, other->capacitance_);
  swap(nextcapacitance_, other->nextcapacitance_);
  swap(capacitancebaseline_, other->capacitancebaseline_);
  swap(inductance_, other->inductance_);
  swap(nextinductance_, other->nextinductance_);
  swap(inductancebaseline_, other->inductancebaseline_);
  swap(heattransferrate_, other->heattransferrate_);
  swap(nextheattransferrate_, other->nextheattransferrate_);
  swap(heatsource_, other->heatsource_);
  swap(nextheatsource_, other->nextheatsource_);
  swap(heatsourcebaseline_, other->heatsourcebaseline_);
  swap(temperaturesource_, other->temperaturesource_);
  swap(nexttemperaturesource_, other->nexttemperaturesource_);
  swap(temperaturesourcebaseline_, other->temperaturesourcebaseline_);
  swap(valvebreakdowntemperature_, other->valvebreakdowntemperature_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThermalCircuitPathData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CircuitManagerData::InitAsDefaultInstance() {
}
class CircuitManagerData::_Internal {
 public:
};

CircuitManagerData::CircuitManagerData()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:pulse.cdm.bind.CircuitManagerData)
}
CircuitManagerData::CircuitManagerData(const CircuitManagerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      electricalnode_(from.electricalnode_),
      electricalpath_(from.electricalpath_),
      electricalcircuit_(from.electricalcircuit_),
      fluidnode_(from.fluidnode_),
      fluidpath_(from.fluidpath_),
      fluidcircuit_(from.fluidcircuit_),
      thermalnode_(from.thermalnode_),
      thermalpath_(from.thermalpath_),
      thermalcircuit_(from.thermalcircuit_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pulse.cdm.bind.CircuitManagerData)
}

void CircuitManagerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
}

CircuitManagerData::~CircuitManagerData() {
  // @@protoc_insertion_point(destructor:pulse.cdm.bind.CircuitManagerData)
  SharedDtor();
}

void CircuitManagerData::SharedDtor() {
}

void CircuitManagerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CircuitManagerData& CircuitManagerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CircuitManagerData_pulse_2fcdm_2fbind_2fCircuit_2eproto.base);
  return *internal_default_instance();
}


void CircuitManagerData::Clear() {
// @@protoc_insertion_point(message_clear_start:pulse.cdm.bind.CircuitManagerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  electricalnode_.Clear();
  electricalpath_.Clear();
  electricalcircuit_.Clear();
  fluidnode_.Clear();
  fluidpath_.Clear();
  fluidcircuit_.Clear();
  thermalnode_.Clear();
  thermalpath_.Clear();
  thermalcircuit_.Clear();
  _internal_metadata_.Clear();
}

const char* CircuitManagerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pulse.cdm.bind.ElectricalCircuitNodeData ElectricalNode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_electricalnode(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.ElectricalCircuitPathData ElectricalPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_electricalpath(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.ElectricalCircuitData ElectricalCircuit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_electricalcircuit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.FluidCircuitNodeData FluidNode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fluidnode(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.FluidCircuitPathData FluidPath = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fluidpath(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.FluidCircuitData FluidCircuit = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fluidcircuit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.ThermalCircuitNodeData ThermalNode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thermalnode(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.ThermalCircuitPathData ThermalPath = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thermalpath(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .pulse.cdm.bind.ThermalCircuitData ThermalCircuit = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_thermalcircuit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CircuitManagerData::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pulse.cdm.bind.CircuitManagerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pulse.cdm.bind.ElectricalCircuitNodeData ElectricalNode = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_electricalnode_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(1, this->_internal_electricalnode(i), target, stream);
  }

  // repeated .pulse.cdm.bind.ElectricalCircuitPathData ElectricalPath = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_electricalpath_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(2, this->_internal_electricalpath(i), target, stream);
  }

  // repeated .pulse.cdm.bind.ElectricalCircuitData ElectricalCircuit = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_electricalcircuit_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(3, this->_internal_electricalcircuit(i), target, stream);
  }

  // repeated .pulse.cdm.bind.FluidCircuitNodeData FluidNode = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fluidnode_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(4, this->_internal_fluidnode(i), target, stream);
  }

  // repeated .pulse.cdm.bind.FluidCircuitPathData FluidPath = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fluidpath_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(5, this->_internal_fluidpath(i), target, stream);
  }

  // repeated .pulse.cdm.bind.FluidCircuitData FluidCircuit = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_fluidcircuit_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(6, this->_internal_fluidcircuit(i), target, stream);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitNodeData ThermalNode = 7;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_thermalnode_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(7, this->_internal_thermalnode(i), target, stream);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitPathData ThermalPath = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_thermalpath_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(8, this->_internal_thermalpath(i), target, stream);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitData ThermalCircuit = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_thermalcircuit_size()); i < n; i++) {
    stream->EnsureSpace(&target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(9, this->_internal_thermalcircuit(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pulse.cdm.bind.CircuitManagerData)
  return target;
}

size_t CircuitManagerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pulse.cdm.bind.CircuitManagerData)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pulse.cdm.bind.ElectricalCircuitNodeData ElectricalNode = 1;
  total_size += 1UL * this->_internal_electricalnode_size();
  for (const auto& msg : this->electricalnode_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.ElectricalCircuitPathData ElectricalPath = 2;
  total_size += 1UL * this->_internal_electricalpath_size();
  for (const auto& msg : this->electricalpath_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.ElectricalCircuitData ElectricalCircuit = 3;
  total_size += 1UL * this->_internal_electricalcircuit_size();
  for (const auto& msg : this->electricalcircuit_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.FluidCircuitNodeData FluidNode = 4;
  total_size += 1UL * this->_internal_fluidnode_size();
  for (const auto& msg : this->fluidnode_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.FluidCircuitPathData FluidPath = 5;
  total_size += 1UL * this->_internal_fluidpath_size();
  for (const auto& msg : this->fluidpath_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.FluidCircuitData FluidCircuit = 6;
  total_size += 1UL * this->_internal_fluidcircuit_size();
  for (const auto& msg : this->fluidcircuit_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitNodeData ThermalNode = 7;
  total_size += 1UL * this->_internal_thermalnode_size();
  for (const auto& msg : this->thermalnode_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitPathData ThermalPath = 8;
  total_size += 1UL * this->_internal_thermalpath_size();
  for (const auto& msg : this->thermalpath_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pulse.cdm.bind.ThermalCircuitData ThermalCircuit = 9;
  total_size += 1UL * this->_internal_thermalcircuit_size();
  for (const auto& msg : this->thermalcircuit_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CircuitManagerData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pulse.cdm.bind.CircuitManagerData)
  GOOGLE_DCHECK_NE(&from, this);
  const CircuitManagerData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CircuitManagerData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pulse.cdm.bind.CircuitManagerData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pulse.cdm.bind.CircuitManagerData)
    MergeFrom(*source);
  }
}

void CircuitManagerData::MergeFrom(const CircuitManagerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pulse.cdm.bind.CircuitManagerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  electricalnode_.MergeFrom(from.electricalnode_);
  electricalpath_.MergeFrom(from.electricalpath_);
  electricalcircuit_.MergeFrom(from.electricalcircuit_);
  fluidnode_.MergeFrom(from.fluidnode_);
  fluidpath_.MergeFrom(from.fluidpath_);
  fluidcircuit_.MergeFrom(from.fluidcircuit_);
  thermalnode_.MergeFrom(from.thermalnode_);
  thermalpath_.MergeFrom(from.thermalpath_);
  thermalcircuit_.MergeFrom(from.thermalcircuit_);
}

void CircuitManagerData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pulse.cdm.bind.CircuitManagerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CircuitManagerData::CopyFrom(const CircuitManagerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pulse.cdm.bind.CircuitManagerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircuitManagerData::IsInitialized() const {
  return true;
}

void CircuitManagerData::InternalSwap(CircuitManagerData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  electricalnode_.InternalSwap(&other->electricalnode_);
  electricalpath_.InternalSwap(&other->electricalpath_);
  electricalcircuit_.InternalSwap(&other->electricalcircuit_);
  fluidnode_.InternalSwap(&other->fluidnode_);
  fluidpath_.InternalSwap(&other->fluidpath_);
  fluidcircuit_.InternalSwap(&other->fluidcircuit_);
  thermalnode_.InternalSwap(&other->thermalnode_);
  thermalpath_.InternalSwap(&other->thermalpath_);
  thermalcircuit_.InternalSwap(&other->thermalcircuit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CircuitManagerData::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace bind
}  // namespace cdm
}  // namespace pulse
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::CircuitData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::CircuitData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::CircuitData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::CircuitNodeData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::CircuitNodeData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::CircuitNodeData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::CircuitPathData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::CircuitPathData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::CircuitPathData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ElectricalCircuitData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ElectricalCircuitData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ElectricalCircuitData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ElectricalCircuitNodeData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ElectricalCircuitNodeData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ElectricalCircuitNodeData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ElectricalCircuitPathData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ElectricalCircuitPathData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ElectricalCircuitPathData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::FluidCircuitData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::FluidCircuitData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::FluidCircuitData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::FluidCircuitNodeData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::FluidCircuitNodeData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::FluidCircuitNodeData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::FluidCircuitPathData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::FluidCircuitPathData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::FluidCircuitPathData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ThermalCircuitData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ThermalCircuitData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ThermalCircuitData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ThermalCircuitNodeData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ThermalCircuitNodeData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ThermalCircuitNodeData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::ThermalCircuitPathData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::ThermalCircuitPathData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::ThermalCircuitPathData >(arena);
}
template<> PROTOBUF_NOINLINE ::pulse::cdm::bind::CircuitManagerData* Arena::CreateMaybeMessage< ::pulse::cdm::bind::CircuitManagerData >(Arena* arena) {
  return Arena::CreateInternal< ::pulse::cdm::bind::CircuitManagerData >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
