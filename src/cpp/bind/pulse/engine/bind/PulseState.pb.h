// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pulse/engine/bind/PulseState.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pulse_2fengine_2fbind_2fPulseState_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pulse_2fengine_2fbind_2fPulseState_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3010000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3010001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pulse/cdm/bind/Enums.pb.h"
#include "pulse/cdm/bind/Events.pb.h"
#include "pulse/cdm/bind/Patient.pb.h"
#include "pulse/cdm/bind/Properties.pb.h"
#include "pulse/cdm/bind/Engine.pb.h"
#include "pulse/cdm/bind/Substance.pb.h"
#include "pulse/cdm/bind/Compartment.pb.h"
#include "pulse/cdm/bind/Circuit.pb.h"
#include "pulse/engine/bind/PulsePhysiology.pb.h"
#include "pulse/engine/bind/PulseEnvironment.pb.h"
#include "pulse/engine/bind/PulseEquipment.pb.h"
#include "pulse/engine/bind/PulseConfiguration.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pulse_2fengine_2fbind_2fPulseState_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pulse_2fengine_2fbind_2fPulseState_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pulse_2fengine_2fbind_2fPulseState_2eproto;
namespace pulse {
namespace engine {
namespace bind {
class StateData;
class StateDataDefaultTypeInternal;
extern StateDataDefaultTypeInternal _StateData_default_instance_;
}  // namespace bind
}  // namespace engine
}  // namespace pulse
PROTOBUF_NAMESPACE_OPEN
template<> ::pulse::engine::bind::StateData* Arena::CreateMaybeMessage<::pulse::engine::bind::StateData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pulse {
namespace engine {
namespace bind {

enum eAirwayMode : int {
  Free = 0,
  AnesthesiaMachine = 1,
  Inhaler = 2,
  MechanicalVentilator = 3,
  NasalCannula = 4,
  SimpleMask = 5,
  NonRebreatherMask = 6,
  eAirwayMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  eAirwayMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool eAirwayMode_IsValid(int value);
constexpr eAirwayMode eAirwayMode_MIN = Free;
constexpr eAirwayMode eAirwayMode_MAX = NonRebreatherMask;
constexpr int eAirwayMode_ARRAYSIZE = eAirwayMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eAirwayMode_descriptor();
template<typename T>
inline const std::string& eAirwayMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eAirwayMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eAirwayMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eAirwayMode_descriptor(), enum_t_value);
}
inline bool eAirwayMode_Parse(
    const std::string& name, eAirwayMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eAirwayMode>(
    eAirwayMode_descriptor(), name, value);
}
// ===================================================================

class StateData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pulse.engine.bind.StateData) */ {
 public:
  StateData();
  virtual ~StateData();

  StateData(const StateData& from);
  StateData(StateData&& from) noexcept
    : StateData() {
    *this = ::std::move(from);
  }

  inline StateData& operator=(const StateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateData& operator=(StateData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateData* internal_default_instance() {
    return reinterpret_cast<const StateData*>(
               &_StateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StateData& a, StateData& b) {
    a.Swap(&b);
  }
  inline void Swap(StateData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateData* New() const final {
    return CreateMaybeMessage<StateData>(nullptr);
  }

  StateData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateData& from);
  void MergeFrom(const StateData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pulse.engine.bind.StateData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pulse_2fengine_2fbind_2fPulseState_2eproto);
    return ::descriptor_table_pulse_2fengine_2fbind_2fPulseState_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActiveSubstanceFieldNumber = 26,
    kActiveCompoundFieldNumber = 27,
    kSimulationTimeFieldNumber = 3,
    kCurrentPatientFieldNumber = 4,
    kInitialPatientFieldNumber = 5,
    kConditionsFieldNumber = 6,
    kActiveActionsFieldNumber = 7,
    kActiveEventsFieldNumber = 8,
    kBloodChemistryFieldNumber = 9,
    kCardiovascularFieldNumber = 10,
    kDrugFieldNumber = 11,
    kEndocrineFieldNumber = 12,
    kEnergyFieldNumber = 13,
    kGastrointestinalFieldNumber = 14,
    kHepaticFieldNumber = 15,
    kNervousFieldNumber = 16,
    kRenalFieldNumber = 17,
    kRespiratoryFieldNumber = 18,
    kTissueFieldNumber = 19,
    kEnvironmentFieldNumber = 20,
    kAnesthesiaMachineFieldNumber = 21,
    kElectroCardioGramFieldNumber = 22,
    kInhalerFieldNumber = 23,
    kCompartmentManagerFieldNumber = 24,
    kCircuitManagerFieldNumber = 25,
    kConfigurationFieldNumber = 28,
    kDataRequestManagerFieldNumber = 29,
    kAirwayModeFieldNumber = 1,
    kIntubationFieldNumber = 2,
  };
  // repeated .pulse.cdm.bind.SubstanceData ActiveSubstance = 26;
  int activesubstance_size() const;
  private:
  int _internal_activesubstance_size() const;
  public:
  void clear_activesubstance();
  ::pulse::cdm::bind::SubstanceData* mutable_activesubstance(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceData >*
      mutable_activesubstance();
  private:
  const ::pulse::cdm::bind::SubstanceData& _internal_activesubstance(int index) const;
  ::pulse::cdm::bind::SubstanceData* _internal_add_activesubstance();
  public:
  const ::pulse::cdm::bind::SubstanceData& activesubstance(int index) const;
  ::pulse::cdm::bind::SubstanceData* add_activesubstance();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceData >&
      activesubstance() const;

  // repeated .pulse.cdm.bind.SubstanceCompoundData ActiveCompound = 27;
  int activecompound_size() const;
  private:
  int _internal_activecompound_size() const;
  public:
  void clear_activecompound();
  ::pulse::cdm::bind::SubstanceCompoundData* mutable_activecompound(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceCompoundData >*
      mutable_activecompound();
  private:
  const ::pulse::cdm::bind::SubstanceCompoundData& _internal_activecompound(int index) const;
  ::pulse::cdm::bind::SubstanceCompoundData* _internal_add_activecompound();
  public:
  const ::pulse::cdm::bind::SubstanceCompoundData& activecompound(int index) const;
  ::pulse::cdm::bind::SubstanceCompoundData* add_activecompound();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceCompoundData >&
      activecompound() const;

  // .pulse.cdm.bind.ScalarTimeData SimulationTime = 3;
  bool has_simulationtime() const;
  private:
  bool _internal_has_simulationtime() const;
  public:
  void clear_simulationtime();
  const ::pulse::cdm::bind::ScalarTimeData& simulationtime() const;
  ::pulse::cdm::bind::ScalarTimeData* release_simulationtime();
  ::pulse::cdm::bind::ScalarTimeData* mutable_simulationtime();
  void set_allocated_simulationtime(::pulse::cdm::bind::ScalarTimeData* simulationtime);
  private:
  const ::pulse::cdm::bind::ScalarTimeData& _internal_simulationtime() const;
  ::pulse::cdm::bind::ScalarTimeData* _internal_mutable_simulationtime();
  public:

  // .pulse.cdm.bind.PatientData CurrentPatient = 4;
  bool has_currentpatient() const;
  private:
  bool _internal_has_currentpatient() const;
  public:
  void clear_currentpatient();
  const ::pulse::cdm::bind::PatientData& currentpatient() const;
  ::pulse::cdm::bind::PatientData* release_currentpatient();
  ::pulse::cdm::bind::PatientData* mutable_currentpatient();
  void set_allocated_currentpatient(::pulse::cdm::bind::PatientData* currentpatient);
  private:
  const ::pulse::cdm::bind::PatientData& _internal_currentpatient() const;
  ::pulse::cdm::bind::PatientData* _internal_mutable_currentpatient();
  public:

  // .pulse.cdm.bind.PatientData InitialPatient = 5;
  bool has_initialpatient() const;
  private:
  bool _internal_has_initialpatient() const;
  public:
  void clear_initialpatient();
  const ::pulse::cdm::bind::PatientData& initialpatient() const;
  ::pulse::cdm::bind::PatientData* release_initialpatient();
  ::pulse::cdm::bind::PatientData* mutable_initialpatient();
  void set_allocated_initialpatient(::pulse::cdm::bind::PatientData* initialpatient);
  private:
  const ::pulse::cdm::bind::PatientData& _internal_initialpatient() const;
  ::pulse::cdm::bind::PatientData* _internal_mutable_initialpatient();
  public:

  // .pulse.cdm.bind.ConditionListData Conditions = 6;
  bool has_conditions() const;
  private:
  bool _internal_has_conditions() const;
  public:
  void clear_conditions();
  const ::pulse::cdm::bind::ConditionListData& conditions() const;
  ::pulse::cdm::bind::ConditionListData* release_conditions();
  ::pulse::cdm::bind::ConditionListData* mutable_conditions();
  void set_allocated_conditions(::pulse::cdm::bind::ConditionListData* conditions);
  private:
  const ::pulse::cdm::bind::ConditionListData& _internal_conditions() const;
  ::pulse::cdm::bind::ConditionListData* _internal_mutable_conditions();
  public:

  // .pulse.cdm.bind.ActionListData ActiveActions = 7;
  bool has_activeactions() const;
  private:
  bool _internal_has_activeactions() const;
  public:
  void clear_activeactions();
  const ::pulse::cdm::bind::ActionListData& activeactions() const;
  ::pulse::cdm::bind::ActionListData* release_activeactions();
  ::pulse::cdm::bind::ActionListData* mutable_activeactions();
  void set_allocated_activeactions(::pulse::cdm::bind::ActionListData* activeactions);
  private:
  const ::pulse::cdm::bind::ActionListData& _internal_activeactions() const;
  ::pulse::cdm::bind::ActionListData* _internal_mutable_activeactions();
  public:

  // .pulse.cdm.bind.ActiveEventListData ActiveEvents = 8;
  bool has_activeevents() const;
  private:
  bool _internal_has_activeevents() const;
  public:
  void clear_activeevents();
  const ::pulse::cdm::bind::ActiveEventListData& activeevents() const;
  ::pulse::cdm::bind::ActiveEventListData* release_activeevents();
  ::pulse::cdm::bind::ActiveEventListData* mutable_activeevents();
  void set_allocated_activeevents(::pulse::cdm::bind::ActiveEventListData* activeevents);
  private:
  const ::pulse::cdm::bind::ActiveEventListData& _internal_activeevents() const;
  ::pulse::cdm::bind::ActiveEventListData* _internal_mutable_activeevents();
  public:

  // .pulse.engine.bind.BloodChemistryData BloodChemistry = 9;
  bool has_bloodchemistry() const;
  private:
  bool _internal_has_bloodchemistry() const;
  public:
  void clear_bloodchemistry();
  const ::pulse::engine::bind::BloodChemistryData& bloodchemistry() const;
  ::pulse::engine::bind::BloodChemistryData* release_bloodchemistry();
  ::pulse::engine::bind::BloodChemistryData* mutable_bloodchemistry();
  void set_allocated_bloodchemistry(::pulse::engine::bind::BloodChemistryData* bloodchemistry);
  private:
  const ::pulse::engine::bind::BloodChemistryData& _internal_bloodchemistry() const;
  ::pulse::engine::bind::BloodChemistryData* _internal_mutable_bloodchemistry();
  public:

  // .pulse.engine.bind.CardiovascularData Cardiovascular = 10;
  bool has_cardiovascular() const;
  private:
  bool _internal_has_cardiovascular() const;
  public:
  void clear_cardiovascular();
  const ::pulse::engine::bind::CardiovascularData& cardiovascular() const;
  ::pulse::engine::bind::CardiovascularData* release_cardiovascular();
  ::pulse::engine::bind::CardiovascularData* mutable_cardiovascular();
  void set_allocated_cardiovascular(::pulse::engine::bind::CardiovascularData* cardiovascular);
  private:
  const ::pulse::engine::bind::CardiovascularData& _internal_cardiovascular() const;
  ::pulse::engine::bind::CardiovascularData* _internal_mutable_cardiovascular();
  public:

  // .pulse.engine.bind.DrugData Drug = 11;
  bool has_drug() const;
  private:
  bool _internal_has_drug() const;
  public:
  void clear_drug();
  const ::pulse::engine::bind::DrugData& drug() const;
  ::pulse::engine::bind::DrugData* release_drug();
  ::pulse::engine::bind::DrugData* mutable_drug();
  void set_allocated_drug(::pulse::engine::bind::DrugData* drug);
  private:
  const ::pulse::engine::bind::DrugData& _internal_drug() const;
  ::pulse::engine::bind::DrugData* _internal_mutable_drug();
  public:

  // .pulse.engine.bind.EndocrineData Endocrine = 12;
  bool has_endocrine() const;
  private:
  bool _internal_has_endocrine() const;
  public:
  void clear_endocrine();
  const ::pulse::engine::bind::EndocrineData& endocrine() const;
  ::pulse::engine::bind::EndocrineData* release_endocrine();
  ::pulse::engine::bind::EndocrineData* mutable_endocrine();
  void set_allocated_endocrine(::pulse::engine::bind::EndocrineData* endocrine);
  private:
  const ::pulse::engine::bind::EndocrineData& _internal_endocrine() const;
  ::pulse::engine::bind::EndocrineData* _internal_mutable_endocrine();
  public:

  // .pulse.engine.bind.EnergyData Energy = 13;
  bool has_energy() const;
  private:
  bool _internal_has_energy() const;
  public:
  void clear_energy();
  const ::pulse::engine::bind::EnergyData& energy() const;
  ::pulse::engine::bind::EnergyData* release_energy();
  ::pulse::engine::bind::EnergyData* mutable_energy();
  void set_allocated_energy(::pulse::engine::bind::EnergyData* energy);
  private:
  const ::pulse::engine::bind::EnergyData& _internal_energy() const;
  ::pulse::engine::bind::EnergyData* _internal_mutable_energy();
  public:

  // .pulse.engine.bind.GastrointestinalData Gastrointestinal = 14;
  bool has_gastrointestinal() const;
  private:
  bool _internal_has_gastrointestinal() const;
  public:
  void clear_gastrointestinal();
  const ::pulse::engine::bind::GastrointestinalData& gastrointestinal() const;
  ::pulse::engine::bind::GastrointestinalData* release_gastrointestinal();
  ::pulse::engine::bind::GastrointestinalData* mutable_gastrointestinal();
  void set_allocated_gastrointestinal(::pulse::engine::bind::GastrointestinalData* gastrointestinal);
  private:
  const ::pulse::engine::bind::GastrointestinalData& _internal_gastrointestinal() const;
  ::pulse::engine::bind::GastrointestinalData* _internal_mutable_gastrointestinal();
  public:

  // .pulse.engine.bind.HepaticData Hepatic = 15;
  bool has_hepatic() const;
  private:
  bool _internal_has_hepatic() const;
  public:
  void clear_hepatic();
  const ::pulse::engine::bind::HepaticData& hepatic() const;
  ::pulse::engine::bind::HepaticData* release_hepatic();
  ::pulse::engine::bind::HepaticData* mutable_hepatic();
  void set_allocated_hepatic(::pulse::engine::bind::HepaticData* hepatic);
  private:
  const ::pulse::engine::bind::HepaticData& _internal_hepatic() const;
  ::pulse::engine::bind::HepaticData* _internal_mutable_hepatic();
  public:

  // .pulse.engine.bind.NervousData Nervous = 16;
  bool has_nervous() const;
  private:
  bool _internal_has_nervous() const;
  public:
  void clear_nervous();
  const ::pulse::engine::bind::NervousData& nervous() const;
  ::pulse::engine::bind::NervousData* release_nervous();
  ::pulse::engine::bind::NervousData* mutable_nervous();
  void set_allocated_nervous(::pulse::engine::bind::NervousData* nervous);
  private:
  const ::pulse::engine::bind::NervousData& _internal_nervous() const;
  ::pulse::engine::bind::NervousData* _internal_mutable_nervous();
  public:

  // .pulse.engine.bind.RenalData Renal = 17;
  bool has_renal() const;
  private:
  bool _internal_has_renal() const;
  public:
  void clear_renal();
  const ::pulse::engine::bind::RenalData& renal() const;
  ::pulse::engine::bind::RenalData* release_renal();
  ::pulse::engine::bind::RenalData* mutable_renal();
  void set_allocated_renal(::pulse::engine::bind::RenalData* renal);
  private:
  const ::pulse::engine::bind::RenalData& _internal_renal() const;
  ::pulse::engine::bind::RenalData* _internal_mutable_renal();
  public:

  // .pulse.engine.bind.RespiratoryData Respiratory = 18;
  bool has_respiratory() const;
  private:
  bool _internal_has_respiratory() const;
  public:
  void clear_respiratory();
  const ::pulse::engine::bind::RespiratoryData& respiratory() const;
  ::pulse::engine::bind::RespiratoryData* release_respiratory();
  ::pulse::engine::bind::RespiratoryData* mutable_respiratory();
  void set_allocated_respiratory(::pulse::engine::bind::RespiratoryData* respiratory);
  private:
  const ::pulse::engine::bind::RespiratoryData& _internal_respiratory() const;
  ::pulse::engine::bind::RespiratoryData* _internal_mutable_respiratory();
  public:

  // .pulse.engine.bind.TissueData Tissue = 19;
  bool has_tissue() const;
  private:
  bool _internal_has_tissue() const;
  public:
  void clear_tissue();
  const ::pulse::engine::bind::TissueData& tissue() const;
  ::pulse::engine::bind::TissueData* release_tissue();
  ::pulse::engine::bind::TissueData* mutable_tissue();
  void set_allocated_tissue(::pulse::engine::bind::TissueData* tissue);
  private:
  const ::pulse::engine::bind::TissueData& _internal_tissue() const;
  ::pulse::engine::bind::TissueData* _internal_mutable_tissue();
  public:

  // .pulse.engine.bind.EnvironmentData Environment = 20;
  bool has_environment() const;
  private:
  bool _internal_has_environment() const;
  public:
  void clear_environment();
  const ::pulse::engine::bind::EnvironmentData& environment() const;
  ::pulse::engine::bind::EnvironmentData* release_environment();
  ::pulse::engine::bind::EnvironmentData* mutable_environment();
  void set_allocated_environment(::pulse::engine::bind::EnvironmentData* environment);
  private:
  const ::pulse::engine::bind::EnvironmentData& _internal_environment() const;
  ::pulse::engine::bind::EnvironmentData* _internal_mutable_environment();
  public:

  // .pulse.engine.bind.AnesthesiaMachineData AnesthesiaMachine = 21;
  bool has_anesthesiamachine() const;
  private:
  bool _internal_has_anesthesiamachine() const;
  public:
  void clear_anesthesiamachine();
  const ::pulse::engine::bind::AnesthesiaMachineData& anesthesiamachine() const;
  ::pulse::engine::bind::AnesthesiaMachineData* release_anesthesiamachine();
  ::pulse::engine::bind::AnesthesiaMachineData* mutable_anesthesiamachine();
  void set_allocated_anesthesiamachine(::pulse::engine::bind::AnesthesiaMachineData* anesthesiamachine);
  private:
  const ::pulse::engine::bind::AnesthesiaMachineData& _internal_anesthesiamachine() const;
  ::pulse::engine::bind::AnesthesiaMachineData* _internal_mutable_anesthesiamachine();
  public:

  // .pulse.engine.bind.ElectroCardioGramData ElectroCardioGram = 22;
  bool has_electrocardiogram() const;
  private:
  bool _internal_has_electrocardiogram() const;
  public:
  void clear_electrocardiogram();
  const ::pulse::engine::bind::ElectroCardioGramData& electrocardiogram() const;
  ::pulse::engine::bind::ElectroCardioGramData* release_electrocardiogram();
  ::pulse::engine::bind::ElectroCardioGramData* mutable_electrocardiogram();
  void set_allocated_electrocardiogram(::pulse::engine::bind::ElectroCardioGramData* electrocardiogram);
  private:
  const ::pulse::engine::bind::ElectroCardioGramData& _internal_electrocardiogram() const;
  ::pulse::engine::bind::ElectroCardioGramData* _internal_mutable_electrocardiogram();
  public:

  // .pulse.engine.bind.InhalerData Inhaler = 23;
  bool has_inhaler() const;
  private:
  bool _internal_has_inhaler() const;
  public:
  void clear_inhaler();
  const ::pulse::engine::bind::InhalerData& inhaler() const;
  ::pulse::engine::bind::InhalerData* release_inhaler();
  ::pulse::engine::bind::InhalerData* mutable_inhaler();
  void set_allocated_inhaler(::pulse::engine::bind::InhalerData* inhaler);
  private:
  const ::pulse::engine::bind::InhalerData& _internal_inhaler() const;
  ::pulse::engine::bind::InhalerData* _internal_mutable_inhaler();
  public:

  // .pulse.cdm.bind.CompartmentManagerData CompartmentManager = 24;
  bool has_compartmentmanager() const;
  private:
  bool _internal_has_compartmentmanager() const;
  public:
  void clear_compartmentmanager();
  const ::pulse::cdm::bind::CompartmentManagerData& compartmentmanager() const;
  ::pulse::cdm::bind::CompartmentManagerData* release_compartmentmanager();
  ::pulse::cdm::bind::CompartmentManagerData* mutable_compartmentmanager();
  void set_allocated_compartmentmanager(::pulse::cdm::bind::CompartmentManagerData* compartmentmanager);
  private:
  const ::pulse::cdm::bind::CompartmentManagerData& _internal_compartmentmanager() const;
  ::pulse::cdm::bind::CompartmentManagerData* _internal_mutable_compartmentmanager();
  public:

  // .pulse.cdm.bind.CircuitManagerData CircuitManager = 25;
  bool has_circuitmanager() const;
  private:
  bool _internal_has_circuitmanager() const;
  public:
  void clear_circuitmanager();
  const ::pulse::cdm::bind::CircuitManagerData& circuitmanager() const;
  ::pulse::cdm::bind::CircuitManagerData* release_circuitmanager();
  ::pulse::cdm::bind::CircuitManagerData* mutable_circuitmanager();
  void set_allocated_circuitmanager(::pulse::cdm::bind::CircuitManagerData* circuitmanager);
  private:
  const ::pulse::cdm::bind::CircuitManagerData& _internal_circuitmanager() const;
  ::pulse::cdm::bind::CircuitManagerData* _internal_mutable_circuitmanager();
  public:

  // .pulse.engine.bind.ConfigurationData Configuration = 28;
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::pulse::engine::bind::ConfigurationData& configuration() const;
  ::pulse::engine::bind::ConfigurationData* release_configuration();
  ::pulse::engine::bind::ConfigurationData* mutable_configuration();
  void set_allocated_configuration(::pulse::engine::bind::ConfigurationData* configuration);
  private:
  const ::pulse::engine::bind::ConfigurationData& _internal_configuration() const;
  ::pulse::engine::bind::ConfigurationData* _internal_mutable_configuration();
  public:

  // .pulse.cdm.bind.DataRequestManagerData DataRequestManager = 29;
  bool has_datarequestmanager() const;
  private:
  bool _internal_has_datarequestmanager() const;
  public:
  void clear_datarequestmanager();
  const ::pulse::cdm::bind::DataRequestManagerData& datarequestmanager() const;
  ::pulse::cdm::bind::DataRequestManagerData* release_datarequestmanager();
  ::pulse::cdm::bind::DataRequestManagerData* mutable_datarequestmanager();
  void set_allocated_datarequestmanager(::pulse::cdm::bind::DataRequestManagerData* datarequestmanager);
  private:
  const ::pulse::cdm::bind::DataRequestManagerData& _internal_datarequestmanager() const;
  ::pulse::cdm::bind::DataRequestManagerData* _internal_mutable_datarequestmanager();
  public:

  // .pulse.engine.bind.eAirwayMode AirwayMode = 1;
  void clear_airwaymode();
  ::pulse::engine::bind::eAirwayMode airwaymode() const;
  void set_airwaymode(::pulse::engine::bind::eAirwayMode value);
  private:
  ::pulse::engine::bind::eAirwayMode _internal_airwaymode() const;
  void _internal_set_airwaymode(::pulse::engine::bind::eAirwayMode value);
  public:

  // .pulse.cdm.bind.eSwitch Intubation = 2;
  void clear_intubation();
  ::pulse::cdm::bind::eSwitch intubation() const;
  void set_intubation(::pulse::cdm::bind::eSwitch value);
  private:
  ::pulse::cdm::bind::eSwitch _internal_intubation() const;
  void _internal_set_intubation(::pulse::cdm::bind::eSwitch value);
  public:

  // @@protoc_insertion_point(class_scope:pulse.engine.bind.StateData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceData > activesubstance_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceCompoundData > activecompound_;
  ::pulse::cdm::bind::ScalarTimeData* simulationtime_;
  ::pulse::cdm::bind::PatientData* currentpatient_;
  ::pulse::cdm::bind::PatientData* initialpatient_;
  ::pulse::cdm::bind::ConditionListData* conditions_;
  ::pulse::cdm::bind::ActionListData* activeactions_;
  ::pulse::cdm::bind::ActiveEventListData* activeevents_;
  ::pulse::engine::bind::BloodChemistryData* bloodchemistry_;
  ::pulse::engine::bind::CardiovascularData* cardiovascular_;
  ::pulse::engine::bind::DrugData* drug_;
  ::pulse::engine::bind::EndocrineData* endocrine_;
  ::pulse::engine::bind::EnergyData* energy_;
  ::pulse::engine::bind::GastrointestinalData* gastrointestinal_;
  ::pulse::engine::bind::HepaticData* hepatic_;
  ::pulse::engine::bind::NervousData* nervous_;
  ::pulse::engine::bind::RenalData* renal_;
  ::pulse::engine::bind::RespiratoryData* respiratory_;
  ::pulse::engine::bind::TissueData* tissue_;
  ::pulse::engine::bind::EnvironmentData* environment_;
  ::pulse::engine::bind::AnesthesiaMachineData* anesthesiamachine_;
  ::pulse::engine::bind::ElectroCardioGramData* electrocardiogram_;
  ::pulse::engine::bind::InhalerData* inhaler_;
  ::pulse::cdm::bind::CompartmentManagerData* compartmentmanager_;
  ::pulse::cdm::bind::CircuitManagerData* circuitmanager_;
  ::pulse::engine::bind::ConfigurationData* configuration_;
  ::pulse::cdm::bind::DataRequestManagerData* datarequestmanager_;
  int airwaymode_;
  int intubation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pulse_2fengine_2fbind_2fPulseState_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StateData

// .pulse.engine.bind.eAirwayMode AirwayMode = 1;
inline void StateData::clear_airwaymode() {
  airwaymode_ = 0;
}
inline ::pulse::engine::bind::eAirwayMode StateData::_internal_airwaymode() const {
  return static_cast< ::pulse::engine::bind::eAirwayMode >(airwaymode_);
}
inline ::pulse::engine::bind::eAirwayMode StateData::airwaymode() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.AirwayMode)
  return _internal_airwaymode();
}
inline void StateData::_internal_set_airwaymode(::pulse::engine::bind::eAirwayMode value) {
  
  airwaymode_ = value;
}
inline void StateData::set_airwaymode(::pulse::engine::bind::eAirwayMode value) {
  _internal_set_airwaymode(value);
  // @@protoc_insertion_point(field_set:pulse.engine.bind.StateData.AirwayMode)
}

// .pulse.cdm.bind.eSwitch Intubation = 2;
inline void StateData::clear_intubation() {
  intubation_ = 0;
}
inline ::pulse::cdm::bind::eSwitch StateData::_internal_intubation() const {
  return static_cast< ::pulse::cdm::bind::eSwitch >(intubation_);
}
inline ::pulse::cdm::bind::eSwitch StateData::intubation() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Intubation)
  return _internal_intubation();
}
inline void StateData::_internal_set_intubation(::pulse::cdm::bind::eSwitch value) {
  
  intubation_ = value;
}
inline void StateData::set_intubation(::pulse::cdm::bind::eSwitch value) {
  _internal_set_intubation(value);
  // @@protoc_insertion_point(field_set:pulse.engine.bind.StateData.Intubation)
}

// .pulse.cdm.bind.ScalarTimeData SimulationTime = 3;
inline bool StateData::_internal_has_simulationtime() const {
  return this != internal_default_instance() && simulationtime_ != nullptr;
}
inline bool StateData::has_simulationtime() const {
  return _internal_has_simulationtime();
}
inline const ::pulse::cdm::bind::ScalarTimeData& StateData::_internal_simulationtime() const {
  const ::pulse::cdm::bind::ScalarTimeData* p = simulationtime_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::ScalarTimeData*>(
      &::pulse::cdm::bind::_ScalarTimeData_default_instance_);
}
inline const ::pulse::cdm::bind::ScalarTimeData& StateData::simulationtime() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.SimulationTime)
  return _internal_simulationtime();
}
inline ::pulse::cdm::bind::ScalarTimeData* StateData::release_simulationtime() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.SimulationTime)
  
  ::pulse::cdm::bind::ScalarTimeData* temp = simulationtime_;
  simulationtime_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ScalarTimeData* StateData::_internal_mutable_simulationtime() {
  
  if (simulationtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ScalarTimeData>(GetArenaNoVirtual());
    simulationtime_ = p;
  }
  return simulationtime_;
}
inline ::pulse::cdm::bind::ScalarTimeData* StateData::mutable_simulationtime() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.SimulationTime)
  return _internal_mutable_simulationtime();
}
inline void StateData::set_allocated_simulationtime(::pulse::cdm::bind::ScalarTimeData* simulationtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(simulationtime_);
  }
  if (simulationtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      simulationtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simulationtime, submessage_arena);
    }
    
  } else {
    
  }
  simulationtime_ = simulationtime;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.SimulationTime)
}

// .pulse.cdm.bind.PatientData CurrentPatient = 4;
inline bool StateData::_internal_has_currentpatient() const {
  return this != internal_default_instance() && currentpatient_ != nullptr;
}
inline bool StateData::has_currentpatient() const {
  return _internal_has_currentpatient();
}
inline const ::pulse::cdm::bind::PatientData& StateData::_internal_currentpatient() const {
  const ::pulse::cdm::bind::PatientData* p = currentpatient_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::PatientData*>(
      &::pulse::cdm::bind::_PatientData_default_instance_);
}
inline const ::pulse::cdm::bind::PatientData& StateData::currentpatient() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.CurrentPatient)
  return _internal_currentpatient();
}
inline ::pulse::cdm::bind::PatientData* StateData::release_currentpatient() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.CurrentPatient)
  
  ::pulse::cdm::bind::PatientData* temp = currentpatient_;
  currentpatient_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::PatientData* StateData::_internal_mutable_currentpatient() {
  
  if (currentpatient_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::PatientData>(GetArenaNoVirtual());
    currentpatient_ = p;
  }
  return currentpatient_;
}
inline ::pulse::cdm::bind::PatientData* StateData::mutable_currentpatient() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.CurrentPatient)
  return _internal_mutable_currentpatient();
}
inline void StateData::set_allocated_currentpatient(::pulse::cdm::bind::PatientData* currentpatient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(currentpatient_);
  }
  if (currentpatient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      currentpatient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, currentpatient, submessage_arena);
    }
    
  } else {
    
  }
  currentpatient_ = currentpatient;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.CurrentPatient)
}

// .pulse.cdm.bind.PatientData InitialPatient = 5;
inline bool StateData::_internal_has_initialpatient() const {
  return this != internal_default_instance() && initialpatient_ != nullptr;
}
inline bool StateData::has_initialpatient() const {
  return _internal_has_initialpatient();
}
inline const ::pulse::cdm::bind::PatientData& StateData::_internal_initialpatient() const {
  const ::pulse::cdm::bind::PatientData* p = initialpatient_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::PatientData*>(
      &::pulse::cdm::bind::_PatientData_default_instance_);
}
inline const ::pulse::cdm::bind::PatientData& StateData::initialpatient() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.InitialPatient)
  return _internal_initialpatient();
}
inline ::pulse::cdm::bind::PatientData* StateData::release_initialpatient() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.InitialPatient)
  
  ::pulse::cdm::bind::PatientData* temp = initialpatient_;
  initialpatient_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::PatientData* StateData::_internal_mutable_initialpatient() {
  
  if (initialpatient_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::PatientData>(GetArenaNoVirtual());
    initialpatient_ = p;
  }
  return initialpatient_;
}
inline ::pulse::cdm::bind::PatientData* StateData::mutable_initialpatient() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.InitialPatient)
  return _internal_mutable_initialpatient();
}
inline void StateData::set_allocated_initialpatient(::pulse::cdm::bind::PatientData* initialpatient) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(initialpatient_);
  }
  if (initialpatient) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      initialpatient = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initialpatient, submessage_arena);
    }
    
  } else {
    
  }
  initialpatient_ = initialpatient;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.InitialPatient)
}

// .pulse.cdm.bind.ConditionListData Conditions = 6;
inline bool StateData::_internal_has_conditions() const {
  return this != internal_default_instance() && conditions_ != nullptr;
}
inline bool StateData::has_conditions() const {
  return _internal_has_conditions();
}
inline const ::pulse::cdm::bind::ConditionListData& StateData::_internal_conditions() const {
  const ::pulse::cdm::bind::ConditionListData* p = conditions_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::ConditionListData*>(
      &::pulse::cdm::bind::_ConditionListData_default_instance_);
}
inline const ::pulse::cdm::bind::ConditionListData& StateData::conditions() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Conditions)
  return _internal_conditions();
}
inline ::pulse::cdm::bind::ConditionListData* StateData::release_conditions() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Conditions)
  
  ::pulse::cdm::bind::ConditionListData* temp = conditions_;
  conditions_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ConditionListData* StateData::_internal_mutable_conditions() {
  
  if (conditions_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ConditionListData>(GetArenaNoVirtual());
    conditions_ = p;
  }
  return conditions_;
}
inline ::pulse::cdm::bind::ConditionListData* StateData::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Conditions)
  return _internal_mutable_conditions();
}
inline void StateData::set_allocated_conditions(::pulse::cdm::bind::ConditionListData* conditions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(conditions_);
  }
  if (conditions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      conditions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conditions, submessage_arena);
    }
    
  } else {
    
  }
  conditions_ = conditions;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Conditions)
}

// .pulse.cdm.bind.ActionListData ActiveActions = 7;
inline bool StateData::_internal_has_activeactions() const {
  return this != internal_default_instance() && activeactions_ != nullptr;
}
inline bool StateData::has_activeactions() const {
  return _internal_has_activeactions();
}
inline const ::pulse::cdm::bind::ActionListData& StateData::_internal_activeactions() const {
  const ::pulse::cdm::bind::ActionListData* p = activeactions_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::ActionListData*>(
      &::pulse::cdm::bind::_ActionListData_default_instance_);
}
inline const ::pulse::cdm::bind::ActionListData& StateData::activeactions() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.ActiveActions)
  return _internal_activeactions();
}
inline ::pulse::cdm::bind::ActionListData* StateData::release_activeactions() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.ActiveActions)
  
  ::pulse::cdm::bind::ActionListData* temp = activeactions_;
  activeactions_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ActionListData* StateData::_internal_mutable_activeactions() {
  
  if (activeactions_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ActionListData>(GetArenaNoVirtual());
    activeactions_ = p;
  }
  return activeactions_;
}
inline ::pulse::cdm::bind::ActionListData* StateData::mutable_activeactions() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.ActiveActions)
  return _internal_mutable_activeactions();
}
inline void StateData::set_allocated_activeactions(::pulse::cdm::bind::ActionListData* activeactions) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activeactions_);
  }
  if (activeactions) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activeactions = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activeactions, submessage_arena);
    }
    
  } else {
    
  }
  activeactions_ = activeactions;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.ActiveActions)
}

// .pulse.cdm.bind.ActiveEventListData ActiveEvents = 8;
inline bool StateData::_internal_has_activeevents() const {
  return this != internal_default_instance() && activeevents_ != nullptr;
}
inline bool StateData::has_activeevents() const {
  return _internal_has_activeevents();
}
inline const ::pulse::cdm::bind::ActiveEventListData& StateData::_internal_activeevents() const {
  const ::pulse::cdm::bind::ActiveEventListData* p = activeevents_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::ActiveEventListData*>(
      &::pulse::cdm::bind::_ActiveEventListData_default_instance_);
}
inline const ::pulse::cdm::bind::ActiveEventListData& StateData::activeevents() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.ActiveEvents)
  return _internal_activeevents();
}
inline ::pulse::cdm::bind::ActiveEventListData* StateData::release_activeevents() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.ActiveEvents)
  
  ::pulse::cdm::bind::ActiveEventListData* temp = activeevents_;
  activeevents_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::ActiveEventListData* StateData::_internal_mutable_activeevents() {
  
  if (activeevents_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::ActiveEventListData>(GetArenaNoVirtual());
    activeevents_ = p;
  }
  return activeevents_;
}
inline ::pulse::cdm::bind::ActiveEventListData* StateData::mutable_activeevents() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.ActiveEvents)
  return _internal_mutable_activeevents();
}
inline void StateData::set_allocated_activeevents(::pulse::cdm::bind::ActiveEventListData* activeevents) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(activeevents_);
  }
  if (activeevents) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      activeevents = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activeevents, submessage_arena);
    }
    
  } else {
    
  }
  activeevents_ = activeevents;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.ActiveEvents)
}

// .pulse.engine.bind.BloodChemistryData BloodChemistry = 9;
inline bool StateData::_internal_has_bloodchemistry() const {
  return this != internal_default_instance() && bloodchemistry_ != nullptr;
}
inline bool StateData::has_bloodchemistry() const {
  return _internal_has_bloodchemistry();
}
inline const ::pulse::engine::bind::BloodChemistryData& StateData::_internal_bloodchemistry() const {
  const ::pulse::engine::bind::BloodChemistryData* p = bloodchemistry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::BloodChemistryData*>(
      &::pulse::engine::bind::_BloodChemistryData_default_instance_);
}
inline const ::pulse::engine::bind::BloodChemistryData& StateData::bloodchemistry() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.BloodChemistry)
  return _internal_bloodchemistry();
}
inline ::pulse::engine::bind::BloodChemistryData* StateData::release_bloodchemistry() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.BloodChemistry)
  
  ::pulse::engine::bind::BloodChemistryData* temp = bloodchemistry_;
  bloodchemistry_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::BloodChemistryData* StateData::_internal_mutable_bloodchemistry() {
  
  if (bloodchemistry_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::BloodChemistryData>(GetArenaNoVirtual());
    bloodchemistry_ = p;
  }
  return bloodchemistry_;
}
inline ::pulse::engine::bind::BloodChemistryData* StateData::mutable_bloodchemistry() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.BloodChemistry)
  return _internal_mutable_bloodchemistry();
}
inline void StateData::set_allocated_bloodchemistry(::pulse::engine::bind::BloodChemistryData* bloodchemistry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bloodchemistry_);
  }
  if (bloodchemistry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bloodchemistry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bloodchemistry, submessage_arena);
    }
    
  } else {
    
  }
  bloodchemistry_ = bloodchemistry;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.BloodChemistry)
}

// .pulse.engine.bind.CardiovascularData Cardiovascular = 10;
inline bool StateData::_internal_has_cardiovascular() const {
  return this != internal_default_instance() && cardiovascular_ != nullptr;
}
inline bool StateData::has_cardiovascular() const {
  return _internal_has_cardiovascular();
}
inline const ::pulse::engine::bind::CardiovascularData& StateData::_internal_cardiovascular() const {
  const ::pulse::engine::bind::CardiovascularData* p = cardiovascular_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::CardiovascularData*>(
      &::pulse::engine::bind::_CardiovascularData_default_instance_);
}
inline const ::pulse::engine::bind::CardiovascularData& StateData::cardiovascular() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Cardiovascular)
  return _internal_cardiovascular();
}
inline ::pulse::engine::bind::CardiovascularData* StateData::release_cardiovascular() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Cardiovascular)
  
  ::pulse::engine::bind::CardiovascularData* temp = cardiovascular_;
  cardiovascular_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::CardiovascularData* StateData::_internal_mutable_cardiovascular() {
  
  if (cardiovascular_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::CardiovascularData>(GetArenaNoVirtual());
    cardiovascular_ = p;
  }
  return cardiovascular_;
}
inline ::pulse::engine::bind::CardiovascularData* StateData::mutable_cardiovascular() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Cardiovascular)
  return _internal_mutable_cardiovascular();
}
inline void StateData::set_allocated_cardiovascular(::pulse::engine::bind::CardiovascularData* cardiovascular) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cardiovascular_);
  }
  if (cardiovascular) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cardiovascular = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cardiovascular, submessage_arena);
    }
    
  } else {
    
  }
  cardiovascular_ = cardiovascular;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Cardiovascular)
}

// .pulse.engine.bind.DrugData Drug = 11;
inline bool StateData::_internal_has_drug() const {
  return this != internal_default_instance() && drug_ != nullptr;
}
inline bool StateData::has_drug() const {
  return _internal_has_drug();
}
inline const ::pulse::engine::bind::DrugData& StateData::_internal_drug() const {
  const ::pulse::engine::bind::DrugData* p = drug_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::DrugData*>(
      &::pulse::engine::bind::_DrugData_default_instance_);
}
inline const ::pulse::engine::bind::DrugData& StateData::drug() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Drug)
  return _internal_drug();
}
inline ::pulse::engine::bind::DrugData* StateData::release_drug() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Drug)
  
  ::pulse::engine::bind::DrugData* temp = drug_;
  drug_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::DrugData* StateData::_internal_mutable_drug() {
  
  if (drug_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::DrugData>(GetArenaNoVirtual());
    drug_ = p;
  }
  return drug_;
}
inline ::pulse::engine::bind::DrugData* StateData::mutable_drug() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Drug)
  return _internal_mutable_drug();
}
inline void StateData::set_allocated_drug(::pulse::engine::bind::DrugData* drug) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(drug_);
  }
  if (drug) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      drug = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, drug, submessage_arena);
    }
    
  } else {
    
  }
  drug_ = drug;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Drug)
}

// .pulse.engine.bind.EndocrineData Endocrine = 12;
inline bool StateData::_internal_has_endocrine() const {
  return this != internal_default_instance() && endocrine_ != nullptr;
}
inline bool StateData::has_endocrine() const {
  return _internal_has_endocrine();
}
inline const ::pulse::engine::bind::EndocrineData& StateData::_internal_endocrine() const {
  const ::pulse::engine::bind::EndocrineData* p = endocrine_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::EndocrineData*>(
      &::pulse::engine::bind::_EndocrineData_default_instance_);
}
inline const ::pulse::engine::bind::EndocrineData& StateData::endocrine() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Endocrine)
  return _internal_endocrine();
}
inline ::pulse::engine::bind::EndocrineData* StateData::release_endocrine() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Endocrine)
  
  ::pulse::engine::bind::EndocrineData* temp = endocrine_;
  endocrine_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::EndocrineData* StateData::_internal_mutable_endocrine() {
  
  if (endocrine_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::EndocrineData>(GetArenaNoVirtual());
    endocrine_ = p;
  }
  return endocrine_;
}
inline ::pulse::engine::bind::EndocrineData* StateData::mutable_endocrine() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Endocrine)
  return _internal_mutable_endocrine();
}
inline void StateData::set_allocated_endocrine(::pulse::engine::bind::EndocrineData* endocrine) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(endocrine_);
  }
  if (endocrine) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      endocrine = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endocrine, submessage_arena);
    }
    
  } else {
    
  }
  endocrine_ = endocrine;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Endocrine)
}

// .pulse.engine.bind.EnergyData Energy = 13;
inline bool StateData::_internal_has_energy() const {
  return this != internal_default_instance() && energy_ != nullptr;
}
inline bool StateData::has_energy() const {
  return _internal_has_energy();
}
inline const ::pulse::engine::bind::EnergyData& StateData::_internal_energy() const {
  const ::pulse::engine::bind::EnergyData* p = energy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::EnergyData*>(
      &::pulse::engine::bind::_EnergyData_default_instance_);
}
inline const ::pulse::engine::bind::EnergyData& StateData::energy() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Energy)
  return _internal_energy();
}
inline ::pulse::engine::bind::EnergyData* StateData::release_energy() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Energy)
  
  ::pulse::engine::bind::EnergyData* temp = energy_;
  energy_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::EnergyData* StateData::_internal_mutable_energy() {
  
  if (energy_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::EnergyData>(GetArenaNoVirtual());
    energy_ = p;
  }
  return energy_;
}
inline ::pulse::engine::bind::EnergyData* StateData::mutable_energy() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Energy)
  return _internal_mutable_energy();
}
inline void StateData::set_allocated_energy(::pulse::engine::bind::EnergyData* energy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(energy_);
  }
  if (energy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      energy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, energy, submessage_arena);
    }
    
  } else {
    
  }
  energy_ = energy;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Energy)
}

// .pulse.engine.bind.GastrointestinalData Gastrointestinal = 14;
inline bool StateData::_internal_has_gastrointestinal() const {
  return this != internal_default_instance() && gastrointestinal_ != nullptr;
}
inline bool StateData::has_gastrointestinal() const {
  return _internal_has_gastrointestinal();
}
inline const ::pulse::engine::bind::GastrointestinalData& StateData::_internal_gastrointestinal() const {
  const ::pulse::engine::bind::GastrointestinalData* p = gastrointestinal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::GastrointestinalData*>(
      &::pulse::engine::bind::_GastrointestinalData_default_instance_);
}
inline const ::pulse::engine::bind::GastrointestinalData& StateData::gastrointestinal() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Gastrointestinal)
  return _internal_gastrointestinal();
}
inline ::pulse::engine::bind::GastrointestinalData* StateData::release_gastrointestinal() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Gastrointestinal)
  
  ::pulse::engine::bind::GastrointestinalData* temp = gastrointestinal_;
  gastrointestinal_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::GastrointestinalData* StateData::_internal_mutable_gastrointestinal() {
  
  if (gastrointestinal_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::GastrointestinalData>(GetArenaNoVirtual());
    gastrointestinal_ = p;
  }
  return gastrointestinal_;
}
inline ::pulse::engine::bind::GastrointestinalData* StateData::mutable_gastrointestinal() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Gastrointestinal)
  return _internal_mutable_gastrointestinal();
}
inline void StateData::set_allocated_gastrointestinal(::pulse::engine::bind::GastrointestinalData* gastrointestinal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gastrointestinal_);
  }
  if (gastrointestinal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gastrointestinal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gastrointestinal, submessage_arena);
    }
    
  } else {
    
  }
  gastrointestinal_ = gastrointestinal;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Gastrointestinal)
}

// .pulse.engine.bind.HepaticData Hepatic = 15;
inline bool StateData::_internal_has_hepatic() const {
  return this != internal_default_instance() && hepatic_ != nullptr;
}
inline bool StateData::has_hepatic() const {
  return _internal_has_hepatic();
}
inline const ::pulse::engine::bind::HepaticData& StateData::_internal_hepatic() const {
  const ::pulse::engine::bind::HepaticData* p = hepatic_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::HepaticData*>(
      &::pulse::engine::bind::_HepaticData_default_instance_);
}
inline const ::pulse::engine::bind::HepaticData& StateData::hepatic() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Hepatic)
  return _internal_hepatic();
}
inline ::pulse::engine::bind::HepaticData* StateData::release_hepatic() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Hepatic)
  
  ::pulse::engine::bind::HepaticData* temp = hepatic_;
  hepatic_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::HepaticData* StateData::_internal_mutable_hepatic() {
  
  if (hepatic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::HepaticData>(GetArenaNoVirtual());
    hepatic_ = p;
  }
  return hepatic_;
}
inline ::pulse::engine::bind::HepaticData* StateData::mutable_hepatic() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Hepatic)
  return _internal_mutable_hepatic();
}
inline void StateData::set_allocated_hepatic(::pulse::engine::bind::HepaticData* hepatic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hepatic_);
  }
  if (hepatic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hepatic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hepatic, submessage_arena);
    }
    
  } else {
    
  }
  hepatic_ = hepatic;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Hepatic)
}

// .pulse.engine.bind.NervousData Nervous = 16;
inline bool StateData::_internal_has_nervous() const {
  return this != internal_default_instance() && nervous_ != nullptr;
}
inline bool StateData::has_nervous() const {
  return _internal_has_nervous();
}
inline const ::pulse::engine::bind::NervousData& StateData::_internal_nervous() const {
  const ::pulse::engine::bind::NervousData* p = nervous_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::NervousData*>(
      &::pulse::engine::bind::_NervousData_default_instance_);
}
inline const ::pulse::engine::bind::NervousData& StateData::nervous() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Nervous)
  return _internal_nervous();
}
inline ::pulse::engine::bind::NervousData* StateData::release_nervous() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Nervous)
  
  ::pulse::engine::bind::NervousData* temp = nervous_;
  nervous_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::NervousData* StateData::_internal_mutable_nervous() {
  
  if (nervous_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::NervousData>(GetArenaNoVirtual());
    nervous_ = p;
  }
  return nervous_;
}
inline ::pulse::engine::bind::NervousData* StateData::mutable_nervous() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Nervous)
  return _internal_mutable_nervous();
}
inline void StateData::set_allocated_nervous(::pulse::engine::bind::NervousData* nervous) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nervous_);
  }
  if (nervous) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nervous = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nervous, submessage_arena);
    }
    
  } else {
    
  }
  nervous_ = nervous;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Nervous)
}

// .pulse.engine.bind.RenalData Renal = 17;
inline bool StateData::_internal_has_renal() const {
  return this != internal_default_instance() && renal_ != nullptr;
}
inline bool StateData::has_renal() const {
  return _internal_has_renal();
}
inline const ::pulse::engine::bind::RenalData& StateData::_internal_renal() const {
  const ::pulse::engine::bind::RenalData* p = renal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::RenalData*>(
      &::pulse::engine::bind::_RenalData_default_instance_);
}
inline const ::pulse::engine::bind::RenalData& StateData::renal() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Renal)
  return _internal_renal();
}
inline ::pulse::engine::bind::RenalData* StateData::release_renal() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Renal)
  
  ::pulse::engine::bind::RenalData* temp = renal_;
  renal_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::RenalData* StateData::_internal_mutable_renal() {
  
  if (renal_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::RenalData>(GetArenaNoVirtual());
    renal_ = p;
  }
  return renal_;
}
inline ::pulse::engine::bind::RenalData* StateData::mutable_renal() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Renal)
  return _internal_mutable_renal();
}
inline void StateData::set_allocated_renal(::pulse::engine::bind::RenalData* renal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(renal_);
  }
  if (renal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      renal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renal, submessage_arena);
    }
    
  } else {
    
  }
  renal_ = renal;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Renal)
}

// .pulse.engine.bind.RespiratoryData Respiratory = 18;
inline bool StateData::_internal_has_respiratory() const {
  return this != internal_default_instance() && respiratory_ != nullptr;
}
inline bool StateData::has_respiratory() const {
  return _internal_has_respiratory();
}
inline const ::pulse::engine::bind::RespiratoryData& StateData::_internal_respiratory() const {
  const ::pulse::engine::bind::RespiratoryData* p = respiratory_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::RespiratoryData*>(
      &::pulse::engine::bind::_RespiratoryData_default_instance_);
}
inline const ::pulse::engine::bind::RespiratoryData& StateData::respiratory() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Respiratory)
  return _internal_respiratory();
}
inline ::pulse::engine::bind::RespiratoryData* StateData::release_respiratory() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Respiratory)
  
  ::pulse::engine::bind::RespiratoryData* temp = respiratory_;
  respiratory_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::RespiratoryData* StateData::_internal_mutable_respiratory() {
  
  if (respiratory_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::RespiratoryData>(GetArenaNoVirtual());
    respiratory_ = p;
  }
  return respiratory_;
}
inline ::pulse::engine::bind::RespiratoryData* StateData::mutable_respiratory() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Respiratory)
  return _internal_mutable_respiratory();
}
inline void StateData::set_allocated_respiratory(::pulse::engine::bind::RespiratoryData* respiratory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(respiratory_);
  }
  if (respiratory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      respiratory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, respiratory, submessage_arena);
    }
    
  } else {
    
  }
  respiratory_ = respiratory;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Respiratory)
}

// .pulse.engine.bind.TissueData Tissue = 19;
inline bool StateData::_internal_has_tissue() const {
  return this != internal_default_instance() && tissue_ != nullptr;
}
inline bool StateData::has_tissue() const {
  return _internal_has_tissue();
}
inline const ::pulse::engine::bind::TissueData& StateData::_internal_tissue() const {
  const ::pulse::engine::bind::TissueData* p = tissue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::TissueData*>(
      &::pulse::engine::bind::_TissueData_default_instance_);
}
inline const ::pulse::engine::bind::TissueData& StateData::tissue() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Tissue)
  return _internal_tissue();
}
inline ::pulse::engine::bind::TissueData* StateData::release_tissue() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Tissue)
  
  ::pulse::engine::bind::TissueData* temp = tissue_;
  tissue_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::TissueData* StateData::_internal_mutable_tissue() {
  
  if (tissue_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::TissueData>(GetArenaNoVirtual());
    tissue_ = p;
  }
  return tissue_;
}
inline ::pulse::engine::bind::TissueData* StateData::mutable_tissue() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Tissue)
  return _internal_mutable_tissue();
}
inline void StateData::set_allocated_tissue(::pulse::engine::bind::TissueData* tissue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tissue_);
  }
  if (tissue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tissue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tissue, submessage_arena);
    }
    
  } else {
    
  }
  tissue_ = tissue;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Tissue)
}

// .pulse.engine.bind.EnvironmentData Environment = 20;
inline bool StateData::_internal_has_environment() const {
  return this != internal_default_instance() && environment_ != nullptr;
}
inline bool StateData::has_environment() const {
  return _internal_has_environment();
}
inline const ::pulse::engine::bind::EnvironmentData& StateData::_internal_environment() const {
  const ::pulse::engine::bind::EnvironmentData* p = environment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::EnvironmentData*>(
      &::pulse::engine::bind::_EnvironmentData_default_instance_);
}
inline const ::pulse::engine::bind::EnvironmentData& StateData::environment() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Environment)
  return _internal_environment();
}
inline ::pulse::engine::bind::EnvironmentData* StateData::release_environment() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Environment)
  
  ::pulse::engine::bind::EnvironmentData* temp = environment_;
  environment_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::EnvironmentData* StateData::_internal_mutable_environment() {
  
  if (environment_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::EnvironmentData>(GetArenaNoVirtual());
    environment_ = p;
  }
  return environment_;
}
inline ::pulse::engine::bind::EnvironmentData* StateData::mutable_environment() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Environment)
  return _internal_mutable_environment();
}
inline void StateData::set_allocated_environment(::pulse::engine::bind::EnvironmentData* environment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(environment_);
  }
  if (environment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      environment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, environment, submessage_arena);
    }
    
  } else {
    
  }
  environment_ = environment;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Environment)
}

// .pulse.engine.bind.AnesthesiaMachineData AnesthesiaMachine = 21;
inline bool StateData::_internal_has_anesthesiamachine() const {
  return this != internal_default_instance() && anesthesiamachine_ != nullptr;
}
inline bool StateData::has_anesthesiamachine() const {
  return _internal_has_anesthesiamachine();
}
inline const ::pulse::engine::bind::AnesthesiaMachineData& StateData::_internal_anesthesiamachine() const {
  const ::pulse::engine::bind::AnesthesiaMachineData* p = anesthesiamachine_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::AnesthesiaMachineData*>(
      &::pulse::engine::bind::_AnesthesiaMachineData_default_instance_);
}
inline const ::pulse::engine::bind::AnesthesiaMachineData& StateData::anesthesiamachine() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.AnesthesiaMachine)
  return _internal_anesthesiamachine();
}
inline ::pulse::engine::bind::AnesthesiaMachineData* StateData::release_anesthesiamachine() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.AnesthesiaMachine)
  
  ::pulse::engine::bind::AnesthesiaMachineData* temp = anesthesiamachine_;
  anesthesiamachine_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::AnesthesiaMachineData* StateData::_internal_mutable_anesthesiamachine() {
  
  if (anesthesiamachine_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::AnesthesiaMachineData>(GetArenaNoVirtual());
    anesthesiamachine_ = p;
  }
  return anesthesiamachine_;
}
inline ::pulse::engine::bind::AnesthesiaMachineData* StateData::mutable_anesthesiamachine() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.AnesthesiaMachine)
  return _internal_mutable_anesthesiamachine();
}
inline void StateData::set_allocated_anesthesiamachine(::pulse::engine::bind::AnesthesiaMachineData* anesthesiamachine) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(anesthesiamachine_);
  }
  if (anesthesiamachine) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anesthesiamachine = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, anesthesiamachine, submessage_arena);
    }
    
  } else {
    
  }
  anesthesiamachine_ = anesthesiamachine;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.AnesthesiaMachine)
}

// .pulse.engine.bind.ElectroCardioGramData ElectroCardioGram = 22;
inline bool StateData::_internal_has_electrocardiogram() const {
  return this != internal_default_instance() && electrocardiogram_ != nullptr;
}
inline bool StateData::has_electrocardiogram() const {
  return _internal_has_electrocardiogram();
}
inline const ::pulse::engine::bind::ElectroCardioGramData& StateData::_internal_electrocardiogram() const {
  const ::pulse::engine::bind::ElectroCardioGramData* p = electrocardiogram_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::ElectroCardioGramData*>(
      &::pulse::engine::bind::_ElectroCardioGramData_default_instance_);
}
inline const ::pulse::engine::bind::ElectroCardioGramData& StateData::electrocardiogram() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.ElectroCardioGram)
  return _internal_electrocardiogram();
}
inline ::pulse::engine::bind::ElectroCardioGramData* StateData::release_electrocardiogram() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.ElectroCardioGram)
  
  ::pulse::engine::bind::ElectroCardioGramData* temp = electrocardiogram_;
  electrocardiogram_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::ElectroCardioGramData* StateData::_internal_mutable_electrocardiogram() {
  
  if (electrocardiogram_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::ElectroCardioGramData>(GetArenaNoVirtual());
    electrocardiogram_ = p;
  }
  return electrocardiogram_;
}
inline ::pulse::engine::bind::ElectroCardioGramData* StateData::mutable_electrocardiogram() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.ElectroCardioGram)
  return _internal_mutable_electrocardiogram();
}
inline void StateData::set_allocated_electrocardiogram(::pulse::engine::bind::ElectroCardioGramData* electrocardiogram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(electrocardiogram_);
  }
  if (electrocardiogram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      electrocardiogram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, electrocardiogram, submessage_arena);
    }
    
  } else {
    
  }
  electrocardiogram_ = electrocardiogram;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.ElectroCardioGram)
}

// .pulse.engine.bind.InhalerData Inhaler = 23;
inline bool StateData::_internal_has_inhaler() const {
  return this != internal_default_instance() && inhaler_ != nullptr;
}
inline bool StateData::has_inhaler() const {
  return _internal_has_inhaler();
}
inline const ::pulse::engine::bind::InhalerData& StateData::_internal_inhaler() const {
  const ::pulse::engine::bind::InhalerData* p = inhaler_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::InhalerData*>(
      &::pulse::engine::bind::_InhalerData_default_instance_);
}
inline const ::pulse::engine::bind::InhalerData& StateData::inhaler() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Inhaler)
  return _internal_inhaler();
}
inline ::pulse::engine::bind::InhalerData* StateData::release_inhaler() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Inhaler)
  
  ::pulse::engine::bind::InhalerData* temp = inhaler_;
  inhaler_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::InhalerData* StateData::_internal_mutable_inhaler() {
  
  if (inhaler_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::InhalerData>(GetArenaNoVirtual());
    inhaler_ = p;
  }
  return inhaler_;
}
inline ::pulse::engine::bind::InhalerData* StateData::mutable_inhaler() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Inhaler)
  return _internal_mutable_inhaler();
}
inline void StateData::set_allocated_inhaler(::pulse::engine::bind::InhalerData* inhaler) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(inhaler_);
  }
  if (inhaler) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inhaler = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inhaler, submessage_arena);
    }
    
  } else {
    
  }
  inhaler_ = inhaler;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Inhaler)
}

// .pulse.cdm.bind.CompartmentManagerData CompartmentManager = 24;
inline bool StateData::_internal_has_compartmentmanager() const {
  return this != internal_default_instance() && compartmentmanager_ != nullptr;
}
inline bool StateData::has_compartmentmanager() const {
  return _internal_has_compartmentmanager();
}
inline const ::pulse::cdm::bind::CompartmentManagerData& StateData::_internal_compartmentmanager() const {
  const ::pulse::cdm::bind::CompartmentManagerData* p = compartmentmanager_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::CompartmentManagerData*>(
      &::pulse::cdm::bind::_CompartmentManagerData_default_instance_);
}
inline const ::pulse::cdm::bind::CompartmentManagerData& StateData::compartmentmanager() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.CompartmentManager)
  return _internal_compartmentmanager();
}
inline ::pulse::cdm::bind::CompartmentManagerData* StateData::release_compartmentmanager() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.CompartmentManager)
  
  ::pulse::cdm::bind::CompartmentManagerData* temp = compartmentmanager_;
  compartmentmanager_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CompartmentManagerData* StateData::_internal_mutable_compartmentmanager() {
  
  if (compartmentmanager_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CompartmentManagerData>(GetArenaNoVirtual());
    compartmentmanager_ = p;
  }
  return compartmentmanager_;
}
inline ::pulse::cdm::bind::CompartmentManagerData* StateData::mutable_compartmentmanager() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.CompartmentManager)
  return _internal_mutable_compartmentmanager();
}
inline void StateData::set_allocated_compartmentmanager(::pulse::cdm::bind::CompartmentManagerData* compartmentmanager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(compartmentmanager_);
  }
  if (compartmentmanager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compartmentmanager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compartmentmanager, submessage_arena);
    }
    
  } else {
    
  }
  compartmentmanager_ = compartmentmanager;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.CompartmentManager)
}

// .pulse.cdm.bind.CircuitManagerData CircuitManager = 25;
inline bool StateData::_internal_has_circuitmanager() const {
  return this != internal_default_instance() && circuitmanager_ != nullptr;
}
inline bool StateData::has_circuitmanager() const {
  return _internal_has_circuitmanager();
}
inline const ::pulse::cdm::bind::CircuitManagerData& StateData::_internal_circuitmanager() const {
  const ::pulse::cdm::bind::CircuitManagerData* p = circuitmanager_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::CircuitManagerData*>(
      &::pulse::cdm::bind::_CircuitManagerData_default_instance_);
}
inline const ::pulse::cdm::bind::CircuitManagerData& StateData::circuitmanager() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.CircuitManager)
  return _internal_circuitmanager();
}
inline ::pulse::cdm::bind::CircuitManagerData* StateData::release_circuitmanager() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.CircuitManager)
  
  ::pulse::cdm::bind::CircuitManagerData* temp = circuitmanager_;
  circuitmanager_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::CircuitManagerData* StateData::_internal_mutable_circuitmanager() {
  
  if (circuitmanager_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::CircuitManagerData>(GetArenaNoVirtual());
    circuitmanager_ = p;
  }
  return circuitmanager_;
}
inline ::pulse::cdm::bind::CircuitManagerData* StateData::mutable_circuitmanager() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.CircuitManager)
  return _internal_mutable_circuitmanager();
}
inline void StateData::set_allocated_circuitmanager(::pulse::cdm::bind::CircuitManagerData* circuitmanager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(circuitmanager_);
  }
  if (circuitmanager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      circuitmanager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circuitmanager, submessage_arena);
    }
    
  } else {
    
  }
  circuitmanager_ = circuitmanager;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.CircuitManager)
}

// repeated .pulse.cdm.bind.SubstanceData ActiveSubstance = 26;
inline int StateData::_internal_activesubstance_size() const {
  return activesubstance_.size();
}
inline int StateData::activesubstance_size() const {
  return _internal_activesubstance_size();
}
inline ::pulse::cdm::bind::SubstanceData* StateData::mutable_activesubstance(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.ActiveSubstance)
  return activesubstance_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceData >*
StateData::mutable_activesubstance() {
  // @@protoc_insertion_point(field_mutable_list:pulse.engine.bind.StateData.ActiveSubstance)
  return &activesubstance_;
}
inline const ::pulse::cdm::bind::SubstanceData& StateData::_internal_activesubstance(int index) const {
  return activesubstance_.Get(index);
}
inline const ::pulse::cdm::bind::SubstanceData& StateData::activesubstance(int index) const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.ActiveSubstance)
  return _internal_activesubstance(index);
}
inline ::pulse::cdm::bind::SubstanceData* StateData::_internal_add_activesubstance() {
  return activesubstance_.Add();
}
inline ::pulse::cdm::bind::SubstanceData* StateData::add_activesubstance() {
  // @@protoc_insertion_point(field_add:pulse.engine.bind.StateData.ActiveSubstance)
  return _internal_add_activesubstance();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceData >&
StateData::activesubstance() const {
  // @@protoc_insertion_point(field_list:pulse.engine.bind.StateData.ActiveSubstance)
  return activesubstance_;
}

// repeated .pulse.cdm.bind.SubstanceCompoundData ActiveCompound = 27;
inline int StateData::_internal_activecompound_size() const {
  return activecompound_.size();
}
inline int StateData::activecompound_size() const {
  return _internal_activecompound_size();
}
inline ::pulse::cdm::bind::SubstanceCompoundData* StateData::mutable_activecompound(int index) {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.ActiveCompound)
  return activecompound_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceCompoundData >*
StateData::mutable_activecompound() {
  // @@protoc_insertion_point(field_mutable_list:pulse.engine.bind.StateData.ActiveCompound)
  return &activecompound_;
}
inline const ::pulse::cdm::bind::SubstanceCompoundData& StateData::_internal_activecompound(int index) const {
  return activecompound_.Get(index);
}
inline const ::pulse::cdm::bind::SubstanceCompoundData& StateData::activecompound(int index) const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.ActiveCompound)
  return _internal_activecompound(index);
}
inline ::pulse::cdm::bind::SubstanceCompoundData* StateData::_internal_add_activecompound() {
  return activecompound_.Add();
}
inline ::pulse::cdm::bind::SubstanceCompoundData* StateData::add_activecompound() {
  // @@protoc_insertion_point(field_add:pulse.engine.bind.StateData.ActiveCompound)
  return _internal_add_activecompound();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pulse::cdm::bind::SubstanceCompoundData >&
StateData::activecompound() const {
  // @@protoc_insertion_point(field_list:pulse.engine.bind.StateData.ActiveCompound)
  return activecompound_;
}

// .pulse.engine.bind.ConfigurationData Configuration = 28;
inline bool StateData::_internal_has_configuration() const {
  return this != internal_default_instance() && configuration_ != nullptr;
}
inline bool StateData::has_configuration() const {
  return _internal_has_configuration();
}
inline const ::pulse::engine::bind::ConfigurationData& StateData::_internal_configuration() const {
  const ::pulse::engine::bind::ConfigurationData* p = configuration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::engine::bind::ConfigurationData*>(
      &::pulse::engine::bind::_ConfigurationData_default_instance_);
}
inline const ::pulse::engine::bind::ConfigurationData& StateData::configuration() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.Configuration)
  return _internal_configuration();
}
inline ::pulse::engine::bind::ConfigurationData* StateData::release_configuration() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.Configuration)
  
  ::pulse::engine::bind::ConfigurationData* temp = configuration_;
  configuration_ = nullptr;
  return temp;
}
inline ::pulse::engine::bind::ConfigurationData* StateData::_internal_mutable_configuration() {
  
  if (configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::engine::bind::ConfigurationData>(GetArenaNoVirtual());
    configuration_ = p;
  }
  return configuration_;
}
inline ::pulse::engine::bind::ConfigurationData* StateData::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.Configuration)
  return _internal_mutable_configuration();
}
inline void StateData::set_allocated_configuration(::pulse::engine::bind::ConfigurationData* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration_);
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    
  } else {
    
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.Configuration)
}

// .pulse.cdm.bind.DataRequestManagerData DataRequestManager = 29;
inline bool StateData::_internal_has_datarequestmanager() const {
  return this != internal_default_instance() && datarequestmanager_ != nullptr;
}
inline bool StateData::has_datarequestmanager() const {
  return _internal_has_datarequestmanager();
}
inline const ::pulse::cdm::bind::DataRequestManagerData& StateData::_internal_datarequestmanager() const {
  const ::pulse::cdm::bind::DataRequestManagerData* p = datarequestmanager_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pulse::cdm::bind::DataRequestManagerData*>(
      &::pulse::cdm::bind::_DataRequestManagerData_default_instance_);
}
inline const ::pulse::cdm::bind::DataRequestManagerData& StateData::datarequestmanager() const {
  // @@protoc_insertion_point(field_get:pulse.engine.bind.StateData.DataRequestManager)
  return _internal_datarequestmanager();
}
inline ::pulse::cdm::bind::DataRequestManagerData* StateData::release_datarequestmanager() {
  // @@protoc_insertion_point(field_release:pulse.engine.bind.StateData.DataRequestManager)
  
  ::pulse::cdm::bind::DataRequestManagerData* temp = datarequestmanager_;
  datarequestmanager_ = nullptr;
  return temp;
}
inline ::pulse::cdm::bind::DataRequestManagerData* StateData::_internal_mutable_datarequestmanager() {
  
  if (datarequestmanager_ == nullptr) {
    auto* p = CreateMaybeMessage<::pulse::cdm::bind::DataRequestManagerData>(GetArenaNoVirtual());
    datarequestmanager_ = p;
  }
  return datarequestmanager_;
}
inline ::pulse::cdm::bind::DataRequestManagerData* StateData::mutable_datarequestmanager() {
  // @@protoc_insertion_point(field_mutable:pulse.engine.bind.StateData.DataRequestManager)
  return _internal_mutable_datarequestmanager();
}
inline void StateData::set_allocated_datarequestmanager(::pulse::cdm::bind::DataRequestManagerData* datarequestmanager) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(datarequestmanager_);
  }
  if (datarequestmanager) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      datarequestmanager = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datarequestmanager, submessage_arena);
    }
    
  } else {
    
  }
  datarequestmanager_ = datarequestmanager;
  // @@protoc_insertion_point(field_set_allocated:pulse.engine.bind.StateData.DataRequestManager)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace bind
}  // namespace engine
}  // namespace pulse

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pulse::engine::bind::eAirwayMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pulse::engine::bind::eAirwayMode>() {
  return ::pulse::engine::bind::eAirwayMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pulse_2fengine_2fbind_2fPulseState_2eproto
